<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Language" content="en" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta name="author" content="FAL Labs" />
<meta name="keywords" content="Tokyo Cabinet, tokyocabinet, database, DBM" />
<meta name="description" content="Specifications of Tokyo Cabinet" />
<link rel="contents" href="./" />
<link rel="alternate" href="spex-ja.html" hreflang="ja" title="the Japanese version" />
<link rel="stylesheet" href="common.css" />
<link rel="icon" href="icon16.png" />
<link rev="made" href="mailto:info@fallabs.com" />
<title>Fundamental Specifications of Tokyo Cabinet Version 1</title>
</head>

<body>

<h1 id="headline">Fundamental Specifications of Tokyo Cabinet Version 1</h1>

<div class="note">Copyright (C) 2006-2012 FAL Labs</div>
<div class="note">Last Update: Sat, 18 Aug 2012 11:05:00 +0900</div>
<div class="navi">[<span class="void">English</span>/<a href="spex-ja.html" hreflang="ja">Japanese</a>] [<a href="index.html">HOME</a>]</div>

<hr />

<h2 id="contents">Table of Contents</h2>

<ol>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#features">Features</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#tcutilapi">The Utility API</a></li>
<li><a href="#tchdbapi">The Hash Database API</a></li>
<li><a href="#tcbdbapi">The B+ Tree Database API</a></li>
<li><a href="#tcfdbapi">The Fixed-length Database API</a></li>
<li><a href="#tctdbapi">The Table Database API</a></li>
<li><a href="#tcadbapi">The Abstract Database API</a></li>
<li><a href="#fileformat">File Format</a></li>
<li><a href="#license">License</a></li>
</ol>

<hr />

<h2 id="introduction">Introduction</h2>

<p>Tokyo Cabinet is a library of routines for managing a database.  The database is a simple data file containing records, each is a pair of a key and a value.  Every key and value is serial bytes with variable length.  Both binary data and character string can be used as a key and a value.  There is neither concept of data tables nor data types.  Records are organized in hash table, B+ tree, or fixed-length array.</p>

<p>As for database of hash table, each key must be unique within a database, so it is impossible to store two or more records with a key overlaps.  The following access methods are provided to the database: storing a record with a key and a value, deleting a record by a key, retrieving a record by a key.  Moreover, traversal access to every key are provided, although the order is arbitrary.  These access methods are similar to ones of DBM (or its followers: NDBM and GDBM) library defined in the UNIX standard.  Tokyo Cabinet is an alternative for DBM because of its higher performance.</p>

<p>As for database of B+ tree, records whose keys are duplicated can be stored.  Access methods of storing, deleting, and retrieving are provided as with the database of hash table.  Records are stored in order by a comparison function assigned by a user.  It is possible to access each record with the cursor in ascending or descending order.  According to this mechanism, forward matching search for strings and range search for integers are realized.</p>

<p>As for database of fixed-length array, records are stored with unique natural numbers.  It is impossible to store two or more records with a key overlaps.  Moreover, the length of each record is limited by the specified length.  Provided operations are the same as ones of hash database.</p>

<p>Table database is also provided as a variant of hash database.  Each record is identified by the primary key and has a set of named columns.  Although there is no concept of data schema, it is possible to search for records with complex conditions efficiently by using indices of arbitrary columns.</p>

<p>Tokyo Cabinet is written in the C language, and provided as API of C, Perl, Ruby, Java, and Lua.  Tokyo Cabinet is available on platforms which have API conforming to C99 and POSIX.  Tokyo Cabinet is a free software licensed under the GNU Lesser General Public License.</p>

<hr />

<h2 id="features">Features</h2>

<p>Tokyo Cabinet is the successor of QDBM and improves time and space efficiency.  This section describes the features of Tokyo Cabinet.</p>

<h3 id="features_dinosaur">The Dinosaur Wing of the DBM Forks</h3>

<p>Tokyo Cabinet is developed as the successor of GDBM and QDBM on the following purposes.  They are achieved and Tokyo Cabinet replaces conventional DBM products.</p>

<ul>
<li>improves <strong>space efficiency</strong> : smaller size of database file.</li>
<li>improves <strong>time efficiency</strong> : faster processing speed.</li>
<li>improves <strong>parallelism</strong> : higher performance in multi-thread environment.</li>
<li>improves <strong>usability</strong> : simplified API.</li>
<li>improves <strong>robustness</strong> : database file is not corrupted even under catastrophic situation.</li>
<li>supports <strong>64-bit architecture</strong> : enormous memory space and database file are available.</li>
</ul>

<p>As with QDBM, the following three restrictions of traditional DBM: a process can handle only one database, the size of a key and a value is bounded, a database file is sparse, are cleared.  Moreover, the following three restrictions of QDBM: the size of a database file is limited to 2GB, environments with different byte orders can not share a database file, only one thread can search a database at the same time, are cleared.</p>

<p>Tokyo Cabinet runs very fast.  For example, elapsed time to store 1 million records is 0.7 seconds for hash database, and 1.6 seconds for B+ tree database.  Moreover, the size of database of Tokyo Cabinet is very small.  For example, overhead for a record is 16 bytes for hash database, and 5 bytes for B+ tree database.  Furthermore, scalability of Tokyo Cabinet is great.  The database size can be up to 8EB (9.22e18 bytes).</p>

<h3 id="features_tchdb">Effective Implementation of Hash Database</h3>

<p>Tokyo Cabinet uses hash algorithm to retrieve records.  If a bucket array has sufficient number of elements, the time complexity of retrieval is "O(1)".  That is, time required for retrieving a record is constant, regardless of the scale of a database.  It is also the same about storing and deleting.  Collision of hash values is managed by separate chaining.  Data structure of the chains is binary search tree.  Even if a bucket array has unusually scarce elements, the time complexity of retrieval is "O(log n)".</p>

<p>Tokyo Cabinet attains improvement in retrieval by loading RAM with the whole of a bucket array.  If a bucket array is on RAM, it is possible to access a region of a target record by about one path of file operations.  A bucket array saved in a file is not read into RAM with the `read' call but directly mapped to RAM with the `mmap' call.  Therefore, preparation time on connecting to a database is very short, and two or more processes can share the same memory map.</p>

<p>If the number of elements of a bucket array is about half of records stored within a database, although it depends on characteristic of the input, the probability of collision of hash values is about 56.7% (36.8% if the same, 21.3% if twice, 11.5% if four times, 6.0% if eight times).  In such case, it is possible to retrieve a record by two or less paths of file operations.  If it is made into a performance index, in order to handle a database containing one million of records, a bucket array with half a million of elements is needed.  The size of each element is 4 bytes.  That is, if 2M bytes of RAM is available, a database containing one million records can be handled.</p>

<p>Traditional DBM provides two modes of the storing operations: "insert" and "replace".  In the case a key overlaps an existing record, the insert mode keeps the existing value, while the replace mode transposes it to the specified value.  In addition to the two modes, Tokyo Cabinet provides "concatenate" mode.  In the mode, the specified value is concatenated at the end of the existing value and stored.  This feature is useful when adding an element to a value as an array.</p>

<p>Generally speaking, while succession of updating, fragmentation of available regions occurs, and the size of a database grows rapidly.  Tokyo Cabinet deal with this problem by coalescence of dispensable regions and reuse of them.  When overwriting a record with a value whose size is greater than the existing one, it is necessary to remove the region to another position of the file.  Because the time complexity of the operation depends on the size of the region of a record, extending values successively is inefficient.  However, Tokyo Cabinet deal with this problem by alignment.  If increment can be put in padding, it is not necessary to remove the region.</p>

<p>The "free block pool" to reuse dispensable regions efficiently is also implemented.  It keeps a list of dispensable regions and reuse the "best fit" region, that is the smallest region in the list, when a new block is requested.  Because fragmentation is inevitable even then, two kinds of optimization (defragmentation) mechanisms are implemented.  The first is called static optimization which deploys all records into another file and then writes them back to the original file at once.  The second is called dynamic optimization which gathers up dispensable regions by replacing the locations of records and dispensable regions gradually.</p>

<h3 id="features_tcbdb">Useful Implementation of B+ Tree Database</h3>

<p>Although B+ tree database is slower than hash database, it features ordering access to each record.  The order can be assigned by users.  Records of B+ tree are sorted and arranged in logical pages.  Sparse index organized in B tree that is multiway balanced tree are maintained for each page.  Thus, the time complexity of retrieval and so on is "O(log n)".  Cursor is provided to access each record in order.  The cursor can jump to a position specified by a key and can step forward or backward from the current position.  Because each page is arranged as double linked list, the time complexity of stepping cursor is "O(1)".</p>

<p>B+ tree database is implemented, based on the above hash database.  Because each page of B+ tree is stored as each record of hash database, B+ tree database inherits efficiency of storage management of hash database.  Because the header of each record is smaller and alignment of each page is adjusted according to the page size, in most cases, the size of database file is cut by half compared to one of hash database.  Although operation of many pages are required to update B+ tree, Tokyo Cabinet expedites the process by caching pages and reducing file operations.  In most cases, because whole of the sparse index is cached on memory, it is possible to retrieve a record by one or less path of file operations.</p>

<p>Each pages of B+ tree can be stored with compressed.  Two compression method; Deflate of ZLIB and Block Sorting of BZIP2, are supported.  Because each record in a page has similar patterns, high efficiency of compression is expected due to the Lempel-Ziv or the BWT algorithms.  In case handling text data, the size of a database is reduced to about 25%.  If the scale of a database is large and disk I/O is the bottleneck, featuring compression makes the processing speed improved to a large extent.</p>

<h3 id="features_tcfdb">Naive Implementation of Fixed-length Database</h3>

<p>Fixed-length database has restrictions that each key should be a natural number and that the length of each value is limited.  However, time efficiency and space efficiency are higher than the other data structures as long as the use case is within the restriction.</p>

<p>Because the whole region of the database is mapped on memory by the `mmap' call and referred as a multidimensional array, the overhead related to the file I/O is minimized.  Due to this simple structure, fixed-length database works faster than hash database, and its concurrency in multi-thread environment is prominent.</p>

<p>The size of the database is proportional to the range of keys and the limit size of each value.  That is, the smaller the range of keys is or the smaller the length of each value is, the higher the space efficiency is.  For example, if the maximum key is 1000000 and the limit size of the value is 100 bytes, the size of the database will be about 100MB.  Because regions around referred records are only loaded on the RAM, you can increase the size of the database to the size of the virtual memory.</p>

<h3 id="features_tctdb">Flexible Implementation of Table Database</h3>

<p>Table database does not express simple key/value structure but expresses a structure like a table of relational database.  Each record is identified by the primary key and has a set of multiple columns named with arbitrary strings.  For example, a stuff in your company can be expressed by a record identified by the primary key of the employee ID number and structured by columns of his name, division, salary, and so on.  Unlike relational database, table database does not need to define any data schema and can contain records of various structures different from each other.</p>

<p>Table database supports query functions with not only the primary key but also with conditions about arbitrary columns.  Each column condition is composed of the name of a column and a condition expression.  Operators of full matching, forward matching, regular expression matching, and so on are provided for the string type.  Operators of full matching, range matching and so on are provided for the number type.  Operators for tag search and full-text search are also provided.  A query can contain multiple conditions for logical intersection.  Search by multiple queries for logical union is also available.  The order of the result set can be specified as the ascending or descending order of strings or numbers.</p>

<p>You can create indices for arbitrary columns to improve performance of search and sorting.  Although columns do not have data types, indices have types for strings or numbers.  Inverted indices for space separated tokens and character N-gram tokens are also supported.  The query optimizer uses indices in suitable way according to each query.  Indices are implemented as different files of B+ tree database.</p>

<h3 id="features_practical">Practical Functionality</h3>

<p>Databases on the filesystem feature transaction mechanisms.  It is possible to commit a series of operations between the beginning and the end of the transaction in a lump, or to abort the transaction and perform rollback to the state before the transaction.  Two isolation levels are supported; serializable and read uncommitted.  Durability is secured by write ahead logging and shadow paging.</p>

<p>Tokyo Cabinet provides two modes to connect to a database: "reader" and "writer".  A reader can perform retrieving but neither storing nor deleting.  A writer can perform all access methods.  Exclusion control between processes is performed when connecting to a database by file locking.  While a writer is connected to a database, neither readers nor writers can be connected.  While a reader is connected to a database, other readers can be connect, but writers can not.  According to this mechanism, data consistency is guaranteed with simultaneous connections in multitasking environment.</p>

<p>Functions of API of Tokyo cabinet are reentrant and available in multi-thread environment.  Discrete database object can be operated in parallel entirely.  For simultaneous operations of the same database object, read-write lock is used for exclusion control.  That is, while a writing thread is operating the database, other reading threads and writing threads are blocked.  However, while a reading thread is operating the database, reading threads are not blocked.  The locking granularity of hash database and fixed-length database is per record, and that of the other databases is per file.</p>

<h3 id="features_simple">Simple but Various Interfaces</h3>

<p>Tokyo Cabinet provides simple API based on the object oriented design.  Every operation for database is encapsulated and published as lucid methods as `open' (connect), `close' (disconnect), `put' (insert), `out' (remove), `get' (retrieve), and so on.  Because the three of hash, B+ tree, and fixed-length array database APIs are very similar with each other, porting an application from one to the other is easy.  Moreover, the abstract API is provided to handle these databases with the same interface.  Applications of the abstract API can determine the type of the database in runtime.</p>

<p>The utility API is also provided.  Such fundamental data structure as list and map are included.  And, some useful features; memory pool, string processing, encoding, are also included.</p>

<p>Six kinds of API; the utility API, the hash database API, the B+ tree database API, the fixed-length database API, the table database API, and the abstract database API, are provided for the C language.  Command line interfaces are also provided corresponding to each API.  They are useful for prototyping, test, and debugging.  Except for C, Tokyo Cabinet provides APIs for Perl, Ruby, Java, and Lua.  APIs for other languages will hopefully be provided by third party.</p>

<p>In cases that multiple processes access a database at the same time or some processes access a database on a remote host, the remote service is useful.  The remote service is composed of a database server and its access library.  Applications can access the database server by using the remote database API.  The server implements HTTP and the memcached protocol partly so that client programs on almost all platforms can access the server easily.</p>

<hr />

<h2 id="installation">Installation</h2>

<p>This section describes how to install Tokyo Cabinet with the source package.  As for a binary package, see its installation manual.</p>

<h3 id="installation_preparation">Preparation</h3>

<p>Tokyo Cabinet is available on UNIX-like systems.  At least, the following environments are supported.</p>

<ul>
<li>Linux 2.4 and later (x86-32/x86-64/PowerPC/Alpha/SPARC)</li>
<li>Mac OS X 10.3 and later (x86-32/x86-64/PowerPC)</li>
</ul>

<p><code>gcc</code> 3.1 or later and <code>make</code> are required to install Tokyo Cabinet with the source package.  They are installed by default on Linux, FreeBSD and so on.</p>

<p>As Tokyo Cabinet depends on the following libraries, install them beforehand.</p>

<ul>
<li><a href="http://www.zlib.net/">zlib</a> : for loss-less data compression.  1.2.3 or later is suggested.</li>
<li><a href="http://www.bzip.org/">bzip2</a> : for loss-less data compression.  1.0.5 or later is suggested.</li>
</ul>

<h3 id="installation_installation">Installation</h3>

<p>When an archive file of Tokyo Cabinet is extracted, change the current working directory to the generated directory and perform installation.</p>

<p>Run the configuration script.</p>

<pre>./configure
</pre>

<p>Build programs.</p>

<pre>make
</pre>

<p>Perform self-diagnostic test.</p>

<pre>make check
</pre>

<p>Install programs.  This operation must be carried out by the <code>root</code> user.</p>

<pre>make install
</pre>

<h3 id="installation_result">Result</h3>

<p>When a series of work finishes, the following files will be installed.</p>

<pre>/usr/local/include/tcutil.h
/usr/local/include/tchdb.h
/usr/local/include/tcbdb.h
/usr/local/include/tcfdb.h
/usr/local/include/tctdb.h
/usr/local/include/tcadb.h
/usr/local/lib/libtokyocabinet.a
/usr/local/lib/libtokyocabinet.so.x.y.z
/usr/local/lib/libtokyocabinet.so.x
/usr/local/lib/libtokyocabinet.so
/usr/local/lib/pkgconfig/tokyocabinet.pc
/usr/local/bin/tcutest
/usr/local/bin/tcumttest
/usr/local/bin/tcucodec
/usr/local/bin/tchtest
/usr/local/bin/tchmttest
/usr/local/bin/tchmgr
/usr/local/bin/tcbmgr
/usr/local/bin/tcbtest
/usr/local/bin/tcbmttest
/usr/local/bin/tcftest
/usr/local/bin/tcfmttest
/usr/local/bin/tcfmgr
/usr/local/bin/tcttest
/usr/local/bin/tctmttest
/usr/local/bin/tctmgr
/usr/local/bin/tcatest
/usr/local/bin/tcamttest
/usr/local/bin/tcamgr
/usr/local/libexec/tcawmgr.cgi
/usr/local/share/tokyocabinet/...
/usr/local/man/man1/...
/usr/local/man/man3/...
</pre>

<h3 id="installation_option">Options of Configure</h3>

<p>The following options can be specified with `<code>./configure</code>'.</p>

<ul class="options">
<li><code>--enable-debug</code> : build for debugging.  Enable debugging symbols, do not perform optimization, and perform static linking.</li>
<li><code>--enable-devel</code> : build for development.  Enable debugging symbols, perform optimization, and perform dynamic linking.</li>
<li><code>--enable-profile</code> : build for profiling.  Enable profiling symbols, perform optimization, and perform dynamic linking.</li>
<li><code>--enable-static</code> : build by static linking.</li>
<li><code>--enable-fastest</code> : build for fastest run.</li>
<li><code>--enable-off64</code> : build with 64-bit file offset on 32-bit system.</li>
<li><code>--enable-swab</code> : build for swapping byte-orders.</li>
<li><code>--enable-uyield</code> : build for detecting race conditions.</li>
<li><code>--disable-zlib</code> : build without ZLIB compression.</li>
<li><code>--disable-bzip</code> : build without BZIP2 compression.</li>
<li><code>--disable-pthread</code> : build without POSIX thread support.</li>
<li><code>--disable-shared</code> :  avoid to build shared libraries.</li>
</ul>

<p>`<code>--prefix</code>' and other options are also available as with usual UNIX software packages.  If you want to install Tokyo Cabinet under `<code>/usr</code>' not `<code>/usr/local</code>', specify `<code>--prefix=/usr</code>'.  As well, the library search path does not include `<code>/usr/local/lib</code>', it is necessary to set the environment variable `<code>LD_LIBRARY_PATH</code>' to include `<code>/usr/local/lib</code>' before running applications of Tokyo Cabinet.</p>

<h3 id="installation_library">How to Use the Library</h3>

<p>Tokyo Cabinet provides API of the C language and it is available by programs conforming to the C89 (ANSI C) standard or the C99 standard.  As the header files of Tokyo Cabinet are provided as `<code>tcutil.h</code>', `<code>tchdb.h</code>', `<code>tcbdb.h</code>', and `<code>tcadb.h</code>', applications should include one or more of them accordingly to use the API.  As the library is provided as `<code>libtokyocabinet.a</code>' and `<code>libtokyocabinet.so</code>' and they depend on `<code>libz.so</code>', `<code>libbz2.so</code>', `<code>librt.so</code>', `<code>libpthread.so</code>', `<code>libm.so</code>', and `<code>libc.so</code>', linker options corresponding to them are required by the build command.  The typical build command is the following.</p>

<pre>gcc -I/usr/local/include tc_example.c -o tc_example \
  -L/usr/local/lib -ltokyocabinet -lz -lbz2 -lrt -lpthread -lm -lc
</pre>

<p>You can also use Tokyo Cabinet in programs written in C++.  Because each header is wrapped in C linkage (`<code>extern "C"</code>' block), you can simply include them into your C++ programs.</p>

<hr />

<h2 id="tcutilapi">The Utility API</h2>

<p>The utility API is a set of routines to handle records on memory easily.  Especially, extensible string, array list, hash map, and ordered tree are useful.  See `<code>tcutil.h</code>' for the entire specification.</p>

<h3 id="tcutilapi_description">Description</h3>

<p>To use the utility API, include `<code>tcutil.h</code>' and related standard header files.  Usually, write the following description near the front of a source file.</p>

<dl>
<dt><code>#include &lt;tcutil.h&gt;</code></dt>
<dt><code>#include &lt;stdlib.h&gt;</code></dt>
<dt><code>#include &lt;stdbool.h&gt;</code></dt>
<dt><code>#include &lt;stdint.h&gt;</code></dt>
</dl>

<p>Objects whose type is pointer to `<code>TCXSTR</code>' are used for extensible string.  An extensible string object is created with the function `<code>tcxstrnew</code>' and is deleted with the function `<code>tcxstrdel</code>'.  Objects whose type is pointer to `<code>TCLIST</code>' are used for array list.  A list object is created with the function `<code>tclistnew</code>' and is deleted with the function `<code>tclistdel</code>'.  Objects whose type is pointer to `<code>TCMAP</code>' are used for hash map.  A map object is created with the function `<code>tcmapnew</code>' and is deleted with the function `<code>tcmapdel</code>'.  Objects whose type is pointer to `<code>TCTREE</code>' are used for ordered tree.  A tree object is created with the function `<code>tctreenew</code>' and is deleted with the function `<code>tctreedel</code>'.  To avoid memory leak, it is important to delete every object when it is no longer in use.</p>

<h3 id="tcutilapi_basicapi">API of Basic Utilities</h3>

<p>The constant `tcversion' is the string containing the version information.</p>

<dl class="api">
<dt><code>extern const char *tcversion;</code></dt>
</dl>

<p>The variable `tcfatalfunc' is the pointer to the call back function for handling a fatal error.</p>

<dl class="api">
<dt><code>extern void (*tcfatalfunc)(const char *);</code></dt>
<dd>The argument specifies the error message.</dd>
<dd>The initial value of this variable is `NULL'.  If the value is `NULL', the default function is called when a fatal error occurs.  A fatal error occurs when memory allocation is failed.</dd>
</dl>

<p>The function `tcmalloc' is used in order to allocate a region on memory.</p>

<dl class="api">
<dt><code>void *tcmalloc(size_t <var>size</var>);</code></dt>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the pointer to the allocated region.</dd>
<dd>This function handles failure of memory allocation implicitly.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tccalloc' is used in order to allocate a nullified region on memory.</p>

<dl class="api">
<dt><code>void *tccalloc(size_t <var>nmemb</var>, size_t <var>size</var>);</code></dt>
<dd>`<var>nmemb</var>' specifies the number of elements.</dd>
<dd>`<var>size</var>' specifies the size of each element.</dd>
<dd>The return value is the pointer to the allocated nullified region.</dd>
<dd>This function handles failure of memory allocation implicitly.  Because the region of the return value is allocated with the `calloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcrealloc' is used in order to re-allocate a region on memory.</p>

<dl class="api">
<dt><code>void *tcrealloc(void *<var>ptr</var>, size_t <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the pointer to the re-allocated region.</dd>
<dd>This function handles failure of memory allocation implicitly.  Because the region of the return value is allocated with the `realloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmemdup' is used in order to duplicate a region on memory.</p>

<dl class="api">
<dt><code>void *tcmemdup(const void *<var>ptr</var>, size_t <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the pointer to the allocated region of the duplicate.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcstrdup' is used in order to duplicate a string on memory.</p>

<dl class="api">
<dt><code>char *tcstrdup(const void *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string.</dd>
<dd>The return value is the allocated string equivalent to the specified string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcfree' is used in order to free a region on memory.</p>

<dl class="api">
<dt><code>void tcfree(void *<var>ptr</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.  If it is `NULL', this function has no effect.</dd>
<dd>Although this function is just a wrapper of `free' call, this is useful in applications using another package of the `malloc' series.</dd>
</dl>

<h3 id="tcutilapi_xstrapi">API of Extensible String</h3>

<p>The function `tcxstrnew' is used in order to create an extensible string object.</p>

<dl class="api">
<dt><code>TCXSTR *tcxstrnew(void);</code></dt>
<dd>The return value is the new extensible string object.</dd>
</dl>

<p>The function `tcxstrnew2' is used in order to create an extensible string object from a character string.</p>

<dl class="api">
<dt><code>TCXSTR *tcxstrnew2(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string of the initial content.</dd>
<dd>The return value is the new extensible string object containing the specified string.</dd>
</dl>

<p>The function `tcxstrnew3' is used in order to create an extensible string object with the initial allocation size.</p>

<dl class="api">
<dt><code>TCXSTR *tcxstrnew3(int <var>asiz</var>);</code></dt>
<dd>`<var>asiz</var>' specifies the initial allocation size.</dd>
<dd>The return value is the new extensible string object.</dd>
</dl>

<p>The function `tcxstrdup' is used in order to copy an extensible string object.</p>

<dl class="api">
<dt><code>TCXSTR *tcxstrdup(const TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>The return value is the new extensible string object equivalent to the specified object.</dd>
</dl>

<p>The function `tcxstrdel' is used in order to delete an extensible string object.</p>

<dl class="api">
<dt><code>void tcxstrdel(TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tcxstrcat' is used in order to concatenate a region to the end of an extensible string object.</p>

<dl class="api">
<dt><code>void tcxstrcat(TCXSTR *<var>xstr</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region to be appended.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
</dl>

<p>The function `tcxstrcat2' is used in order to concatenate a character string to the end of an extensible string object.</p>

<dl class="api">
<dt><code>void tcxstrcat2(TCXSTR *<var>xstr</var>, const char *<var>str</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>`<var>str</var>' specifies the string to be appended.</dd>
</dl>

<p>The function `tcxstrptr' is used in order to get the pointer of the region of an extensible string object.</p>

<dl class="api">
<dt><code>const void *tcxstrptr(const TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>The return value is the pointer of the region of the object.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.</dd>
</dl>

<p>The function `tcxstrsize' is used in order to get the size of the region of an extensible string object.</p>

<dl class="api">
<dt><code>int tcxstrsize(const TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>The return value is the size of the region of the object.</dd>
</dl>

<p>The function `tcxstrclear' is used in order to clear an extensible string object.</p>

<dl class="api">
<dt><code>void tcxstrclear(TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>The internal buffer of the object is cleared and the size is set zero.</dd>
</dl>

<p>The function `tcxstrprintf' is used in order to perform formatted output into an extensible string object.</p>

<dl class="api">
<dt><code>void tcxstrprintf(TCXSTR *<var>xstr</var>, const char *<var>format</var>, ...);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>`<var>format</var>' specifies the printf-like format string.  The conversion character `%' can be used with such flag characters as `s', `d', `o', `u', `x', `X', `c', `e', `E', `f', `g', `G', `@', `?', `b', and `%'.  `@' works as with `s' but escapes meta characters of XML.  `?' works as with `s' but escapes meta characters of URL.  `b' converts an integer to the string as binary numbers.  The other conversion character work as with each original.</dd>
<dd>The other arguments are used according to the format string.</dd>
</dl>

<p>The function `tcsprintf' is used in order to allocate a formatted string on memory.</p>

<dl class="api">
<dt><code>char *tcsprintf(const char *<var>format</var>, ...);</code></dt>
<dd>`<var>format</var>' specifies the printf-like format string.  The conversion character `%' can be used with such flag characters as `s', `d', `o', `u', `x', `X', `c', `e', `E', `f', `g', `G', `@', `?', `b', and `%'.  `@' works as with `s' but escapes meta characters of XML.  `?' works as with `s' but escapes meta characters of URL.  `b' converts an integer to the string as binary numbers.  The other conversion character work as with each original.</dd>
<dd>The other arguments are used according to the format string.</dd>
<dd>The return value is the pointer to the region of the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<h3 id="tcutilapi_listapi">API of Array List</h3>

<p>The function `tclistnew' is used in order to create a list object.</p>

<dl class="api">
<dt><code>TCLIST *tclistnew(void);</code></dt>
<dd>The return value is the new list object.</dd>
</dl>

<p>The function `tclistnew2' is used in order to create a list object with expecting the number of elements.</p>

<dl class="api">
<dt><code>TCLIST *tclistnew2(int <var>anum</var>);</code></dt>
<dd>`<var>anum</var>' specifies the number of elements expected to be stored in the list.</dd>
<dd>The return value is the new list object.</dd>
</dl>

<p>The function `tclistnew3' is used in order to create a list object with initial string elements.</p>

<dl class="api">
<dt><code>TCLIST *tclistnew3(const char *<var>str</var>, ...);</code></dt>
<dd>`<var>str</var>' specifies the string of the first element.</dd>
<dd>The other arguments are other elements.  They should be trailed by a `NULL' argument.</dd>
<dd>The return value is the new list object.</dd>
</dl>

<p>The function `tclistdup' is used in order to copy a list object.</p>

<dl class="api">
<dt><code>TCLIST *tclistdup(const TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>The return value is the new list object equivalent to the specified object.</dd>
</dl>

<p>The function `tclistdel' is used in order to delete a list object.</p>

<dl class="api">
<dt><code>void tclistdel(TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tclistnum' is used in order to get the number of elements of a list object.</p>

<dl class="api">
<dt><code>int tclistnum(const TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>The return value is the number of elements of the list.</dd>
</dl>

<p>The function `tclistval' is used in order to get the pointer to the region of an element of a list object.</p>

<dl class="api">
<dt><code>const void *tclistval(const TCLIST *<var>list</var>, int <var>index</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the element.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the value.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  If `index' is equal to or more than the number of elements, the return value is `NULL'.</dd>
</dl>

<p>The function `tclistval2' is used in order to get the string of an element of a list object.</p>

<dl class="api">
<dt><code>const char *tclistval2(const TCLIST *<var>list</var>, int <var>index</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the element.</dd>
<dd>The return value is the string of the value.</dd>
<dd>If `index' is equal to or more than the number of elements, the return value is `NULL'.</dd>
</dl>

<p>The function `tclistpush' is used in order to add an element at the end of a list object.</p>

<dl class="api">
<dt><code>void tclistpush(TCLIST *<var>list</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region of the new element.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
</dl>

<p>The function `tclistpush2' is used in order to add a string element at the end of a list object.</p>

<dl class="api">
<dt><code>void tclistpush2(TCLIST *<var>list</var>, const char *<var>str</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>str</var>' specifies the string of the new element.</dd>
</dl>

<p>The function `tclistpop' is used in order to remove an element of the end of a list object.</p>

<dl class="api">
<dt><code>void *tclistpop(TCLIST *<var>list</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the removed element.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If the list is empty, the return value is `NULL'.</dd>
</dl>

<p>The function `tclistpop2' is used in order to remove a string element of the end of a list object.</p>

<dl class="api">
<dt><code>char *tclistpop2(TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>The return value is the string of the removed element.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If the list is empty, the return value is `NULL'.</dd>
</dl>

<p>The function `tclistunshift' is used in order to add an element at the top of a list object.</p>

<dl class="api">
<dt><code>void tclistunshift(TCLIST *<var>list</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region of the new element.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
</dl>

<p>The function `tclistunshift2' is used in order to add a string element at the top of a list object.</p>

<dl class="api">
<dt><code>void tclistunshift2(TCLIST *<var>list</var>, const char *<var>str</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>str</var>' specifies the string of the new element.</dd>
</dl>

<p>The function `tclistshift' is used in order to remove an element of the top of a list object.</p>

<dl class="api">
<dt><code>void *tclistshift(TCLIST *<var>list</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the removed element.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If the list is empty, the return value is `NULL'.</dd>
</dl>

<p>The function `tclistshift2' is used in order to remove a string element of the top of a list object.</p>

<dl class="api">
<dt><code>char *tclistshift2(TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>The return value is the string of the removed element.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If the list is empty, the return value is `NULL'.</dd>
</dl>

<p>The function `tclistinsert' is used in order to add an element at the specified location of a list object.</p>

<dl class="api">
<dt><code>void tclistinsert(TCLIST *<var>list</var>, int <var>index</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the new element.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region of the new element.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>If `index' is equal to or more than the number of elements, this function has no effect.</dd>
</dl>

<p>The function `tclistinsert2' is used in order to add a string element at the specified location of a list object.</p>

<dl class="api">
<dt><code>void tclistinsert2(TCLIST *<var>list</var>, int <var>index</var>, const char *<var>str</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the new element.</dd>
<dd>`<var>str</var>' specifies the string of the new element.</dd>
<dd>If `index' is equal to or more than the number of elements, this function has no effect.</dd>
</dl>

<p>The function `tclistremove' is used in order to remove an element at the specified location of a list object.</p>

<dl class="api">
<dt><code>void *tclistremove(TCLIST *<var>list</var>, int <var>index</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the element to be removed.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the removed element.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If `index' is equal to or more than the number of elements, no element is removed and the return value is `NULL'.</dd>
</dl>

<p>The function `tclistremove2' is used in order to remove a string element at the specified location of a list object.</p>

<dl class="api">
<dt><code>char *tclistremove2(TCLIST *<var>list</var>, int <var>index</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the element to be removed.</dd>
<dd>The return value is the string of the removed element.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If `index' is equal to or more than the number of elements, no element is removed and the return value is `NULL'.</dd>
</dl>

<p>The function `tclistover' is used in order to overwrite an element at the specified location of a list object.</p>

<dl class="api">
<dt><code>void tclistover(TCLIST *<var>list</var>, int <var>index</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the element to be overwritten.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region of the new content.</dd>
<dd>`<var>size</var>' specifies the size of the new content.</dd>
<dd>If `index' is equal to or more than the number of elements, this function has no effect.</dd>
</dl>

<p>The function `tclistover2' is used in order to overwrite a string element at the specified location of a list object.</p>

<dl class="api">
<dt><code>void tclistover2(TCLIST *<var>list</var>, int <var>index</var>, const char *<var>str</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the element to be overwritten.</dd>
<dd>`<var>str</var>' specifies the string of the new content.</dd>
<dd>If `index' is equal to or more than the number of elements, this function has no effect.</dd>
</dl>

<p>The function `tclistsort' is used in order to sort elements of a list object in lexical order.</p>

<dl class="api">
<dt><code>void tclistsort(TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
</dl>

<p>The function `tclistlsearch' is used in order to search a list object for an element using liner search.</p>

<dl class="api">
<dt><code>int tclistlsearch(const TCLIST *<var>list</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the index of a corresponding element or -1 if there is no corresponding element.</dd>
<dd>If two or more elements correspond, the former returns.</dd>
</dl>

<p>The function `tclistbsearch' is used in order to search a list object for an element using binary search.</p>

<dl class="api">
<dt><code>int tclistbsearch(const TCLIST *<var>list</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.  It should be sorted in lexical order.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the index of a corresponding element or -1 if there is no corresponding element.</dd>
<dd>If two or more elements correspond, which returns is not defined.</dd>
</dl>

<p>The function `tclistclear' is used in order to clear a list object.</p>

<dl class="api">
<dt><code>void tclistclear(TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>All elements are removed.</dd>
</dl>

<p>The function `tclistdump' is used in order to serialize a list object into a byte array.</p>

<dl class="api">
<dt><code>void *tclistdump(const TCLIST *<var>list</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the result serial region.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tclistload' is used in order to create a list object from a serialized byte array.</p>

<dl class="api">
<dt><code>TCLIST *tclistload(const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region of serialized byte array.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is a new list object.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<h3 id="tcutilapi_mapapi">API of Hash Map</h3>

<p>The function `tcmapnew' is used in order to create a map object.</p>

<dl class="api">
<dt><code>TCMAP *tcmapnew(void);</code></dt>
<dd>The return value is the new map object.</dd>
</dl>

<p>The function `tcmapnew2' is used in order to create a map object with specifying the number of the buckets.</p>

<dl class="api">
<dt><code>TCMAP *tcmapnew2(uint32_t <var>bnum</var>);</code></dt>
<dd>`<var>bnum</var>' specifies the number of the buckets.</dd>
<dd>The return value is the new map object.</dd>
</dl>

<p>The function `tcmapnew3' is used in order to create a map object with initial string elements.</p>

<dl class="api">
<dt><code>TCMAP *tcmapnew3(const char *<var>str</var>, ...);</code></dt>
<dd>`<var>str</var>' specifies the string of the first element.</dd>
<dd>The other arguments are other elements.  They should be trailed by a `NULL' argument.</dd>
<dd>The return value is the new map object.</dd>
<dd>The key and the value of each record are situated one after the other.</dd>
</dl>

<p>The function `tcmapdup' is used in order to copy a map object.</p>

<dl class="api">
<dt><code>TCMAP *tcmapdup(const TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>The return value is the new map object equivalent to the specified object.</dd>
</dl>

<p>The function `tcmapdel' is used in order to delete a map object.</p>

<dl class="api">
<dt><code>void tcmapdel(TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tcmapput' is used in order to store a record into a map object.</p>

<dl class="api">
<dt><code>void tcmapput(TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If a record with the same key exists in the map, it is overwritten.</dd>
</dl>

<p>The function `tcmapput2' is used in order to store a string record into a map object.</p>

<dl class="api">
<dt><code>void tcmapput2(TCMAP *<var>map</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If a record with the same key exists in the map, it is overwritten.</dd>
</dl>

<p>The function `tcmapputkeep' is used in order to store a new record into a map object.</p>

<dl class="api">
<dt><code>bool tcmapputkeep(TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the map, this function has no effect.</dd>
</dl>

<p>The function `tcmapputkeep2' is used in order to store a new string record into a map object.</p>

<dl class="api">
<dt><code>bool tcmapputkeep2(TCMAP *<var>map</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the map, this function has no effect.</dd>
</dl>

<p>The function `tcmapputcat' is used in order to concatenate a value at the end of the value of the existing record in a map object.</p>

<dl class="api">
<dt><code>void tcmapputcat(TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcmapputcat2' is used in order to concatenate a string value at the end of the value of the existing record in a map object.</p>

<dl class="api">
<dt><code>void tcmapputcat2(TCMAP *<var>map</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcmapout' is used in order to remove a record of a map object.</p>

<dl class="api">
<dt><code>bool tcmapout(TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcmapout2' is used in order to remove a string record of a map object.</p>

<dl class="api">
<dt><code>bool tcmapout2(TCMAP *<var>map</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcmapget' is used in order to retrieve a record in a map object.</p>

<dl class="api">
<dt><code>const void *tcmapget(const TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.</dd>
</dl>

<p>The function `tcmapget2' is used in order to retrieve a string record in a map object.</p>

<dl class="api">
<dt><code>const char *tcmapget2(const TCMAP *<var>map</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
</dl>

<p>The function `tcmapmove' is used in order to move a record to the edge of a map object.</p>

<dl class="api">
<dt><code>bool tcmapmove(TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, bool <var>head</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of a key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>head</var>' specifies the destination which is the head if it is true or the tail if else.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcmapmove2' is used in order to move a string record to the edge of a map object.</p>

<dl class="api">
<dt><code>bool tcmapmove2(TCMAP *<var>map</var>, const char *<var>kstr</var>, bool <var>head</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kstr</var>' specifies the string of a key.</dd>
<dd>`<var>head</var>' specifies the destination which is the head if it is true or the tail if else.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcmapiterinit' is used in order to initialize the iterator of a map object.</p>

<dl class="api">
<dt><code>void tcmapiterinit(TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>The iterator is used in order to access the key of every record stored in the map object.</dd>
</dl>

<p>The function `tcmapiternext' is used in order to get the next key of the iterator of a map object.</p>

<dl class="api">
<dt><code>const void *tcmapiternext(TCMAP *<var>map</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  The order of iteration is assured to be the same as the stored order.</dd>
</dl>

<p>The function `tcmapiternext2' is used in order to get the next key string of the iterator of a map object.</p>

<dl class="api">
<dt><code>const char *tcmapiternext2(TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</dd>
<dd>The order of iteration is assured to be the same as the stored order.</dd>
</dl>

<p>The function `tcmaprnum' is used in order to get the number of records stored in a map object.</p>

<dl class="api">
<dt><code>uint64_t tcmaprnum(const TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>The return value is the number of the records stored in the map object.</dd>
</dl>

<p>The function `tcmapmsiz' is used in order to get the total size of memory used in a map object.</p>

<dl class="api">
<dt><code>uint64_t tcmapmsiz(const TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>The return value is the total size of memory used in a map object.</dd>
</dl>

<p>The function `tcmapkeys' is used in order to create a list object containing all keys in a map object.</p>

<dl class="api">
<dt><code>TCLIST *tcmapkeys(const TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>The return value is the new list object containing all keys in the map object.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcmapvals' is used in order to create a list object containing all values in a map object.</p>

<dl class="api">
<dt><code>TCLIST *tcmapvals(const TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>The return value is the new list object containing all values in the map object.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcmapaddint' is used in order to add an integer to a record in a map object.</p>

<dl class="api">
<dt><code>int tcmapaddint(TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int <var>num</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>The return value is the summation value.</dd>
<dd>If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcmapadddouble' is used in order to add a real number to a record in a map object.</p>

<dl class="api">
<dt><code>double tcmapadddouble(TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, double <var>num</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>The return value is the summation value.</dd>
<dd>If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcmapclear' is used in order to clear a map object.</p>

<dl class="api">
<dt><code>void tcmapclear(TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>All records are removed.</dd>
</dl>

<p>The function `tcmapcutfront' is used in order to remove front records of a map object.</p>

<dl class="api">
<dt><code>void tcmapcutfront(TCMAP *<var>map</var>, int <var>num</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>num</var>' specifies the number of records to be removed.</dd>
</dl>

<p>The function `tcmapdump' is used in order to serialize a map object into a byte array.</p>

<dl class="api">
<dt><code>void *tcmapdump(const TCMAP *<var>map</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the result serial region.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmapload' is used in order to create a map object from a serialized byte array.</p>

<dl class="api">
<dt><code>TCMAP *tcmapload(const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region of serialized byte array.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is a new map object.</dd>
<dd>Because the object of the return value is created with the function `tcmapnew', it should be deleted with the function `tcmapdel' when it is no longer in use.</dd>
</dl>

<h3 id="tcutilapi_treeapi">API of Ordered Tree</h3>

<p>The function `tctreenew' is used in order to create a tree object.</p>

<dl class="api">
<dt><code>TCTREE *tctreenew(void);</code></dt>
<dd>The return value is the new tree object.</dd>
</dl>

<p>The function `tctreenew2' is used in order to create a tree object with specifying the custom comparison function.</p>

<dl class="api">
<dt><code>TCTREE *tctreenew2(TCCMP <var>cmp</var>, void *<var>cmpop</var>);</code></dt>
<dd>`<var>cmp</var>' specifies the pointer to the custom comparison function.  It receives five parameters.  The first parameter is the pointer to the region of one key.  The second parameter is the size of the region of one key.  The third parameter is the pointer to the region of the other key.  The fourth parameter is the size of the region of the other key.  The fifth parameter is the pointer to the optional opaque object.  It returns positive if the former is big, negative if the latter is big, 0 if both are equivalent.</dd>
<dd>`<var>cmpop</var>' specifies an arbitrary pointer to be given as a parameter of the comparison function.  If it is not needed, `NULL' can be specified.</dd>
<dd>The return value is the new tree object.</dd>
<dd>The default comparison function compares keys of two records by lexical order.  The functions `tccmplexical' (dafault), `tccmpdecimal', `tccmpint32', and `tccmpint64' are built-in.</dd>
</dl>

<p>The function `tctreedup' is used in order to copy a tree object.</p>

<dl class="api">
<dt><code>TCTREE *tctreedup(const TCTREE *<var>tree</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>The return value is the new tree object equivalent to the specified object.</dd>
</dl>

<p>The function `tctreedel' is used in order to delete a tree object.</p>

<dl class="api">
<dt><code>void tctreedel(TCTREE *<var>tree</var>);</code></dt>
<dd>`tree' specifies the tree object.</dd>
<dd>Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tctreeput' is used in order to store a record into a tree object.</p>

<dl class="api">
<dt><code>void tctreeput(TCTREE *<var>tree</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If a record with the same key exists in the tree, it is overwritten.</dd>
</dl>

<p>The function `tctreeput2' is used in order to store a string record into a tree object.</p>

<dl class="api">
<dt><code>void tctreeput2(TCTREE *<var>tree</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If a record with the same key exists in the tree, it is overwritten.</dd>
</dl>

<p>The function `tctreeputkeep' is used in order to store a new record into a tree object.</p>

<dl class="api">
<dt><code>bool tctreeputkeep(TCTREE *<var>tree</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the tree, this function has no effect.</dd>
</dl>

<p>The function `tctreeputkeep2' is used in order to store a new string record into a tree object.</p>

<dl class="api">
<dt><code>bool tctreeputkeep2(TCTREE *<var>tree</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the tree, this function has no effect.</dd>
</dl>

<p>The function `tctreeputcat' is used in order to concatenate a value at the end of the value of the existing record in a tree object.</p>

<dl class="api">
<dt><code>void tctreeputcat(TCTREE *<var>tree</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tctreeputcat2' is used in order to concatenate a string value at the end of the value of the existing record in a tree object.</p>

<dl class="api">
<dt><code>void tctreeputcat2(TCTREE *<var>tree</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tctreeout' is used in order to remove a record of a tree object.</p>

<dl class="api">
<dt><code>bool tctreeout(TCTREE *<var>tree</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tctreeout2' is used in order to remove a string record of a tree object.</p>

<dl class="api">
<dt><code>bool tctreeout2(TCTREE *<var>tree</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tctreeget' is used in order to retrieve a record in a tree object.</p>

<dl class="api">
<dt><code>const void *tctreeget(TCTREE *<var>tree</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.</dd>
</dl>

<p>The function `tctreeget2' is used in order to retrieve a string record in a tree object.</p>

<dl class="api">
<dt><code>const char *tctreeget2(TCTREE *<var>tree</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
</dl>

<p>The function `tctreeiterinit' is used in order to initialize the iterator of a tree object.</p>

<dl class="api">
<dt><code>void tctreeiterinit(TCTREE *<var>tree</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>The iterator is used in order to access the key of every record stored in the tree object.</dd>
</dl>

<p>The function `tctreeiternext' is used in order to get the next key of the iterator of a tree object.</p>

<dl class="api">
<dt><code>const void *tctreeiternext(TCTREE *<var>tree</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  The order of iteration is assured to be ascending of the keys.</dd>
</dl>

<p>The function `tctreeiternext2' is used in order to get the next key string of the iterator of a tree object.</p>

<dl class="api">
<dt><code>const char *tctreeiternext2(TCTREE *<var>tree</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</dd>
<dd>The order of iteration is assured to be ascending of the keys.</dd>
</dl>

<p>The function `tctreernum' is used in order to get the number of records stored in a tree object.</p>

<dl class="api">
<dt><code>uint64_t tctreernum(const TCTREE *<var>tree</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>The return value is the number of the records stored in the tree object.</dd>
</dl>

<p>The function `tctreemsiz' is used in order to get the total size of memory used in a tree object.</p>

<dl class="api">
<dt><code>uint64_t tctreemsiz(const TCTREE *<var>tree</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>The return value is the total size of memory used in a tree object.</dd>
</dl>

<p>The function `tctreekeys' is used in order to create a list object containing all keys in a tree object.</p>

<dl class="api">
<dt><code>TCLIST *tctreekeys(const TCTREE *<var>tree</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>The return value is the new list object containing all keys in the tree object.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tctreevals' is used in order to create a list object containing all values in a tree object.</p>

<dl class="api">
<dt><code>TCLIST *tctreevals(const TCTREE *<var>tree</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>The return value is the new list object containing all values in the tree object.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tctreeaddint' is used in order to add an integer to a record in a tree object.</p>

<dl class="api">
<dt><code>int tctreeaddint(TCTREE *<var>tree</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int <var>num</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>The return value is the summation value.</dd>
<dd>If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tctreeadddouble' is used in order to add a real number to a record in a tree object.</p>

<dl class="api">
<dt><code>double tctreeadddouble(TCTREE *<var>tree</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, double <var>num</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>The return value is the summation value.</dd>
<dd>If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tctreeclear' is used in order to clear a tree object.</p>

<dl class="api">
<dt><code>void tctreeclear(TCTREE *<var>tree</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>All records are removed.</dd>
</dl>

<p>The function `tctreecutfringe' is used in order to remove fringe records of a tree object.</p>

<dl class="api">
<dt><code>void tctreecutfringe(TCTREE *<var>tree</var>, int <var>num</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>num</var>' specifies the number of records to be removed.</dd>
</dl>

<p>The function `tctreedump' is used in order to serialize a tree object into a byte array.</p>

<dl class="api">
<dt><code>void *tctreedump(const TCTREE *<var>tree</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the result serial region.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tctreeload' is used in order to create a tree object from a serialized byte array.</p>

<dl class="api">
<dt><code>TCTREE *tctreeload(const void *<var>ptr</var>, int <var>size</var>, TCCMP <var>cmp</var>, void *<var>cmpop</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region of serialized byte array.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>cmp</var>' specifies the pointer to the custom comparison function.</dd>
<dd>`<var>cmpop</var>' specifies an arbitrary pointer to be given as a parameter of the comparison function.</dd>
<dd>If it is not needed, `NULL' can be specified.</dd>
<dd>The return value is a new tree object.</dd>
<dd>Because the object of the return value is created with the function `tctreenew', it should be deleted with the function `tctreedel' when it is no longer in use.</dd>
</dl>

<h3 id="tcutilapi_mdbapi">API of On-memory Hash Database</h3>

<p>The function `tcmdbnew' is used in order to create an on-memory hash database object.</p>

<dl class="api">
<dt><code>TCMDB *tcmdbnew(void);</code></dt>
<dd>The return value is the new on-memory hash database object.</dd>
<dd>The object can be shared by plural threads because of the internal mutex.</dd>
</dl>

<p>The function `tcmdbnew2' is used in order to create an on-memory hash database object with specifying the number of the buckets.</p>

<dl class="api">
<dt><code>TCMDB *tcmdbnew2(uint32_t <var>bnum</var>);</code></dt>
<dd>`<var>bnum</var>' specifies the number of the buckets.</dd>
<dd>The return value is the new on-memory hash database object.</dd>
<dd>The object can be shared by plural threads because of the internal mutex.</dd>
</dl>

<p>The function `tcmdbdel' is used in order to delete an on-memory hash database object.</p>

<dl class="api">
<dt><code>void tcmdbdel(TCMDB *<var>mdb</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
</dl>

<p>The function `tcmdbput' is used in order to store a record into an on-memory hash database object.</p>

<dl class="api">
<dt><code>void tcmdbput(TCMDB *<var>mdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcmdbput2' is used in order to store a string record into an on-memory hash database object.</p>

<dl class="api">
<dt><code>void tcmdbput2(TCMDB *<var>mdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcmdbputkeep' is used in order to store a new record into an on-memory hash database object.</p>

<dl class="api">
<dt><code>bool tcmdbputkeep(TCMDB *<var>mdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcmdbputkeep2' is used in order to store a new string record into an on-memory hash database object.</p>

<dl class="api">
<dt><code>bool tcmdbputkeep2(TCMDB *<var>mdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcmdbputcat' is used in order to concatenate a value at the end of the existing record in an on-memory hash database.</p>

<dl class="api">
<dt><code>void tcmdbputcat(TCMDB *<var>mdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcmdbputcat2' is used in order to concatenate a string at the end of the existing record in an on-memory hash database.</p>

<dl class="api">
<dt><code>void tcmdbputcat2(TCMDB *<var>mdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcmdbout' is used in order to remove a record of an on-memory hash database object.</p>

<dl class="api">
<dt><code>bool tcmdbout(TCMDB *<var>mdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcmdbout2' is used in order to remove a string record of an on-memory hash database object.</p>

<dl class="api">
<dt><code>bool tcmdbout2(TCMDB *<var>mdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcmdbget' is used in order to retrieve a record in an on-memory hash database object.</p>

<dl class="api">
<dt><code>void *tcmdbget(TCMDB *<var>mdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmdbget2' is used in order to retrieve a string record in an on-memory hash database object.</p>

<dl class="api">
<dt><code>char *tcmdbget2(TCMDB *<var>mdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmdbvsiz' is used in order to get the size of the value of a record in an on-memory hash database object.</p>

<dl class="api">
<dt><code>int tcmdbvsiz(TCMDB *<var>mdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tcmdbvsiz2' is used in order to get the size of the value of a string record in an on-memory hash database object.</p>

<dl class="api">
<dt><code>int tcmdbvsiz2(TCMDB *<var>mdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tcmdbiterinit' is used in order to initialize the iterator of an on-memory hash database object.</p>

<dl class="api">
<dt><code>void tcmdbiterinit(TCMDB *<var>mdb</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>The iterator is used in order to access the key of every record stored in the on-memory hash database.</dd>
</dl>

<p>The function `tcmdbiternext' is used in order to get the next key of the iterator of an on-memory hash database object.</p>

<dl class="api">
<dt><code>void *tcmdbiternext(TCMDB *<var>mdb</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return</dd>
<dd>value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  The order of iteration is assured to be the same as the stored order.</dd>
</dl>

<p>The function `tcmdbiternext2' is used in order to get the next key string of the iterator of an on-memory hash database object.</p>

<dl class="api">
<dt><code>char *tcmdbiternext2(TCMDB *<var>mdb</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  The order of iteration is assured to be the same as the stored order.</dd>
</dl>

<p>The function `tcmdbfwmkeys' is used in order to get forward matching keys in an on-memory hash database object.</p>

<dl class="api">
<dt><code>TCLIST *tcmdbfwmkeys(TCMDB *<var>mdb</var>, const void *<var>pbuf</var>, int <var>psiz</var>, int <var>max</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>pbuf</var>' specifies the pointer to the region of the prefix.</dd>
<dd>`<var>psiz</var>' specifies the size of the region of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</dd>
</dl>

<p>The function `tcmdbfwmkeys2' is used in order to get forward matching string keys in an on-memory hash database object.</p>

<dl class="api">
<dt><code>TCLIST *tcmdbfwmkeys2(TCMDB *<var>mdb</var>, const char *<var>pstr</var>, int <var>max</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>pstr</var>' specifies the string of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</dd>
</dl>

<p>The function `tcmdbrnum' is used in order to get the number of records stored in an on-memory hash database object.</p>

<dl class="api">
<dt><code>uint64_t tcmdbrnum(TCMDB *<var>mdb</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>The return value is the number of the records stored in the database.</dd>
</dl>

<p>The function `tcmdbmsiz' is used in order to get the total size of memory used in an on-memory hash database object.</p>

<dl class="api">
<dt><code>uint64_t tcmdbmsiz(TCMDB *<var>mdb</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>The return value is the total size of memory used in the database.</dd>
</dl>

<p>The function `tcmdbaddint' is used in order to add an integer to a record in an on-memory hash database object.</p>

<dl class="api">
<dt><code>int tcmdbaddint(TCMDB *<var>mdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int <var>num</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>The return value is the summation value.</dd>
<dd>If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcmdbadddouble' is used in order to add a real number to a record in an on-memory hash database object.</p>

<dl class="api">
<dt><code>double tcmdbadddouble(TCMDB *<var>mdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, double <var>num</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>The return value is the summation value.</dd>
<dd>If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcmdbvanish' is used in order to clear an on-memory hash database object.</p>

<dl class="api">
<dt><code>void tcmdbvanish(TCMDB *<var>mdb</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>All records are removed.</dd>
</dl>

<p>The function `tcmdbcutfront' is used in order to remove front records of an on-memory hash database object.</p>

<dl class="api">
<dt><code>void tcmdbcutfront(TCMDB *<var>mdb</var>, int <var>num</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>num</var>' specifies the number of records to be removed.</dd>
</dl>

<h3 id="tcutilapi_ndbapi">API of On-memory Tree Database</h3>

<p>The function `tcndbnew' is used in order to create an on-memory tree database object.</p>

<dl class="api">
<dt><code>TCNDB *tcndbnew(void);</code></dt>
<dd>The return value is the new on-memory tree database object.</dd>
<dd>The object can be shared by plural threads because of the internal mutex.</dd>
</dl>

<p>The function `tcndbnew2' is used in order to create an on-memory tree database object with specifying the custom comparison function.</p>

<dl class="api">
<dt><code>TCNDB *tcndbnew2(TCCMP <var>cmp</var>, void *<var>cmpop</var>);</code></dt>
<dd>`<var>cmp</var>' specifies the pointer to the custom comparison function.</dd>
<dd>`<var>cmpop</var>' specifies an arbitrary pointer to be given as a parameter of the comparison function.  If it is not needed, `NULL' can be specified.</dd>
<dd>The return value is the new on-memory tree database object.</dd>
<dd>The default comparison function compares keys of two records by lexical order.  The functions `tccmplexical' (dafault), `tccmpdecimal', `tccmpint32', and `tccmpint64' are built-in.  The object can be shared by plural threads because of the internal mutex.</dd>
</dl>

<p>The function `tcndbdel' is used in order to delete an on-memory tree database object.</p>

<dl class="api">
<dt><code>void tcndbdel(TCNDB *<var>ndb</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
</dl>

<p>The function `tcndbput' is used in order to store a record into an on-memory tree database object.</p>

<dl class="api">
<dt><code>void tcndbput(TCNDB *<var>ndb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcndbput2' is used in order to store a string record into an on-memory tree database object.</p>

<dl class="api">
<dt><code>void tcndbput2(TCNDB *<var>ndb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcndbputkeep' is used in order to store a new record into an on-memory tree database object.</p>

<dl class="api">
<dt><code>bool tcndbputkeep(TCNDB *<var>ndb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcndbputkeep2' is used in order to store a new string record into an on-memory tree database object.</p>

<dl class="api">
<dt><code>bool tcndbputkeep2(TCNDB *<var>ndb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcndbputcat' is used in order to concatenate a value at the end of the existing record in an on-memory tree database.</p>

<dl class="api">
<dt><code>void tcndbputcat(TCNDB *<var>ndb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcndbputcat2' is used in order to concatenate a string at the end of the existing record in an on-memory tree database.</p>

<dl class="api">
<dt><code>void tcndbputcat2(TCNDB *<var>ndb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcndbout' is used in order to remove a record of an on-memory tree database object.</p>

<dl class="api">
<dt><code>bool tcndbout(TCNDB *<var>ndb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcndbout2' is used in order to remove a string record of an on-memory tree database object.</p>

<dl class="api">
<dt><code>bool tcndbout2(TCNDB *<var>ndb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcndbget' is used in order to retrieve a record in an on-memory tree database object.</p>

<dl class="api">
<dt><code>void *tcndbget(TCNDB *<var>ndb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcndbget2' is used in order to retrieve a string record in an on-memory tree database object.</p>

<dl class="api">
<dt><code>char *tcndbget2(TCNDB *<var>ndb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcndbvsiz' is used in order to get the size of the value of a record in an on-memory tree database object.</p>

<dl class="api">
<dt><code>int tcndbvsiz(TCNDB *<var>ndb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tcndbvsiz2' is used in order to get the size of the value of a string record in an on-memory tree database object.</p>

<dl class="api">
<dt><code>int tcndbvsiz2(TCNDB *<var>ndb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tcndbiterinit' is used in order to initialize the iterator of an on-memory tree database object.</p>

<dl class="api">
<dt><code>void tcndbiterinit(TCNDB *<var>ndb</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>The iterator is used in order to access the key of every record stored in the on-memory database.</dd>
</dl>

<p>The function `tcndbiternext' is used in order to get the next key of the iterator of an on-memory tree database object.</p>

<dl class="api">
<dt><code>void *tcndbiternext(TCNDB *<var>ndb</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  The order of iteration is assured to be the same as the stored order.</dd>
</dl>

<p>The function `tcndbiternext2' is used in order to get the next key string of the iterator of an on-memory tree database object.</p>

<dl class="api">
<dt><code>char *tcndbiternext2(TCNDB *<var>ndb</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  The order of iteration is assured to be the same as the stored order.</dd>
</dl>

<p>The function `tcndbfwmkeys' is used in order to get forward matching keys in an on-memory tree database object.</p>

<dl class="api">
<dt><code>TCLIST *tcndbfwmkeys(TCNDB *<var>ndb</var>, const void *<var>pbuf</var>, int <var>psiz</var>, int <var>max</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>pbuf</var>' specifies the pointer to the region of the prefix.</dd>
<dd>`<var>psiz</var>' specifies the size of the region of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcndbfwmkeys2' is used in order to get forward matching string keys in an on-memory tree database object.</p>

<dl class="api">
<dt><code>TCLIST *tcndbfwmkeys2(TCNDB *<var>ndb</var>, const char *<var>pstr</var>, int <var>max</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>pstr</var>' specifies the string of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcndbrnum' is used in order to get the number of records stored in an on-memory tree database object.</p>

<dl class="api">
<dt><code>uint64_t tcndbrnum(TCNDB *<var>ndb</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>The return value is the number of the records stored in the database.</dd>
</dl>

<p>The function `tcndbmsiz' is used in order to get the total size of memory used in an on-memory tree database object.</p>

<dl class="api">
<dt><code>uint64_t tcndbmsiz(TCNDB *<var>ndb</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>The return value is the total size of memory used in the database.</dd>
</dl>

<p>The function `tcndbaddint' is used in order to add an integer to a record in an on-memory tree database object.</p>

<dl class="api">
<dt><code>int tcndbaddint(TCNDB *<var>ndb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int <var>num</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>The return value is the summation value.</dd>
<dd>If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcndbadddouble' is used in order to add a real number to a record in an on-memory tree database object.</p>

<dl class="api">
<dt><code>double tcndbadddouble(TCNDB *<var>ndb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, double <var>num</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>The return value is the summation value.</dd>
<dd>If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcndbvanish' is used in order to clear an on-memory tree database object.</p>

<dl class="api">
<dt><code>void tcndbvanish(TCNDB *<var>ndb</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>All records are removed.</dd>
</dl>

<p>The function `tcndbcutfringe' is used in order to remove fringe records of an on-memory tree database object.</p>

<dl class="api">
<dt><code>void tcndbcutfringe(TCNDB *<var>ndb</var>, int <var>num</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>num</var>' specifies the number of records to be removed.</dd>
</dl>

<h3 id="tcutilapi_mpoolapi">API of Memory Pool</h3>

<p>The function `tcmpoolnew' is used in order to create a memory pool object.</p>

<dl class="api">
<dt><code>TCMPOOL *tcmpoolnew(void);</code></dt>
<dd>The return value is the new memory pool object.</dd>
</dl>

<p>The function `tcmpooldel' is used in order to delete a memory pool object.</p>

<dl class="api">
<dt><code>void tcmpooldel(TCMPOOL *<var>mpool</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tcmpoolpush' is used in order to relegate an arbitrary object to a memory pool object.</p>

<dl class="api">
<dt><code>void *tcmpoolpush(TCMPOOL *<var>mpool</var>, void *<var>ptr</var>, void (*<var>del</var>)(void *));</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the object to be relegated.  If it is `NULL', this function has no effect.</dd>
<dd>`<var>del</var>' specifies the pointer to the function to delete the object.</dd>
<dd>The return value is the pointer to the given object.</dd>
<dd>This function assures that the specified object is deleted when the memory pool object is deleted.</dd>
</dl>

<p>The function `tcmpoolpushptr' is used in order to relegate an allocated region to a memory pool object.</p>

<dl class="api">
<dt><code>void *tcmpoolpushptr(TCMPOOL *<var>mpool</var>, void *<var>ptr</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region to be relegated.  If it is `NULL', this function has no effect.</dd>
<dd>The return value is the pointer to the given object.</dd>
<dd>This function assures that the specified region is released when the memory pool object is deleted.</dd>
</dl>

<p>The function `tcmpoolpushxstr' is used in order to relegate an extensible string object to a memory pool object.</p>

<dl class="api">
<dt><code>TCXSTR *tcmpoolpushxstr(TCMPOOL *<var>mpool</var>, TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>`<var>xstr</var>' specifies the extensible string object.  If it is `NULL', this function has no effect.</dd>
<dd>The return value is the pointer to the given object.</dd>
<dd>This function assures that the specified object is deleted when the memory pool object is deleted.</dd>
</dl>

<p>The function `tcmpoolpushlist' is used in order to relegate a list object to a memory pool object.</p>

<dl class="api">
<dt><code>TCLIST *tcmpoolpushlist(TCMPOOL *<var>mpool</var>, TCLIST *<var>list</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>`<var>list</var>' specifies the list object.  If it is `NULL', this function has no effect.</dd>
<dd>The return value is the pointer to the given object.</dd>
<dd>This function assures that the specified object is deleted when the memory pool object is deleted.</dd>
</dl>

<p>The function `tcmpoolpushmap' is used in order to relegate a map object to a memory pool object.</p>

<dl class="api">
<dt><code>TCMAP *tcmpoolpushmap(TCMPOOL *<var>mpool</var>, TCMAP *<var>map</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>`<var>map</var>' specifies the map object.  If it is `NULL', this function has no effect.</dd>
<dd>The return value is the pointer to the given object.</dd>
<dd>This function assures that the specified object is deleted when the memory pool object is deleted.</dd>
</dl>

<p>The function `tcmpoolpushtree' is used in order to relegate a tree object to a memory pool object.</p>

<dl class="api">
<dt><code>TCTREE *tcmpoolpushtree(TCMPOOL *<var>mpool</var>, TCTREE *<var>tree</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>`<var>tree</var>' specifies the tree object.  If it is `NULL', this function has no effect.</dd>
<dd>The return value is the pointer to the given object.</dd>
<dd>This function assures that the specified object is deleted when the memory pool object is deleted.</dd>
</dl>

<p>The function `tcmpoolmalloc' is used in order to allocate a region relegated to a memory pool object.</p>

<dl class="api">
<dt><code>void *tcmpoolmalloc(TCMPOOL *<var>mpool</var>, size_t <var>size</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>The return value is the pointer to the allocated region under the memory pool.</dd>
</dl>

<p>The function `tcmpoolxstrnew' is used in order to create an extensible string object relegated to a memory pool object.</p>

<dl class="api">
<dt><code>TCXSTR *tcmpoolxstrnew(TCMPOOL *<var>mpool</var>);</code></dt>
<dd>The return value is the new extensible string object under the memory pool.</dd>
</dl>

<p>The function `tcmpoollistnew' is used in order to create a list object relegated to a memory pool object.</p>

<dl class="api">
<dt><code>TCLIST *tcmpoollistnew(TCMPOOL *<var>mpool</var>);</code></dt>
<dd>The return value is the new list object under the memory pool.</dd>
</dl>

<p>The function `tcmpoolmapnew' is used in order to create a map object relegated to a memory pool object.</p>

<dl class="api">
<dt><code>TCMAP *tcmpoolmapnew(TCMPOOL *<var>mpool</var>);</code></dt>
<dd>The return value is the new map object under the memory pool.</dd>
</dl>

<p>The function `tcmpooltreenew' is used in order to create a tree object relegated to a memory pool object.</p>

<dl class="api">
<dt><code>TCTREE *tcmpooltreenew(TCMPOOL *<var>mpool</var>);</code></dt>
<dd>The return value is the new tree object under the memory pool.</dd>
</dl>

<p>The function `tcmpoolpop' is used in order to remove the most recently installed cleanup handler of a memory pool object.</p>

<dl class="api">
<dt><code>void tcmpoolpop(TCMPOOL *<var>mpool</var>, bool <var>exe</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>`<var>exe</var>' specifies whether to execute the destructor of the removed handler.</dd>
</dl>

<p>The function `tcmpoolclear' is used in order to remove all cleanup handler of a memory pool object.</p>

<dl class="api">
<dt><code>void tcmpoolclear(TCMPOOL *<var>mpool</var>, bool <var>exe</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>`<var>exe</var>' specifies whether to execute the destructors of the removed handlers.</dd>
</dl>

<p>The function `tcmpoolglobal' is used in order to get the global memory pool object.</p>

<dl class="api">
<dt><code>TCMPOOL *tcmpoolglobal(void);</code></dt>
<dd>The return value is the global memory pool object.</dd>
<dd>The global memory pool object is a singleton and assured to be deleted when the process is terminating normally.</dd>
</dl>

<h3 id="tcutilapi_miscapi">API of Miscellaneous Utilities</h3>

<p>The function `tclmax' is used in order to get the larger value of two integers.</p>

<dl class="api">
<dt><code>long tclmax(long <var>a</var>, long <var>b</var>);</code></dt>
<dd>`<var>a</var>' specifies an integer.</dd>
<dd>`<var>b</var>' specifies the other integer.</dd>
<dd>The return value is the larger value of the two.</dd>
</dl>

<p>The function `tclmin' is used in order to get the lesser value of two integers.</p>

<dl class="api">
<dt><code>long tclmin(long <var>a</var>, long <var>b</var>);</code></dt>
<dd>`<var>a</var>' specifies an integer.</dd>
<dd>`<var>b</var>' specifies the other integer.</dd>
<dd>The return value is the lesser value of the two.</dd>
</dl>

<p>The function `tclrand' is used in order to get a random number as long integer based on uniform distribution.</p>

<dl class="api">
<dt><code>unsigned long tclrand(void);</code></dt>
<dd>The return value is the random number between 0 and `ULONG_MAX'.</dd>
<dd>This function uses the random number source device and generates a real random number if possible.</dd>
</dl>

<p>The function `tcdrand' is used in order to get a random number as double decimal based on uniform distribution.</p>

<dl class="api">
<dt><code>double tcdrand(void);</code></dt>
<dd>The return value is the random number equal to or greater than 0, and less than 1.0.</dd>
<dd>This function uses the random number source device and generates a real random number if possible.</dd>
</dl>

<p>The function `tcdrandnd' is used in order to get a random number as double decimal based on normal distribution.</p>

<dl class="api">
<dt><code>double tcdrandnd(double <var>avg</var>, double <var>sd</var>);</code></dt>
<dd>`<var>avg</var>' specifies the average.</dd>
<dd>`<var>sd</var>' specifies the standard deviation.</dd>
<dd>The return value is the random number.</dd>
<dd>This function uses the random number source device and generates a real random number if possible.</dd>
</dl>

<p>The function `tcstricmp' is used in order to compare two strings with case insensitive evaluation.</p>

<dl class="api">
<dt><code>int tcstricmp(const char *<var>astr</var>, const char *<var>bstr</var>);</code></dt>
<dd>`<var>astr</var>' specifies a string.</dd>
<dd>`<var>bstr</var>' specifies of the other string.</dd>
<dd>The return value is positive if the former is big, negative if the latter is big, 0 if both are equivalent.</dd>
</dl>

<p>The function `tcstrfwm' is used in order to check whether a string begins with a key.</p>

<dl class="api">
<dt><code>bool tcstrfwm(const char *<var>str</var>, const char *<var>key</var>);</code></dt>
<dd>`<var>str</var>' specifies the target string.</dd>
<dd>`<var>key</var>' specifies the forward matching key string.</dd>
<dd>The return value is true if the target string begins with the key, else, it is false.</dd>
</dl>

<p>The function `tcstrifwm' is used in order to check whether a string begins with a key with case insensitive evaluation.</p>

<dl class="api">
<dt><code>bool tcstrifwm(const char *<var>str</var>, const char *<var>key</var>);</code></dt>
<dd>`<var>str</var>' specifies the target string.</dd>
<dd>`<var>key</var>' specifies the forward matching key string.</dd>
<dd>The return value is true if the target string begins with the key, else, it is false.</dd>
</dl>

<p>The function `tcstrbwm' is used in order to check whether a string ends with a key.</p>

<dl class="api">
<dt><code>bool tcstrbwm(const char *<var>str</var>, const char *<var>key</var>);</code></dt>
<dd>`<var>str</var>' specifies the target string.</dd>
<dd>`<var>key</var>' specifies the backward matching key string.</dd>
<dd>The return value is true if the target string ends with the key, else, it is false.</dd>
</dl>

<p>The function `tcstribwm' is used in order to check whether a string ends with a key with case insensitive evaluation.</p>

<dl class="api">
<dt><code>bool tcstribwm(const char *<var>str</var>, const char *<var>key</var>);</code></dt>
<dd>`<var>str</var>' specifies the target string.</dd>
<dd>`<var>key</var>' specifies the backward matching key string.</dd>
<dd>The return value is true if the target string ends with the key, else, it is false.</dd>
</dl>

<p>The function `tcstrdist' is used in order to calculate the edit distance of two strings.</p>

<dl class="api">
<dt><code>int tcstrdist(const char *<var>astr</var>, const char *<var>bstr</var>);</code></dt>
<dd>`<var>astr</var>' specifies a string.</dd>
<dd>`<var>bstr</var>' specifies of the other string.</dd>
<dd>The return value is the edit distance which is known as the Levenshtein distance.  The cost is calculated by byte.</dd>
</dl>

<p>The function `tcstrdistutf' is used in order to calculate the edit distance of two UTF-8 strings.</p>

<dl class="api">
<dt><code>int tcstrdistutf(const char *<var>astr</var>, const char *<var>bstr</var>);</code></dt>
<dd>`<var>astr</var>' specifies a string.</dd>
<dd>`<var>bstr</var>' specifies of the other string.</dd>
<dd>The return value is the edit distance which is known as the Levenshtein distance.  The cost is calculated by Unicode character.</dd>
</dl>

<p>The function `tcstrtoupper' is used in order to convert the letters of a string into upper case.</p>

<dl class="api">
<dt><code>char *tcstrtoupper(char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string to be converted.</dd>
<dd>The return value is the string itself.</dd>
</dl>

<p>The function `tcstrtolower' is used in order to convert the letters of a string into lower case.</p>

<dl class="api">
<dt><code>char *tcstrtolower(char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string to be converted.</dd>
<dd>The return value is the string itself.</dd>
</dl>

<p>The function `tcstrtrim' is used in order to cut space characters at head or tail of a string.</p>

<dl class="api">
<dt><code>char *tcstrtrim(char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string to be converted.</dd>
<dd>The return value is the string itself.</dd>
</dl>

<p>The function `tcstrsqzspc' is used in order to squeeze space characters in a string and trim it.</p>

<dl class="api">
<dt><code>char *tcstrsqzspc(char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string to be converted.</dd>
<dd>The return value is the string itself.</dd>
</dl>

<p>The function `tcstrsubchr' is used in order to substitute characters in a string.</p>

<dl class="api">
<dt><code>char *tcstrsubchr(char *<var>str</var>, const char *<var>rstr</var>, const char *<var>sstr</var>);</code></dt>
<dd>`<var>str</var>' specifies the string to be converted.</dd>
<dd>`<var>rstr</var>' specifies the string containing characters to be replaced.</dd>
<dd>`<var>sstr</var>' specifies the string containing characters to be substituted.</dd>
<dd>If the substitute string is shorter then the replacement string, corresponding characters are removed.</dd>
</dl>

<p>The function `tcstrcntutf' is used in order to count the number of characters in a string of UTF-8.</p>

<dl class="api">
<dt><code>int tcstrcntutf(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string of UTF-8.</dd>
<dd>The return value is the number of characters in the string.</dd>
</dl>

<p>The function `tcstrcututf' is used in order to cut a string of UTF-8 at the specified number of characters.</p>

<dl class="api">
<dt><code>char *tcstrcututf(char *<var>str</var>, int <var>num</var>);</code></dt>
<dd>`<var>str</var>' specifies the string of UTF-8.</dd>
<dd>`<var>num</var>' specifies the number of characters to be kept.</dd>
<dd>The return value is the string itself.</dd>
</dl>

<p>The function `tcstrutftoucs' is used in order to convert a UTF-8 string into a UCS-2 array.</p>

<dl class="api">
<dt><code>void tcstrutftoucs(const char *<var>str</var>, uint16_t *<var>ary</var>, int *<var>np</var>);</code></dt>
<dd>`<var>str</var>' specifies the UTF-8 string.</dd>
<dd>`<var>ary</var>' specifies the pointer to the region into which the result UCS-2 codes are written.  The size of the buffer should be sufficient.</dd>
<dd>`<var>np</var>' specifies the pointer to a variable into which the number of elements of the result array is assigned.</dd>
</dl>

<p>The function `tcstrucstoutf' is used in order to convert a UCS-2 array into a UTF-8 string.</p>

<dl class="api">
<dt><code>int tcstrucstoutf(const uint16_t *<var>ary</var>, int <var>num</var>, char *<var>str</var>);</code></dt>
<dd>`<var>ary</var>' specifies the array of UCS-2 codes.</dd>
<dd>`<var>num</var>' specifies the number of the array.</dd>
<dd>`<var>str</var>' specifies the pointer to the region into which the result UTF-8 string is written.  The size of the buffer should be sufficient.</dd>
<dd>The return value is the length of the result string.</dd>
</dl>

<p>The function `tcstrsplit' is used in order to create a list object by splitting a string.</p>

<dl class="api">
<dt><code>TCLIST *tcstrsplit(const char *<var>str</var>, const char *<var>delims</var>);</code></dt>
<dd>`<var>str</var>' specifies the source string.</dd>
<dd>`<var>delims</var>' specifies a string containing delimiting characters.</dd>
<dd>The return value is a list object of the split elements.</dd>
<dd>If two delimiters are successive, it is assumed that an empty element is between the two.  Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcstrjoin' is used in order to create a string by joining all elements of a list object.</p>

<dl class="api">
<dt><code>char *tcstrjoin(const TCLIST *<var>list</var>, char <var>delim</var>);</code></dt>
<dd>`<var>list</var>' specifies a list object.</dd>
<dd>`<var>delim</var>' specifies a delimiting character.</dd>
<dd>The return value is the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcatoi' is used in order to convert a string to an integer.</p>

<dl class="api">
<dt><code>int64_t tcatoi(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string.</dd>
<dd>The return value is the integer.  If the string does not contain numeric expression, 0 is returned.</dd>
<dd>This function is equivalent to `atoll' except that it does not depend on the locale.</dd>
</dl>

<p>The function `tcatoix' is used in order to convert a string with a metric prefix to an integer.</p>

<dl class="api">
<dt><code>int64_t tcatoix(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string, which can be trailed by a binary metric prefix.  "K", "M", "G", "T", "P", and "E" are supported.  They are case-insensitive.</dd>
<dd>The return value is the integer.  If the string does not contain numeric expression, 0 is returned.  If the integer overflows the domain, `INT64_MAX' or `INT64_MIN' is returned according to the sign.</dd>
</dl>

<p>The function `tcatof' is used in order to convert a string to a real number.</p>

<dl class="api">
<dt><code>double tcatof(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string.</dd>
<dd>The return value is the real number.  If the string does not contain numeric expression, 0.0 is returned.</dd>
<dd>This function is equivalent to `atof' except that it does not depend on the locale.</dd>
</dl>

<p>The function `tcregexmatch' is used in order to check whether a string matches a regular expression.</p>

<dl class="api">
<dt><code>bool tcregexmatch(const char *<var>str</var>, const char *<var>regex</var>);</code></dt>
<dd>`<var>str</var>' specifies the target string.</dd>
<dd>`<var>regex</var>' specifies the regular expression string.  If it begins with `*', the trailing substring is used as a case-insensitive regular expression.</dd>
<dd>The return value is true if matching is success, else, it is false.</dd>
</dl>

<p>The function `tcregexreplace' is used in order to replace each substring matching a regular expression string.</p>

<dl class="api">
<dt><code>char *tcregexreplace(const char *<var>str</var>, const char *<var>regex</var>, const char *<var>alt</var>);</code></dt>
<dd>`<var>str</var>' specifies the target string.</dd>
<dd>`<var>regex</var>' specifies the regular expression string for substrings.  If it begins with `*', the trailing substring is used as a case-insensitive regular expression.</dd>
<dd>`<var>alt</var>' specifies the alternative string with which each substrings is replaced.  Each `&amp;' in the string is replaced with the matched substring.  Each `\' in the string escapes the following character.  Special escapes "\1" through "\9" referring to the corresponding matching sub-expressions in the regular expression string are supported.</dd>
<dd>The return value is a new converted string.  Even if the regular expression is invalid, a copy of the original string is returned.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmd5hash' is used in order to get the MD5 hash value of a serial object.</p>

<dl class="api">
<dt><code>void tcmd5hash(const void *<var>ptr</var>, int <var>size</var>, char *<var>buf</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>buf</var>' specifies the pointer to the region into which the result string is written.  The size of the buffer should be equal to or more than 48 bytes.</dd>
</dl>

<p>The function `tcarccipher' is used in order to cipher or decipher a serial object with the Arcfour stream cipher.</p>

<dl class="api">
<dt><code>void tcarccipher(const void *<var>ptr</var>, int <var>size</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, void *<var>obuf</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the cipher key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the cipher key.</dd>
<dd>`<var>obuf</var>' specifies the pointer to the region into which the result data is written.  The size of the buffer should be equal to or more than the input region.</dd>
</dl>

<p>The function `tctime' is used in order to get the time of day in seconds.</p>

<dl class="api">
<dt><code>double tctime(void);</code></dt>
<dd>The return value is the time of day in seconds.  The accuracy is in microseconds.</dd>
</dl>

<p>The function `tccalendar' is used in order to get the Gregorian calendar of a time.</p>

<dl class="api">
<dt><code>void tccalendar(int64_t <var>t</var>, int <var>jl</var>, int *<var>yearp</var>, int *<var>monp</var>, int *<var>dayp</var>, int *<var>hourp</var>, int *<var>minp</var>, int *<var>secp</var>);</code></dt>
<dd>`<var>t</var>' specifies the source time in seconds from the epoch.  If it is `INT64_MAX', the current time is specified.</dd>
<dd>`<var>jl</var>' specifies the jet lag of a location in seconds.  If it is `INT_MAX', the local jet lag is specified.</dd>
<dd>`<var>yearp</var>' specifies the pointer to a variable to which the year is assigned.  If it is `NULL', it is not used.</dd>
<dd>`<var>monp</var>' specifies the pointer to a variable to which the month is assigned.  If it is `NULL', it is not used.  1 means January and 12 means December.</dd>
<dd>`<var>dayp</var>' specifies the pointer to a variable to which the day of the month is assigned.  If it is `NULL', it is not used.</dd>
<dd>`<var>hourp</var>' specifies the pointer to a variable to which the hours is assigned.  If it is `NULL', it is not used.</dd>
<dd>`<var>minp</var>' specifies the pointer to a variable to which the minutes is assigned.  If it is `NULL', it is not used.</dd>
<dd>`<var>secp</var>' specifies the pointer to a variable to which the seconds is assigned.  If it is `NULL', it is not used.</dd>
</dl>

<p>The function `tcdatestrwww' is used in order to format a date as a string in W3CDTF.</p>

<dl class="api">
<dt><code>void tcdatestrwww(int64_t <var>t</var>, int <var>jl</var>, char *<var>buf</var>);</code></dt>
<dd>`<var>t</var>' specifies the source time in seconds from the epoch.  If it is `INT64_MAX', the current time is specified.</dd>
<dd>`<var>jl</var>' specifies the jet lag of a location in seconds.  If it is `INT_MAX', the local jet lag is specified.</dd>
<dd>`<var>buf</var>' specifies the pointer to the region into which the result string is written.  The size of the buffer should be equal to or more than 48 bytes.</dd>
<dd>W3CDTF represents a date as "YYYY-MM-DDThh:mm:ddTZD".</dd>
</dl>

<p>The function `tcdatestrhttp' is used in order to format a date as a string in RFC 1123 format.</p>

<dl class="api">
<dt><code>void tcdatestrhttp(int64_t <var>t</var>, int <var>jl</var>, char *<var>buf</var>);</code></dt>
<dd>`<var>t</var>' specifies the source time in seconds from the epoch.  If it is `INT64_MAX', the current time is specified.</dd>
<dd>`<var>jl</var>' specifies the jet lag of a location in seconds.  If it is `INT_MAX', the local jet lag is specified.</dd>
<dd>`<var>buf</var>' specifies the pointer to the region into which the result string is written.  The size of the buffer should be equal to or more than 48 bytes.</dd>
<dd>RFC 1123 format represents a date as "Wdy, DD-Mon-YYYY hh:mm:dd TZD".</dd>
</dl>

<p>The function `tcstrmktime' is used in order to get the time value of a date string.</p>

<dl class="api">
<dt><code>int64_t tcstrmktime(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the date string in decimal, hexadecimal, W3CDTF, or RFC 822 (1123).  Decimal can be trailed by "s" for in seconds, "m" for in minutes, "h" for in hours, and "d" for in days.</dd>
<dd>The return value is the time value of the date or `INT64_MIN' if the format is invalid.</dd>
</dl>

<p>The function `tcjetlag' is used in order to get the jet lag of the local time.</p>

<dl class="api">
<dt><code>int tcjetlag(void);</code></dt>
<dd>The return value is the jet lag of the local time in seconds.</dd>
</dl>

<p>The function `tcdayofweek' is used in order to get the day of week of a date.</p>

<dl class="api">
<dt><code>int tcdayofweek(int <var>year</var>, int <var>mon</var>, int <var>day</var>);</code></dt>
<dd>`<var>year</var>' specifies the year of a date.</dd>
<dd>`<var>mon</var>' specifies the month of the date.</dd>
<dd>`<var>day</var>' specifies the day of the date.</dd>
<dd>The return value is the day of week of the date.  0 means Sunday and 6 means Saturday.</dd>
</dl>

<h3 id="tcutilapi_fsapi">API of Filesystem Utilities</h3>

<p>The function `tcrealpath' is used in order to get the canonicalized absolute path of a file.</p>

<dl class="api">
<dt><code>char *tcrealpath(const char *<var>path</var>);</code></dt>
<dd>`<var>path</var>' specifies the path of the file.</dd>
<dd>The return value is the canonicalized absolute path of a file, or `NULL' if the path is invalid.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcstatfile' is used in order to get the status information of a file.</p>

<dl class="api">
<dt><code>bool tcstatfile(const char *<var>path</var>, bool *<var>isdirp</var>, int64_t *<var>sizep</var>, int64_t *<var>mtimep</var>);</code></dt>
<dd>`<var>path</var>' specifies the path of the file.</dd>
<dd>`<var>isdirp</var>' specifies the pointer to a variable into which whether the file is a directory is assigned.  If it is `NULL', it is ignored.</dd>
<dd>`<var>sizep</var>' specifies the pointer to a variable into which the size of the file is assigned.  If it is `NULL', it is ignored.</dd>
<dd>`<var>ntimep</var>' specifies the pointer to a variable into which the size of the file is assigned.  If it is `NULL', it is ignored.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcreadfile' is used in order to read whole data of a file.</p>

<dl class="api">
<dt><code>void *tcreadfile(const char *<var>path</var>, int <var>limit</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>path</var>' specifies the path of the file.  If it is `NULL', the standard input is specified.</dd>
<dd>`<var>limit</var>' specifies the limiting size of reading data.  If it is not more than 0, the limitation is not specified.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.  If it is `NULL', it is not used.</dd>
<dd>The return value is the pointer to the allocated region of the read data, or `NULL' if the file could not be opened.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when when is no longer in use.</dd>
</dl>

<p>The function `tcreadfilelines' is used in order to read every line of a file.</p>

<dl class="api">
<dt><code>TCLIST *tcreadfilelines(const char *<var>path</var>);</code></dt>
<dd>`<var>path</var>' specifies the path of the file.  If it is `NULL', the standard input is specified.</dd>
<dd>The return value is a list object of every lines if successful, else it is `NULL'.</dd>
<dd>Line separators are cut out.  Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcwritefile' is used in order to write data into a file.</p>

<dl class="api">
<dt><code>bool tcwritefile(const char *<var>path</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>path</var>' specifies the path of the file.  If it is `NULL', the standard output is specified.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the data region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tccopyfile' is used in order to copy a file.</p>

<dl class="api">
<dt><code>bool tccopyfile(const char *<var>src</var>, const char *<var>dest</var>);</code></dt>
<dd>`<var>src</var>' specifies the path of the source file.</dd>
<dd>`<var>dest</var>' specifies the path of the destination file.</dd>
<dd>The return value is true if successful, else, it is false.</dd>
<dd>If the destination file exists, it is overwritten.</dd>
</dl>

<p>The function `tcreaddir' is used in order to read names of files in a directory.</p>

<dl class="api">
<dt><code>TCLIST *tcreaddir(const char *<var>path</var>);</code></dt>
<dd>`<var>path</var>' specifies the path of the directory.</dd>
<dd>The return value is a list object of names if successful, else it is `NULL'.</dd>
<dd>Links to the directory itself and to the parent directory are ignored.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcglobpat' is used in order to expand a pattern into a list of matched paths.</p>

<dl class="api">
<dt><code>TCLIST *tcglobpat(const char *<var>pattern</var>);</code></dt>
<dd>`<var>pattern</var>' specifies the matching pattern.</dd>
<dd>The return value is a list object of matched paths.  If no path is matched, an empty list is returned.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcremovelink' is used in order to remove a file or a directory and its sub ones recursively.</p>

<dl class="api">
<dt><code>bool tcremovelink(const char *<var>path</var>);</code></dt>
<dd>`<var>path</var>' specifies the path of the link.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned when the link does not exist or the permission is denied.</dd>
</dl>

<p>The function `tcwrite' is used in order to write data into a file.</p>

<dl class="api">
<dt><code>bool tcwrite(int <var>fd</var>, const void *<var>buf</var>, size_t <var>size</var>);</code></dt>
<dd>`<var>fd</var>' specifies the file descriptor.</dd>
<dd>`<var>buf</var>' specifies the buffer to be written.</dd>
<dd>`<var>size</var>' specifies the size of the buffer.</dd>
<dd>The return value is true if successful, else, it is false.</dd>
</dl>

<p>The function `tcread' is used in order to read data from a file.</p>

<dl class="api">
<dt><code>bool tcread(int <var>fd</var>, void *<var>buf</var>, size_t <var>size</var>);</code></dt>
<dd>`<var>fd</var>' specifies the file descriptor.</dd>
<dd>`<var>buf</var>' specifies the buffer to store into.</dd>
<dd>`<var>size</var>' specifies the size of the buffer.</dd>
<dd>The return value is true if successful, else, it is false.</dd>
</dl>

<p>The function `tclock' is used in order to lock a file.</p>

<dl class="api">
<dt><code>bool tclock(int <var>fd</var>, bool <var>ex</var>, bool <var>nb</var>);</code></dt>
<dd>`<var>fd</var>' specifies the file descriptor.</dd>
<dd>`<var>ex</var>' specifies whether an exclusive lock or a shared lock is performed.</dd>
<dd>`<var>nb</var>' specifies whether to request with non-blocking.</dd>
<dd>The return value is true if successful, else, it is false.</dd>
</dl>

<p>The function `tcunlock' is used in order to unlock a file.</p>

<dl class="api">
<dt><code>bool tcunlock(int <var>fd</var>);</code></dt>
<dd>`<var>fd</var>' specifies the file descriptor.</dd>
<dd>The return value is true if successful, else, it is false.</dd>
</dl>

<p>The function `tcsystem' is used in order to execute a shell command.</p>

<dl class="api">
<dt><code>int tcsystem(const char **<var>args</var>, int <var>anum</var>);</code></dt>
<dd>`<var>args</var>' specifies an array of the command name and its arguments.</dd>
<dd>`<var>anum</var>' specifies the number of elements of the array.</dd>
<dd>The return value is the exit code of the command or `INT_MAX' on failure.</dd>
<dd>The command name and the arguments are quoted and meta characters are escaped.</dd>
</dl>

<h3 id="tcutilapi_encapi">API of Encoding Utilities</h3>

<p>The function `tcurlencode' is used in order to encode a serial object with URL encoding.</p>

<dl class="api">
<dt><code>char *tcurlencode(const char *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</dd>
</dl>

<p>The function `tcurldecode' is used in order to decode a string encoded with URL encoding.</p>

<dl class="api">
<dt><code>char *tcurldecode(const char *<var>str</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>str</var>' specifies the encoded string.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the result.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcurlbreak' is used in order to break up a URL into elements.</p>

<dl class="api">
<dt><code>TCMAP *tcurlbreak(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the URL string.</dd>
<dd>The return value is the map object whose keys are the name of elements.  The key "self" indicates the URL itself.  The key "scheme" indicates the scheme.  The key "host" indicates the host of the server.  The key "port" indicates the port number of the server.  The key "authority" indicates the authority information.  The key "path" indicates the path of the resource.  The key "file" indicates the file name without the directory section.  The key "query" indicates the query string.  The key "fragment" indicates the fragment string.</dd>
<dd>Supported schema are HTTP, HTTPS, FTP, and FILE.  Absolute URL and relative URL are supported.  Because the object of the return value is created with the function `tcmapnew', it should be deleted with the function `tcmapdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcurlresolve' is used in order to resolve a relative URL with an absolute URL.</p>

<dl class="api">
<dt><code>char *tcurlresolve(const char *<var>base</var>, const char *<var>target</var>);</code></dt>
<dd>`<var>base</var>' specifies the absolute URL of the base location.</dd>
<dd>`<var>target</var>' specifies the URL to be resolved.</dd>
<dd>The return value is the resolved URL.  If the target URL is relative, a new URL of relative location from the base location is returned.  Else, a copy of the target URL is returned.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbaseencode' is used in order to encode a serial object with Base64 encoding.</p>

<dl class="api">
<dt><code>char *tcbaseencode(const char *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</dd>
</dl>

<p>The function `tcbasedecode' is used in order to decode a string encoded with Base64 encoding.</p>

<dl class="api">
<dt><code>char *tcbasedecode(const char *<var>str</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>str</var>' specifies the encoded string.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the result.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcquoteencode' is used in order to encode a serial object with Quoted-printable encoding.</p>

<dl class="api">
<dt><code>char *tcquoteencode(const char *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</dd>
</dl>

<p>The function `tcquotedecode' is used in order to decode a string encoded with Quoted-printable encoding.</p>

<dl class="api">
<dt><code>char *tcquotedecode(const char *<var>str</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>str</var>' specifies the encoded string.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the result.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmimeencode' is used in order to encode a string with MIME encoding.</p>

<dl class="api">
<dt><code>char *tcmimeencode(const char *<var>str</var>, const char *<var>encname</var>, bool <var>base</var>);</code></dt>
<dd>`<var>str</var>' specifies the string.</dd>
<dd>`<var>encname</var>' specifies the string of the name of the character encoding.</dd>
<dd>`<var>base</var>' specifies whether to use Base64 encoding.  If it is false, Quoted-printable is used.</dd>
<dd>The return value is the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmimedecode' is used in order to decode a string encoded with MIME encoding.</p>

<dl class="api">
<dt><code>char *tcmimedecode(const char *<var>str</var>, char *<var>enp</var>);</code></dt>
<dd>`<var>str</var>' specifies the encoded string.</dd>
<dd>`<var>enp</var>' specifies the pointer to the region into which the name of encoding is written.  If it is `NULL', it is not used.  The size of the buffer should be equal to or more than 32 bytes.</dd>
<dd>The return value is the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmimebreak' is used in order to split a string of MIME into headers and the body.</p>

<dl class="api">
<dt><code>char *tcmimebreak(const char *<var>ptr</var>, int <var>size</var>, TCMAP *<var>headers</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region of MIME data.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>headers</var>' specifies a map object to store headers.  If it is `NULL', it is not used.  Each key of the map is an uncapitalized header name.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the body data.</dd>
<dd>If the content type is defined, the header map has the key "TYPE" specifying the type.  If the character encoding is defined, the key "CHARSET" indicates the encoding name.  If the boundary string of multipart is defined, the key "BOUNDARY" indicates the string.  If the content disposition is defined, the key "DISPOSITION" indicates the direction.  If the file name is defined, the key "FILENAME" indicates the name.  If the attribute name is defined, the key "NAME" indicates the name.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmimeparts' is used in order to split multipart data of MIME into its parts.</p>

<dl class="api">
<dt><code>TCLIST *tcmimeparts(const char *<var>ptr</var>, int <var>size</var>, const char *<var>boundary</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region of multipart data of MIME.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>boundary</var>' specifies the boundary string.</dd>
<dd>The return value is a list object.  Each element of the list is the data of a part.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tchexencode' is used in order to encode a serial object with hexadecimal encoding.</p>

<dl class="api">
<dt><code>char *tchexencode(const char *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</dd>
</dl>

<p>The function `tchexdecode' is used in order to decode a string encoded with hexadecimal encoding.</p>

<dl class="api">
<dt><code>char *tchexdecode(const char *<var>str</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>str</var>' specifies the encoded string.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return</dd>
<dd>value is assigned.</dd>
<dd>The return value is the pointer to the region of the result.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcpackencode' is used in order to compress a serial object with Packbits encoding.</p>

<dl class="api">
<dt><code>char *tcpackencode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcpackdecode' is used in order to decompress a serial object compressed with Packbits encoding.</p>

<dl class="api">
<dt><code>char *tcpackdecode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbsencode' is used in order to compress a serial object with TCBS encoding.</p>

<dl class="api">
<dt><code>char *tcbsencode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbsdecode' is used in order to decompress a serial object compressed with TCBS encoding.</p>

<dl class="api">
<dt><code>char *tcbsdecode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcdeflate' is used in order to compress a serial object with Deflate encoding.</p>

<dl class="api">
<dt><code>char *tcdeflate(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcinflate' is used in order to decompress a serial object compressed with Deflate encoding.</p>

<dl class="api">
<dt><code>char *tcinflate(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcgzipencode' is used in order to compress a serial object with GZIP encoding.</p>

<dl class="api">
<dt><code>char *tcgzipencode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcgzipdecode' is used in order to decompress a serial object compressed with GZIP encoding.</p>

<dl class="api">
<dt><code>char *tcgzipdecode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcgetcrc' is used in order to get the CRC32 checksum of a serial object.</p>

<dl class="api">
<dt><code>unsigned int tcgetcrc(const char *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the CRC32 checksum of the object.</dd>
</dl>

<p>The function `tcbzipencode' is used in order to compress a serial object with BZIP2 encoding.</p>

<dl class="api">
<dt><code>char *tcbzipencode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbzipdecode' is used in order to decompress a serial object compressed with BZIP2 encoding.</p>

<dl class="api">
<dt><code>char *tcbzipdecode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcberencode' is used in order to encode an array of nonnegative integers with BER encoding.</p>

<dl class="api">
<dt><code>char *tcberencode(const unsigned int *<var>ary</var>, int <var>anum</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ary</var>' specifies the pointer to the array of nonnegative integers.</dd>
<dd>`<var>anum</var>' specifies the size of the array.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the result.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</dd>
</dl>

<p>The function `tcberdecode' is used in order to decode a serial object encoded with BER encoding.</p>

<dl class="api">
<dt><code>unsigned int *tcberdecode(const char *<var>ptr</var>, int <var>size</var>, int *<var>np</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>np</var>' specifies the pointer to a variable into which the number of elements of the return value is assigned.</dd>
<dd>The return value is the pointer to the array of the result.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</dd>
</dl>

<p>The function `tcxmlescape' is used in order to escape meta characters in a string with the entity references of XML.</p>

<dl class="api">
<dt><code>char *tcxmlescape(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string.</dd>
<dd>The return value is the pointer to the escaped string.</dd>
<dd>This function escapes only `&amp;', `&lt;', `&gt;', and `&quot;'.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcxmlunescape' is used in order to unescape entity references in a string of XML.</p>

<dl class="api">
<dt><code>char *tcxmlunescape(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string.</dd>
<dd>The return value is the unescaped string.</dd>
<dd>This function restores only `&amp;amp;', `&amp;lt;', `&amp;gt;', and `&amp;quot;'.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<h3 id="tcutilapi_example">Example Code</h3>

<p>The following code is an example using extensible string, array list, and hash map.</p>

<pre>#include &lt;tcutil.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char **argv){

  { /* example to use an extensible string object */
    TCXSTR *xstr;
    /* create the object */
    xstr = tcxstrnew();
    /* concatenate strings */
    tcxstrcat2(xstr, "hop");
    tcxstrcat2(xstr, "step");
    tcxstrcat2(xstr, "jump");
    /* print the size and the content */
    printf("%d:%s\n", tcxstrsize(xstr), (char *)tcxstrptr(xstr));
    /* delete the object */
    tcxstrdel(xstr);
  }

  { /* example to use a list object */
    TCLIST *list;
    int i;
    /* create the object */
    list = tclistnew();
    /* add strings to the tail */
    tclistpush2(list, "hop");
    tclistpush2(list, "step");
    tclistpush2(list, "jump");
    /* print all elements */
    for(i = 0; i &lt; tclistnum(list); i++){
      printf("%d:%s\n", i, tclistval2(list, i));
    }
    /* delete the object */
    tclistdel(list);
  }

  { /* example to use a map object */
    TCMAP *map;
    const char *key;
    /* create the object */
    map = tcmapnew();
    /* add records */
    tcmapput2(map, "foo", "hop");
    tcmapput2(map, "bar", "step");
    tcmapput2(map, "baz", "jump");
    /* print all records */
    tcmapiterinit(map);
    while((key = tcmapiternext2(map)) != NULL){
      printf("%s:%s\n", key, tcmapget2(map, key));
    }
    /* delete the object */
    tcmapdel(map);
  }

  { /* example to use a tree object */
    TCTREE *tree;
    const char *key;
    /* create the object */
    tree = tctreenew();
    /* add records */
    tctreeput2(tree, "foo", "hop");
    tctreeput2(tree, "bar", "step");
    tctreeput2(tree, "baz", "jump");
    /* print all records */
    tctreeiterinit(tree);
    while((key = tctreeiternext2(tree)) != NULL){
      printf("%s:%s\n", key, tctreeget2(tree, key));
    }
    /* delete the object */
    tctreedel(tree);
  }

  return 0;
}
</pre>

<h3 id="tcutilapi_cli">CLI</h3>

<p>To use the utility API easily, the commands `<code>tcutest</code>', `<code>tcumttest</code>', and `<code>tcucodec</code>' are provided.</p>

<p>The command `<code>tcutest</code>' is a utility for facility test and performance test.  This command is used in the following format.  `<var>rnum</var>' specifies the number of iterations.  `<var>anum</var>' specifies the initial number of elements of array.  `<var>bnum</var>' specifies the number of buckets.</p>

<dl class="api">
<dt><code>tcutest xstr <var>rnum</var></code></dt>
<dd>Perform test of extensible string.</dd>
<dt><code>tcutest list [-rd] <var>rnum</var> [<var>anum</var>]</code></dt>
<dd>Perform test of array list.</dd>
<dt><code>tcutest map [-rd] [-tr] [-rnd] [-dk|-dc|-dai|-dad|-dpr] <var>rnum</var> [<var>bnum</var>]</code></dt>
<dd>Perform test of hash map.</dd>
<dt><code>tcutest tree [-rd] [-tr] [-rnd] [-dk|-dc|-dai|-dad|-dpr] <var>rnum</var></code></dt>
<dd>Perform test of ordered tree.</dd>
<dt><code>tcutest mdb [-rd] [-tr] [-rnd] [-dk|-dc|-dai|-dad|-dpr] <var>rnum</var> [<var>bnum</var>]</code></dt>
<dd>Perform test of on-memory hash database.</dd>
<dt><code>tcutest ndb [-rd] [-tr] [-rnd] [-dk|-dc|-dai|-dad|-dpr] <var>rnum</var></code></dt>
<dd>Perform test of on-memory tree database.</dd>
<dt><code>tcutest misc <var>rnum</var></code></dt>
<dd>Perform test of miscellaneous routines.</dd>
<dt><code>tcutest wicked <var>rnum</var></code></dt>
<dd>Perform updating operations of list and map selected at random.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-rd</code> : perform the reading test also.</li>
<li><code>-tr</code> : perform the iterator test also.</li>
<li><code>-rnd</code> : select keys at random.</li>
<li><code>-dk</code> : use the function `tcxxxputkeep' instead of `tcxxxput'.</li>
<li><code>-dc</code> : use the function `tcxxxputcat' instead of `tcxxxput'.</li>
<li><code>-dai</code> : use the function `tcxxxaddint' instead of `tcxxxput'.</li>
<li><code>-dad</code> : use the function `tcxxxadddouble' instead of `tcxxxput'.</li>
<li><code>-dpr</code> : use the function `tcxxxputproc' instead of `tcxxxput'.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<p>The command `<code>tcumttest</code>' is a utility for facility test under multi-thread situation.  This command is used in the following format.  `<var>tnum</var>' specifies the number of running threads.  `<var>rnum</var>' specifies the number of iterations.  `<var>bnum</var>' specifies the number of buckets.</p>

<dl class="api">
<dt><code>tcumttest combo [-rnd] <var>tnum</var> <var>rnum</var> [<var>bnum</var>]</code></dt>
<dd>Peform storing, retrieving, and removing in turn.</dd>
<dt><code>tcumttest typical [-nc] [-rr <var>num</var>] <var>tnum</var> <var>rnum</var> [<var>bnum</var>]</code></dt>
<dd>Perform typical operations selected at random.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-rnd</code> : select keys at random.</li>
<li><code>-nc</code> : omit the comparison test.</li>
<li><code>-rr <var>num</var></code> : specify the ratio of reading operation by percentage.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<p>The command `<code>tcucodec</code>' is a tool to use encoding and decoding features.  This command is used in the following format.  `<var>file</var>' specifies a input file.  If it is omitted, the standard input is read.</p>

<dl class="api">
<dt><code>tcucodec url [-d] [-br] [-rs <var>base</var>] [<var>file</var>]</code></dt>
<dd>Perform URL encoding and its decoding.</dd>
<dt><code>tcucodec base [-d] [<var>file</var>]</code></dt>
<dd>Perform Base64 encoding and its decoding.</dd>
<dt><code>tcucodec quote [-d] [<var>file</var>]</code></dt>
<dd>Perform quoted-printable encoding and its decoding.</dd>
<dt><code>tcucodec mime [-d] [-en <var>name</var>] [-q] [-on] [-hd] [-bd] [-part <var>num</var>] [<var>file</var>]</code></dt>
<dd>Perform MIME encoding and its decoding.</dd>
<dt><code>tcucodec hex [-d] [<var>file</var>]</code></dt>
<dd>Perform hexadecimal encoding and its decoding.</dd>
<dt><code>tcucodec pack [-d] [-bwt] [<var>file</var>]</code></dt>
<dd>Perform Packbits encoding and its decoding.</dd>
<dt><code>tcucodec tcbs [-d] [<var>file</var>]</code></dt>
<dd>Perform TCBS encoding and its decoding.</dd>
<dt><code>tcucodec zlib [-d] [-gz] [<var>file</var>]</code></dt>
<dd>Perform ZLIB encoding and its decoding.</dd>
<dt><code>tcucodec bzip [-d] [<var>file</var>]</code></dt>
<dd>Perform BZIP2 encoding and its decoding.</dd>
<dt><code>tcucodec xml [-d] [-br] [<var>file</var>]</code></dt>
<dd>Process XML.  By default, escape meta characters.</dd>
<dt><code>tcucodec cstr [-d] [-js] [<var>file</var>]</code></dt>
<dd>Perform C-string escaping and its unescaping.</dd>
<dt><code>tcucodec ucs [-d] [-un] [-kw <var>str</var>] [<var>file</var>]</code></dt>
<dd>Convert UTF-8 string into UCS-2 array.</dd>
<dt><code>tcucodec hash [-crc] [-ch <var>num</var>] [<var>file</var>]</code></dt>
<dd>Calculate the hash value.  By default, use MD5 function.</dd>
<dt><code>tcucodec cipher [-key <var>str</var>] [<var>file</var>]</code></dt>
<dd>Perform stream cipher and its decipher.</dd>
<dt><code>tcucodec date [-ds <var>str</var>] [-jl <var>num</var>] [-wf] [-rf]</code></dt>
<dd>Process date string.  By default, print the current UNIX time.</dd>
<dt><code>tcucodec tmpl [-var <var>name</var> <var>value</var>] [<var>file</var>]</code></dt>
<dd>Perform template serialization.</dd>
<dt><code>tcucodec conf [-v|-i|-l|-p]</code></dt>
<dd>Print some configurations.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-d</code> : perform decoding (unescaping), not encoding (escaping).</li>
<li><code>-br</code> : break up URL or XML into elements.</li>
<li><code>-rs <var>base</var></code> : specify the base URL and resolve the relative URL.</li>
<li><code>-en <var>name</var></code> : specify the input encoding, which is UTF-8 by default.</li>
<li><code>-q</code> : use quoted-printable encoding, which is Base64 by default.</li>
<li><code>-on</code> : output the charset name when decoding.</li>
<li><code>-bd</code> : perform MIME parsing and output the body.</li>
<li><code>-hd</code> : perform MIME parsing and output the headers.</li>
<li><code>-part <var>num</var></code> : perform MIME parsing and output the specified part.</li>
<li><code>-bwt</code> : convert by BWT as preprocessing.</li>
<li><code>-gz</code> : use GZIP format.</li>
<li><code>-crc</code> : use CRC32 function.</li>
<li><code>-js</code> : use JSON compatible format.</li>
<li><code>-un</code> : perform UCS normalization.</li>
<li><code>-kw <var>str</var></code> : generate KWIC string.</li>
<li><code>-ch <var>num</var></code> : use consistent hashing function.</li>
<li><code>-key <var>str</var></code> : specify the cipher key.</li>
<li><code>-ds <var>str</var></code> : specify the time.</li>
<li><code>-jl <var>num</var></code> : specify the jet lag.</li>
<li><code>-wf</code> : format the output in W3CDTF.</li>
<li><code>-rf</code> : format the output in RFC 1123 format.</li>
<li><code>-var <var>name</var> <var>value</var></code> : specify a template variable.</li>
<li><code>-v</code> : show the version number of Tokyo Cabinet.</li>
<li><code>-i</code> : show options to include the headers of Tokyo Cabinet.</li>
<li><code>-l</code> : show options to link the library of Tokyo Cabinet.</li>
<li><code>-p</code> : show the directory path of the commands of Tokyo Cabinet.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<hr />

<h2 id="tchdbapi">The Hash Database API</h2>

<p>Hash database is a file containing a hash table and is handled with the hash database API.  See `<code>tchdb.h</code>' for the entire specification.</p>

<h3 id="tchdbapi_description">Description</h3>

<p>To use the hash database API, include `<code>tcutil.h</code>', `<code>tchdb.h</code>', and related standard header files.  Usually, write the following description near the front of a source file.</p>

<dl>
<dt><code>#include &lt;tcutil.h&gt;</code></dt>
<dt><code>#include &lt;tchdb.h&gt;</code></dt>
<dt><code>#include &lt;stdlib.h&gt;</code></dt>
<dt><code>#include &lt;stdbool.h&gt;</code></dt>
<dt><code>#include &lt;stdint.h&gt;</code></dt>
</dl>

<p>Objects whose type is pointer to `<code>TCHDB</code>' are used to handle hash databases.  A hash database object is created with the function `<code>tchdbnew</code>' and is deleted with the function `<code>tchdbdel</code>'.  To avoid memory leak, it is important to delete every object when it is no longer in use.</p>

<p>Before operations to store or retrieve records, it is necessary to open a database file and connect the hash database object to it.  The function `<code>tchdbopen</code>' is used to open a database file and the function `<code>tchdbclose</code>' is used to close the database file.  To avoid data missing or corruption, it is important to close every database file when it is no longer in use.  It is forbidden for multible database objects in a process to open the same database at the same time.</p>

<h3 id="tchdbapi_api">API</h3>

<p>The function `tchdberrmsg' is used in order to get the message string corresponding to an error code.</p>

<dl class="api">
<dt><code>const char *tchdberrmsg(int <var>ecode</var>);</code></dt>
<dd>`<var>ecode</var>' specifies the error code.</dd>
<dd>The return value is the message string of the error code.</dd>
</dl>

<p>The function `tchdbnew' is used in order to create a hash database object.</p>

<dl class="api">
<dt><code>TCHDB *tchdbnew(void);</code></dt>
<dd>The return value is the new hash database object.</dd>
</dl>

<p>The function `tchdbdel' is used in order to delete a hash database object.</p>

<dl class="api">
<dt><code>void tchdbdel(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>If the database is not closed, it is closed implicitly.  Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tchdbecode' is used in order to get the last happened error code of a hash database object.</p>

<dl class="api">
<dt><code>int tchdbecode(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>The return value is the last happened error code.</dd>
<dd>The following error codes are defined: `TCESUCCESS' for success, `TCETHREAD' for threading error, `TCEINVALID' for invalid operation, `TCENOFILE' for file not found, `TCENOPERM' for no permission, `TCEMETA' for invalid meta data, `TCERHEAD' for invalid record header, `TCEOPEN' for open error, `TCECLOSE' for close error, `TCETRUNC' for trunc error, `TCESYNC' for sync error, `TCESTAT' for stat error, `TCESEEK' for seek error, `TCEREAD' for read error, `TCEWRITE' for write error, `TCEMMAP' for mmap error, `TCELOCK' for lock error, `TCEUNLINK' for unlink error, `TCERENAME' for rename error, `TCEMKDIR' for mkdir error, `TCERMDIR' for rmdir error, `TCEKEEP' for existing record, `TCENOREC' for no record found, and `TCEMISC' for miscellaneous error.</dd>
</dl>

<p>The function `tchdbsetmutex' is used in order to set mutual exclusion control of a hash database object for threading.</p>

<dl class="api">
<dt><code>bool tchdbsetmutex(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object which is not opened.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the mutual exclusion control of the database should be set before the database is opened.</dd>
</dl>

<p>The function `tchdbtune' is used in order to set the tuning parameters of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbtune(TCHDB *<var>hdb</var>, int64_t <var>bnum</var>, int8_t <var>apow</var>, int8_t <var>fpow</var>, uint8_t <var>opts</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object which is not opened.</dd>
<dd>`<var>bnum</var>' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is 131071.  Suggested size of the bucket array is about from 0.5 to 4 times of the number of all records to be stored.</dd>
<dd>`<var>apow</var>' specifies the size of record alignment by power of 2.  If it is negative, the default value is specified.  The default value is 4 standing for 2^4=16.</dd>
<dd>`<var>fpow</var>' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the default value is specified.  The default value is 10 standing for 2^10=1024.</dd>
<dd>`<var>opts</var>' specifies options by bitwise-or: `HDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64-bit bucket array, `HDBTDEFLATE' specifies that each record is compressed with Deflate encoding, `HDBTBZIP' specifies that each record is compressed with BZIP2 encoding, `HDBTTCBS' specifies that each record is compressed with TCBS encoding.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the tuning parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tchdbsetcache' is used in order to set the caching parameters of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbsetcache(TCHDB *<var>hdb</var>, int32_t <var>rcnum</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object which is not opened.</dd>
<dd>`<var>rcnum</var>' specifies the maximum number of records to be cached.  If it is not more than 0, the record cache is disabled.  It is disabled by default.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the caching parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tchdbsetxmsiz' is used in order to set the size of the extra mapped memory of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbsetxmsiz(TCHDB *<var>hdb</var>, int64_t <var>xmsiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object which is not opened.</dd>
<dd>`<var>xmsiz</var>' specifies the size of the extra mapped memory.  If it is not more than 0, the extra mapped memory is disabled.  The default size is 67108864.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the mapping parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tchdbsetdfunit' is used in order to set the unit step number of auto defragmentation of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbsetdfunit(TCHDB *<var>hdb</var>, int32_t <var>dfunit</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object which is not opened.</dd>
<dd>`<var>dfunit</var>' specifie the unit step number.  If it is not more than 0, the auto defragmentation is disabled.  It is disabled by default.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the defragmentation parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tchdbopen' is used in order to open a database file and connect a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbopen(TCHDB *<var>hdb</var>, const char *<var>path</var>, int <var>omode</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object which is not opened.</dd>
<dd>`<var>path</var>' specifies the path of the database file.</dd>
<dd>`<var>omode</var>' specifies the connection mode: `HDBOWRITER' as a writer, `HDBOREADER' as a reader.  If the mode is `HDBOWRITER', the following may be added by bitwise-or: `HDBOCREAT', which means it creates a new database if not exist, `HDBOTRUNC', which means it creates a new database regardless if one exists, `HDBOTSYNC', which means every transaction synchronizes updated contents with the device.  Both of `HDBOREADER' and `HDBOWRITER' can be added to by bitwise-or: `HDBONOLCK', which means it opens the database file without file locking, or `HDBOLCKNB', which means locking is performed without blocking.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tchdbclose' is used in order to close a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbclose(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update of a database is assured to be written when the database is closed.  If a writer opens a database but does not close it appropriately, the database will be broken.</dd>
</dl>

<p>The function `tchdbput' is used in order to store a record into a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbput(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tchdbput2' is used in order to store a string record into a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbput2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tchdbputkeep' is used in order to store a new record into a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbputkeep(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tchdbputkeep2' is used in order to store a new string record into a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbputkeep2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tchdbputcat' is used in order to concatenate a value at the end of the existing record in a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbputcat(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tchdbputcat2' is used in order to concatenate a string value at the end of the existing record in a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbputcat2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tchdbputasync' is used in order to store a record into a hash database object in asynchronous fashion.</p>

<dl class="api">
<dt><code>bool tchdbputasync(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.  Records passed to this function are accumulated into the inner buffer and wrote into the file at a blast.</dd>
</dl>

<p>The function `tchdbputasync2' is used in order to store a string record into a hash database object in asynchronous fashion.</p>

<dl class="api">
<dt><code>bool tchdbputasync2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.  Records passed to this function are accumulated into the inner buffer and wrote into the file at a blast.</dd>
</dl>

<p>The function `tchdbout' is used in order to remove a record of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbout(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tchdbout2' is used in order to remove a string record of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbout2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tchdbget' is used in order to retrieve a record in a hash database object.</p>

<dl class="api">
<dt><code>void *tchdbget(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tchdbget2' is used in order to retrieve a string record in a hash database object.</p>

<dl class="api">
<dt><code>char *tchdbget2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tchdbget3' is used in order to retrieve a record in a hash database object and write the value into a buffer.</p>

<dl class="api">
<dt><code>int tchdbget3(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, void *<var>vbuf</var>, int <var>max</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the buffer into which the value of the corresponding record is written.</dd>
<dd>`<var>max</var>' specifies the size of the buffer.</dd>
<dd>If successful, the return value is the size of the written data, else, it is -1.  -1 is returned if no record corresponds to the specified key.</dd>
<dd>Note that an additional zero code is not appended at the end of the region of the writing buffer.</dd>
</dl>

<p>The function `tchdbvsiz' is used in order to get the size of the value of a record in a hash database object.</p>

<dl class="api">
<dt><code>int tchdbvsiz(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tchdbvsiz2' is used in order to get the size of the value of a string record in a hash database object.</p>

<dl class="api">
<dt><code>int tchdbvsiz2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tchdbiterinit' is used in order to initialize the iterator of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbiterinit(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The iterator is used in order to access the key of every record stored in a database.</dd>
</dl>

<p>The function `tchdbiternext' is used in order to get the next key of the iterator of a hash database object.</p>

<dl class="api">
<dt><code>void *tchdbiternext(TCHDB *<var>hdb</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  It is allowed to update or remove records whose keys are fetched while the iteration.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.</dd>
</dl>

<p>The function `tchdbiternext2' is used in order to get the next key string of the iterator of a hash database object.</p>

<dl class="api">
<dt><code>char *tchdbiternext2(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>If successful, the return value is the string of the next key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.</dd>
</dl>

<p>The function `tchdbiternext3' is used in order to get the next extensible objects of the iterator of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbiternext3(TCHDB *<var>hdb</var>, TCXSTR *<var>kxstr</var>, TCXSTR *<var>vxstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>kxstr</var>' specifies the object into which the next key is wrote down.</dd>
<dd>`<var>vxstr</var>' specifies the object into which the next value is wrote down.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned when no record is to be get out of the iterator.</dd>
</dl>

<p>The function `tchdbfwmkeys' is used in order to get forward matching keys in a hash database object.</p>

<dl class="api">
<dt><code>TCLIST *tchdbfwmkeys(TCHDB *<var>hdb</var>, const void *<var>pbuf</var>, int <var>psiz</var>, int <var>max</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>pbuf</var>' specifies the pointer to the region of the prefix.</dd>
<dd>`<var>psiz</var>' specifies the size of the region of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</dd>
</dl>

<p>The function `tchdbfwmkeys2' is used in order to get forward matching string keys in a hash database object.</p>

<dl class="api">
<dt><code>TCLIST *tchdbfwmkeys2(TCHDB *<var>hdb</var>, const char *<var>pstr</var>, int <var>max</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>pstr</var>' specifies the string of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</dd>
</dl>

<p>The function `tchdbaddint' is used in order to add an integer to a record in a hash database object.</p>

<dl class="api">
<dt><code>int tchdbaddint(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int <var>num</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>If successful, the return value is the summation value, else, it is `INT_MIN'.</dd>
<dd>If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tchdbdbadddouble' is used in order to add a real number to a record in a hash database object.</p>

<dl class="api">
<dt><code>double tchdbadddouble(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, double <var>num</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>If successful, the return value is the summation value, else, it is Not-a-Number.</dd>
<dd>If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tchdbsync' is used in order to synchronize updated contents of a hash database object with the file and the device.</p>

<dl class="api">
<dt><code>bool tchdbsync(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function is useful when another process connects to the same database file.</dd>
</dl>

<p>The function `tchdboptimize' is used in order to optimize the file of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdboptimize(TCHDB *<var>hdb</var>, int64_t <var>bnum</var>, int8_t <var>apow</var>, int8_t <var>fpow</var>, uint8_t <var>opts</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>bnum</var>' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is two times of the number of records.</dd>
<dd>`<var>apow</var>' specifies the size of record alignment by power of 2.  If it is negative, the current setting is not changed.</dd>
<dd>`<var>fpow</var>' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the current setting is not changed.</dd>
<dd>`<var>opts</var>' specifies options by bitwise-or: `HDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64-bit bucket array, `HDBTDEFLATE' specifies that each record is compressed with Deflate encoding, `HDBTBZIP' specifies that each record is compressed with BZIP2 encoding, `HDBTTCBS' specifies that each record is compressed with TCBS encoding.  If it is `UINT8_MAX', the current setting is not changed.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function is useful to reduce the size of the database file with data fragmentation by successive updating.</dd>
</dl>

<p>The function `tchdbvanish' is used in order to remove all records of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbvanish(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tchdbcopy' is used in order to copy the database file of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbcopy(TCHDB *<var>hdb</var>, const char *<var>path</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>path</var>' specifies the path of the destination file.  If it begins with `@', the trailing substring is executed as a command line.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if the executed command returns non-zero code.</dd>
<dd>The database file is assured to be kept synchronized and not modified while the copying or executing operation is in progress.  So, this function is useful to create a backup file of the database file.</dd>
</dl>

<p>The function `tchdbtranbegin' is used in order to begin the transaction of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbtranbegin(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The database is locked by the thread while the transaction so that only one transaction can be activated with a database object at the same time.  Thus, the serializable isolation level is assumed if every database operation is performed in the transaction.  All updated regions are kept track of by write ahead logging while the transaction.  If the database is closed during transaction, the transaction is aborted implicitly.</dd>
</dl>

<p>The function `tchdbtrancommit' is used in order to commit the transaction of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbtrancommit(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update in the transaction is fixed when it is committed successfully.</dd>
</dl>

<p>The function `tchdbtranabort' is used in order to abort the transaction of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbtranabort(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update in the transaction is discarded when it is aborted.  The state of the database is rollbacked to before transaction.</dd>
</dl>

<p>The function `tchdbpath' is used in order to get the file path of a hash database object.</p>

<dl class="api">
<dt><code>const char *tchdbpath(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>The return value is the path of the database file or `NULL' if the object does not connect to any database file.</dd>
</dl>

<p>The function `tchdbrnum' is used in order to get the number of records of a hash database object.</p>

<dl class="api">
<dt><code>uint64_t tchdbrnum(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>The return value is the number of records or 0 if the object does not connect to any database file.</dd>
</dl>

<p>The function `tchdbfsiz' is used in order to get the size of the database file of a hash database object.</p>

<dl class="api">
<dt><code>uint64_t tchdbfsiz(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>The return value is the size of the database file or 0 if the object does not connect to any database file.</dd>
</dl>

<h3 id="tchdbapi_example">Example Code</h3>

<p>The following code is an example to use a hash database.</p>

<pre>#include &lt;tcutil.h&gt;
#include &lt;tchdb.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;

int main(int argc, char **argv){
  TCHDB *hdb;
  int ecode;
  char *key, *value;

  /* create the object */
  hdb = tchdbnew();

  /* open the database */
  if(!tchdbopen(hdb, "casket.tch", HDBOWRITER | HDBOCREAT)){
    ecode = tchdbecode(hdb);
    fprintf(stderr, "open error: %s\n", tchdberrmsg(ecode));
  }

  /* store records */
  if(!tchdbput2(hdb, "foo", "hop") ||
     !tchdbput2(hdb, "bar", "step") ||
     !tchdbput2(hdb, "baz", "jump")){
    ecode = tchdbecode(hdb);
    fprintf(stderr, "put error: %s\n", tchdberrmsg(ecode));
  }

  /* retrieve records */
  value = tchdbget2(hdb, "foo");
  if(value){
    printf("%s\n", value);
    free(value);
  } else {
    ecode = tchdbecode(hdb);
    fprintf(stderr, "get error: %s\n", tchdberrmsg(ecode));
  }

  /* traverse records */
  tchdbiterinit(hdb);
  while((key = tchdbiternext2(hdb)) != NULL){
    value = tchdbget2(hdb, key);
    if(value){
      printf("%s:%s\n", key, value);
      free(value);
    }
    free(key);
  }

  /* close the database */
  if(!tchdbclose(hdb)){
    ecode = tchdbecode(hdb);
    fprintf(stderr, "close error: %s\n", tchdberrmsg(ecode));
  }

  /* delete the object */
  tchdbdel(hdb);

  return 0;
}
</pre>

<h3 id="tchdbapi_cli">CLI</h3>

<p>To use the hash database API easily, the commands `<code>tchtest</code>', `<code>tchmttest</code>', and `<code>tchmgr</code>' are provided.</p>

<p>The command `<code>tchtest</code>' is a utility for facility test and performance test.  This command is used in the following format.  `<var>path</var>' specifies the path of a database file.  `<var>rnum</var>' specifies the number of iterations.  `<var>bnum</var>' specifies the number of buckets.  `<var>apow</var>' specifies the power of the alignment.  `<var>fpow</var>' specifies the power of the free block pool.</p>

<dl class="api">
<dt><code>tchtest write [-mt] [-tl] [-td|-tb|-tt|-tx] [-rc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-as] [-rnd] <var>path</var> <var>rnum</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>Store records with keys of 8 bytes.  They change as `00000001', `00000002'...</dd>
<dt><code>tchtest read [-mt] [-rc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-wb] [-rnd] <var>path</var></code></dt>
<dd>Retrieve all records of the database above.</dd>
<dt><code>tchtest remove [-mt] [-rc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-rnd] <var>path</var></code></dt>
<dd>Remove all records of the database above.</dd>
<dt><code>tchtest rcat [-mt] [-tl] [-td|-tb|-tt|-tx] [-rc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-pn <var>num</var>] [-dai|-dad|-rl|-ru] <var>path</var> <var>rnum</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>Store records with partway duplicated keys using concatenate mode.</dd>
<dt><code>tchtest misc [-mt] [-tl] [-td|-tb|-tt|-tx] [-nl|-nb] <var>path</var> <var>rnum</var></code></dt>
<dd>Perform miscellaneous test of various operations.</dd>
<dt><code>tchtest wicked [-mt] [-tl] [-td|-tb|-tt|-tx] [-nl|-nb] <var>path</var> <var>rnum</var></code></dt>
<dd>Perform updating operations selected at random.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-mt</code> : call the function `tchdbsetmutex'.</li>
<li><code>-tl</code> : enable the option `HDBTLARGE'.</li>
<li><code>-td</code> : enable the option `HDBTDEFLATE'.</li>
<li><code>-tb</code> : enable the option `HDBTBZIP'.</li>
<li><code>-tt</code> : enable the option `HDBTTCBS'.</li>
<li><code>-tx</code> : enable the option `HDBTEXCODEC'.</li>
<li><code>-rc <var>num</var></code> : specify the number of cached records.</li>
<li><code>-xm <var>num</var></code> : specify the size of the extra mapped memory.</li>
<li><code>-df <var>num</var></code> : specify the unit step number of auto defragmentation.</li>
<li><code>-nl</code> : enable the option `HDBNOLCK'.</li>
<li><code>-nb</code> : enable the option `HDBLCKNB'.</li>
<li><code>-as</code> : use the function `tchdbputasync' instead of `tchdbput'.</li>
<li><code>-rnd</code> : select keys at random.</li>
<li><code>-wb</code> : use the function `tchdbget3' instead of `tchdbget'.</li>
<li><code>-pn <var>num</var></code> : specify the number of patterns.</li>
<li><code>-dai</code> : use the function `tchdbaddint' instead of `tchdbputcat'.</li>
<li><code>-dad</code> : use the function `tchdbadddouble' instead of `tchdbputcat'.</li>
<li><code>-rl</code> : set the length of values at random.</li>
<li><code>-ru</code> : select update operations at random.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<p>The command `<code>tchmttest</code>' is a utility for facility test under multi-thread situation.  This command is used in the following format.  `<var>path</var>' specifies the path of a database file.  `<var>tnum</var>' specifies the number of running threads.  `<var>rnum</var>' specifies the number of iterations.  `<var>bnum</var>' specifies the number of buckets.  `<var>apow</var>' specifies the power of the alignment.  `<var>fpow</var>' specifies the power of the free block pool.</p>

<dl class="api">
<dt><code>tchmttest write [-tl] [-td|-tb|-tt|-tx] [-rc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-as] [-rnd] <var>path</var> <var>tnum</var> <var>rnum</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>Store records with keys of 8 bytes.  They change as `00000001', `00000002'...</dd>
<dt><code>tchmttest read [-rc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-wb] [-rnd] <var>path</var> <var>tnum</var></code></dt>
<dd>Retrieve all records of the database above.</dd>
<dt><code>tchmttest remove [-rc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-rnd] <var>path</var> <var>tnum</var></code></dt>
<dd>Remove all records of the database above.</dd>
<dt><code>tchmttest wicked [-tl] [-td|-tb|-tt|-tx] [-nl|-nb] [-nc] <var>path</var> <var>tnum</var> <var>rnum</var></code></dt>
<dd>Perform updating operations selected at random.</dd>
<dt><code>tchmttest typical [-tl] [-td|-tb|-tt|-tx] [-rc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-nc] [-rr <var>num</var>] <var>path</var> <var>tnum</var> <var>rnum</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]</code></dt>
<dd>Perform typical operations selected at random.</dd>
<dt><code>tchmttest race [-tl] [-td|-tb|-tt|-tx] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] <var>path</var> <var>tnum</var> <var>rnum</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]</code></dt>
<dd>Perform race condition test.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-tl</code> : enable the option `HDBTLARGE'.</li>
<li><code>-td</code> : enable the option `HDBTDEFLATE'.</li>
<li><code>-tb</code> : enable the option `HDBTBZIP'.</li>
<li><code>-tt</code> : enable the option `HDBTTCBS'.</li>
<li><code>-tx</code> : enable the option `HDBTEXCODEC'.</li>
<li><code>-rc <var>num</var></code> : specify the number of cached records.</li>
<li><code>-xm <var>num</var></code> : specify the size of the extra mapped memory.</li>
<li><code>-df <var>num</var></code> : specify the unit step number of auto defragmentation.</li>
<li><code>-nl</code> : enable the option `HDBNOLCK'.</li>
<li><code>-nb</code> : enable the option `HDBLCKNB'.</li>
<li><code>-as</code> : use the function `tchdbputasync' instead of `tchdbput'.</li>
<li><code>-rnd</code> : select keys at random.</li>
<li><code>-wb</code> : use the function `tchdbget3' instead of `tchdbget'.</li>
<li><code>-nc</code> : omit the comparison test.</li>
<li><code>-rr <var>num</var></code> : specify the ratio of reading operation by percentage.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<p>The command `<code>tchmgr</code>' is a utility for test and debugging of the hash database API and its applications.  `<var>path</var>' specifies the path of a database file.  `<var>bnum</var>' specifies the number of buckets.  `<var>apow</var>' specifies the power of the alignment.  `<var>fpow</var>' specifies the power of the free block pool.  `<var>key</var>' specifies the key of a record.  `<var>value</var>' specifies the value of a record.  `<var>file</var>' specifies the input file.</p>

<dl class="api">
<dt><code>tchmgr create [-tl] [-td|-tb|-tt|-tx] <var>path</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>Create a database file.</dd>
<dt><code>tchmgr inform [-nl|-nb] <var>path</var></code></dt>
<dd>Print miscellaneous information to the standard output.</dd>
<dt><code>tchmgr put [-nl|-nb] [-sx] [-dk|-dc|-dai|-dad] <var>path</var> <var>key</var> <var>value</var></code></dt>
<dd>Store a record.</dd>
<dt><code>tchmgr out [-nl|-nb] [-sx] <var>path</var> <var>key</var></code></dt>
<dd>Remove a record.</dd>
<dt><code>tchmgr get [-nl|-nb] [-sx] [-px] [-pz] <var>path</var> <var>key</var></code></dt>
<dd>Print the value of a record.</dd>
<dt><code>tchmgr list [-nl|-nb] [-m <var>num</var>] [-pv] [-px] [-fm <var>str</var>] <var>path</var></code></dt>
<dd>Print keys of all records, separated by line feeds.</dd>
<dt><code>tchmgr optimize [-tl] [-td|-tb|-tt|-tx] [-tz] [-nl|-nb] [-df] <var>path</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>Optimize a database file.</dd>
<dt><code>tchmgr importtsv [-nl|-nb] [-sc] <var>path</var> [<var>file</var>]</code></dt>
<dd>Store records of TSV in each line of a file.</dd>
<dt><code>tchmgr version</code></dt>
<dd>Print the version information of Tokyo Cabinet.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-tl</code> : enable the option `HDBTLARGE'.</li>
<li><code>-td</code> : enable the option `HDBTDEFLATE'.</li>
<li><code>-tb</code> : enable the option `HDBTBZIP'.</li>
<li><code>-tt</code> : enable the option `HDBTTCBS'.</li>
<li><code>-tx</code> : enable the option `HDBTEXCODEC'.</li>
<li><code>-nl</code> : enable the option `HDBNOLCK'.</li>
<li><code>-nb</code> : enable the option `HDBLCKNB'.</li>
<li><code>-sx</code> : the input data is evaluated as a hexadecimal data string.</li>
<li><code>-dk</code> : use the function `tchdbputkeep' instead of `tchdbput'.</li>
<li><code>-dc</code> : use the function `tchdbputcat' instead of `tchdbput'.</li>
<li><code>-dai</code> : use the function `tchdbaddint' instead of `tchdbput'.</li>
<li><code>-dad</code> : use the function `tchdbadddouble' instead of `tchdbput'.</li>
<li><code>-px</code> : the output data is converted into a hexadecimal data string.</li>
<li><code>-pz</code> : do not append line feed at the end of the output.</li>
<li><code>-m <var>num</var></code> : specify the maximum number of the output.</li>
<li><code>-pv</code> : print values of records also.</li>
<li><code>-fm <var>str</var></code> : specify the prefix of keys.</li>
<li><code>-tz</code> : enable the option `UINT8_MAX'.</li>
<li><code>-df</code> : perform defragmentation only.</li>
<li><code>-sc</code> : normalize keys as lower cases.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<hr />

<h2 id="tcbdbapi">The B+ Tree Database API</h2>

<p>B+ tree database is a file containing a B+ tree and is handled with the B+ tree database API.  See `<code>tcbdb.h</code>' for the entire specification.</p>

<h3 id="tcbdbapi_description">Description</h3>

<p>To use the B+ tree database API, include `<code>tcutil.h</code>', `<code>tcbdb.h</code>', and related standard header files.  Usually, write the following description near the front of a source file.</p>

<dl>
<dt><code>#include &lt;tcutil.h&gt;</code></dt>
<dt><code>#include &lt;tcbdb.h&gt;</code></dt>
<dt><code>#include &lt;stdlib.h&gt;</code></dt>
<dt><code>#include &lt;stdbool.h&gt;</code></dt>
<dt><code>#include &lt;stdint.h&gt;</code></dt>
</dl>

<p>Objects whose type is pointer to `<code>TCBDB</code>' are used to handle B+ tree databases.  A B+ tree database object is created with the function `<code>tcbdbnew</code>' and is deleted with the function `<code>tcbdbdel</code>'.  To avoid memory leak, it is important to delete every object when it is no longer in use.</p>

<p>Before operations to store or retrieve records, it is necessary to open a database file and connect the B+ tree database object to it.  The function `<code>tcbdbopen</code>' is used to open a database file and the function `<code>tcbdbclose</code>' is used to close the database file.  To avoid data missing or corruption, it is important to close every database file when it is no longer in use.  It is forbidden for multible database objects in a process to open the same database at the same time.</p>

<h3 id="tcbdbapi_api">API</h3>

<p>The function `tcbdberrmsg' is used in order to get the message string corresponding to an error code.</p>

<dl class="api">
<dt><code>const char *tcbdberrmsg(int <var>ecode</var>);</code></dt>
<dd>`<var>ecode</var>' specifies the error code.</dd>
<dd>The return value is the message string of the error code.</dd>
</dl>

<p>The function `tcbdbnew' is used in order to create a B+ tree database object.</p>

<dl class="api">
<dt><code>TCBDB *tcbdbnew(void);</code></dt>
<dd>The return value is the new B+ tree database object.</dd>
</dl>

<p>The function `tcbdbdel' is used in order to delete a B+ tree database object.</p>

<dl class="api">
<dt><code>void tcbdbdel(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>If the database is not closed, it is closed implicitly.  Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tcbdbecode' is used in order to get the last happened error code of a B+ tree database object.</p>

<dl class="api">
<dt><code>int tcbdbecode(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>The return value is the last happened error code.</dd>
<dd>The following error codes are defined: `TCESUCCESS' for success, `TCETHREAD' for threading error, `TCEINVALID' for invalid operation, `TCENOFILE' for file not found, `TCENOPERM' for no permission, `TCEMETA' for invalid meta data, `TCERHEAD' for invalid record header, `TCEOPEN' for open error, `TCECLOSE' for close error, `TCETRUNC' for trunc error, `TCESYNC' for sync error, `TCESTAT' for stat error, `TCESEEK' for seek error, `TCEREAD' for read error, `TCEWRITE' for write error, `TCEMMAP' for mmap error, `TCELOCK' for lock error, `TCEUNLINK' for unlink error, `TCERENAME' for rename error, `TCEMKDIR' for mkdir error, `TCERMDIR' for rmdir error, `TCEKEEP' for existing record, `TCENOREC' for no record found, and `TCEMISC' for miscellaneous error.</dd>
</dl>

<p>The function `tcbdbsetmutex' is used in order to set mutual exclusion control of a B+ tree database object for threading.</p>

<dl class="api">
<dt><code>bool tcbdbsetmutex(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object which is not opened.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the mutual exclusion control of the database should be set before the database is opened.</dd>
</dl>

<p>The function `tcbdbsetcmpfunc' is used in order to set the custom comparison function of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbsetcmpfunc(TCBDB *<var>bdb</var>, TCCMP <var>cmp</var>, void *<var>cmpop</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object which is not opened.</dd>
<dd>`<var>cmp</var>' specifies the pointer to the custom comparison function.  It receives five parameters.  The first parameter is the pointer to the region of one key.  The second parameter is the size of the region of one key.  The third parameter is the pointer to the region of the other key.  The fourth parameter is the size of the region of the other key.  The fifth parameter is the pointer to the optional opaque object.  It returns positive if the former is big, negative if the latter is big, 0 if both are equivalent.</dd>
<dd>`<var>cmpop</var>' specifies an arbitrary pointer to be given as a parameter of the comparison function.  If it is not needed, `NULL' can be specified.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The default comparison function compares keys of two records by lexical order.  The functions `tccmplexical' (dafault), `tccmpdecimal', `tccmpint32', and `tccmpint64' are built-in.  Note that the comparison function should be set before the database is opened.  Moreover, user-defined comparison functions should be set every time the database is being opened.</dd>
</dl>

<p>The function `tcbdbtune' is used in order to set the tuning parameters of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbtune(TCBDB *<var>bdb</var>, int32_t <var>lmemb</var>, int32_t <var>nmemb</var>, int64_t <var>bnum</var>, int8_t <var>apow</var>, int8_t <var>fpow</var>, uint8_t <var>opts</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object which is not opened.</dd>
<dd>`<var>lmemb</var>' specifies the number of members in each leaf page.  If it is not more than 0, the default value is specified.  The default value is 128.</dd>
<dd>`<var>nmemb</var>' specifies the number of members in each non-leaf page.  If it is not more than 0, the default value is specified.  The default value is 256.</dd>
<dd>`<var>bnum</var>' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is 32749.  Suggested size of the bucket array is about from 1 to 4 times of the number of all pages to be stored.</dd>
<dd>`<var>apow</var>' specifies the size of record alignment by power of 2.  If it is negative, the default value is specified.  The default value is 8 standing for 2^8=256.</dd>
<dd>`<var>fpow</var>' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the default value is specified.  The default value is 10 standing for 2^10=1024.</dd>
<dd>`<var>opts</var>' specifies options by bitwise-or: `BDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64-bit bucket array, `BDBTDEFLATE' specifies that each page is compressed with Deflate encoding, `BDBTBZIP' specifies that each page is compressed with BZIP2 encoding, `BDBTTCBS' specifies that each page is compressed with TCBS encoding.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the tuning parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tcbdbsetcache' is used in order to set the caching parameters of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbsetcache(TCBDB *<var>bdb</var>, int32_t <var>lcnum</var>, int32_t <var>ncnum</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object which is not opened.</dd>
<dd>`<var>lcnum</var>' specifies the maximum number of leaf nodes to be cached.  If it is not more than 0, the default value is specified.  The default value is 1024.</dd>
<dd>`<var>ncnum</var>' specifies the maximum number of non-leaf nodes to be cached.  If it is not more than 0, the default value is specified.  The default value is 512.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the caching parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tcbdbsetxmsiz' is used in order to set the size of the extra mapped memory of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbsetxmsiz(TCBDB *<var>bdb</var>, int64_t <var>xmsiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object which is not opened.</dd>
<dd>`<var>xmsiz</var>' specifies the size of the extra mapped memory.  If it is not more than 0, the extra mapped memory is disabled.  It is disabled by default.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the mapping parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tcbdbsetdfunit' is used in order to set the unit step number of auto defragmentation of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbsetdfunit(TCBDB *<var>bdb</var>, int32_t <var>dfunit</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object which is not opened.</dd>
<dd>`<var>dfunit</var>' specifie the unit step number.  If it is not more than 0, the auto defragmentation is disabled.  It is disabled by default.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the defragmentation parameter should be set before the database is opened.</dd>
</dl>

<p>The function `tcbdbopen' is used in order to open a database file and connect a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbopen(TCBDB *<var>bdb</var>, const char *<var>path</var>, int <var>omode</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object which is not opened.</dd>
<dd>`<var>path</var>' specifies the path of the database file.</dd>
<dd>`<var>omode</var>' specifies the connection mode: `BDBOWRITER' as a writer, `BDBOREADER' as a reader.  If the mode is `BDBOWRITER', the following may be added by bitwise-or: `BDBOCREAT', which means it creates a new database if not exist, `BDBOTRUNC', which means it creates a new database regardless if one exists, `BDBOTSYNC', which means every transaction synchronizes updated contents with the device.  Both of `BDBOREADER' and `BDBOWRITER' can be added to by bitwise-or: `BDBONOLCK', which means it opens the database file without file locking, or `BDBOLCKNB', which means locking is performed without blocking.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcbdbclose' is used in order to close a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbclose(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update of a database is assured to be written when the database is closed.  If a writer opens a database but does not close it appropriately, the database will be broken.</dd>
</dl>

<p>The function `tcbdbput' is used in order to store a record into a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbput(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcbdbput2' is used in order to store a string record into a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbput2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcbdbputkeep' is used in order to store a new record into a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbputkeep(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcbdbputkeep2' is used in order to store a new string record into a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbputkeep2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcbdbputcat' is used in order to concatenate a value at the end of the existing record in a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbputcat(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcbdbputcat2' is used in order to concatenate a string value at the end of the existing record in a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbputcat2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcbdbputdup' is used in order to store a record into a B+ tree database object with allowing duplication of keys.</p>

<dl class="api">
<dt><code>bool tcbdbputdup(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, the new record is placed after the existing one.</dd>
</dl>

<p>The function `tcbdbputdup2' is used in order to store a string record into a B+ tree database object with allowing duplication of keys.</p>

<dl class="api">
<dt><code>bool tcbdbputdup2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, the new record is placed after the existing one.</dd>
</dl>

<p>The function `tcbdbputdup3' is used in order to store records into a B+ tree database object with allowing duplication of keys.</p>

<dl class="api">
<dt><code>bool tcbdbputdup3(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const TCLIST *<var>vals</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the common key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the common key.</dd>
<dd>`<var>vals</var>' specifies a list object containing values.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, the new records are placed after the existing one.</dd>
</dl>

<p>The function `tcbdbout' is used in order to remove a record of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbout(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If the key of duplicated records is specified, the first one is selected.</dd>
</dl>

<p>The function `tcbdbout2' is used in order to remove a string record of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbout2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If the key of duplicated records is specified, the first one is selected.</dd>
</dl>

<p>The function `tcbdbout3' is used in order to remove records of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbout3(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If the key of duplicated records is specified, all of them are removed.</dd>
</dl>

<p>The function `tcbdbget' is used in order to retrieve a record in a B+ tree database object.</p>

<dl class="api">
<dt><code>void *tcbdbget(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>If the key of duplicated records is specified, the first one is selected.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbget2' is used in order to retrieve a string record in a B+ tree database object.</p>

<dl class="api">
<dt><code>char *tcbdbget2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>If the key of duplicated records is specified, the first one is selected.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbget3' is used in order to retrieve a record in a B+ tree database object as a volatile buffer.</p>

<dl class="api">
<dt><code>const void *tcbdbget3(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>If the key of duplicated records is specified, the first one is selected.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is volatile and it may be spoiled by another operation of the database, the data should be copied into another involatile buffer immediately.</dd>
</dl>

<p>The function `tcbdbget4' is used in order to retrieve records in a B+ tree database object.</p>

<dl class="api">
<dt><code>TCLIST *tcbdbget4(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is a list object of the values of the corresponding records.  `NULL' is returned if no record corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbvnum' is used in order to get the number of records corresponding a key in a B+ tree database object.</p>

<dl class="api">
<dt><code>int tcbdbvnum(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is the number of the corresponding records, else, it is 0.</dd>
</dl>

<p>The function `tcbdbvnum2' is used in order to get the number of records corresponding a string key in a B+ tree database object.</p>

<dl class="api">
<dt><code>int tcbdbvnum2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the number of the corresponding records, else, it is 0.</dd>
</dl>

<p>The function `tcbdbvsiz' is used in order to get the size of the value of a record in a B+ tree database object.</p>

<dl class="api">
<dt><code>int tcbdbvsiz(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
<dd>If the key of duplicated records is specified, the first one is selected.</dd>
</dl>

<p>The function `tcbdbvsiz2' is used in order to get the size of the value of a string record in a B+ tree database object.</p>

<dl class="api">
<dt><code>int tcbdbvsiz2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
<dd>If the key of duplicated records is specified, the first one is selected.</dd>
</dl>

<p>The function `tcbdbrange' is used in order to get keys of ranged records in a B+ tree database object.</p>

<dl class="api">
<dt><code>TCLIST *tcbdbrange(TCBDB *<var>bdb</var>, const void *<var>bkbuf</var>, int <var>bksiz</var>, bool <var>binc</var>, const void *<var>ekbuf</var>, int <var>eksiz</var>, bool <var>einc</var>, int <var>max</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>bkbuf</var>' specifies the pointer to the region of the key of the beginning border.  If it is `NULL', the first record is specified.</dd>
<dd>`<var>bksiz</var>' specifies the size of the region of the beginning key.</dd>
<dd>`<var>binc</var>' specifies whether the beginning border is inclusive or not.</dd>
<dd>`<var>ekbuf</var>' specifies the pointer to the region of the key of the ending border.  If it is `NULL', the last record is specified.</dd>
<dd>`<var>eksiz</var>' specifies the size of the region of the ending key.</dd>
<dd>`<var>einc</var>' specifies whether the ending border is inclusive or not.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the keys of the corresponding records.  This function does never fail.  It returns an empty list even if no record corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbrange2' is used in order to get string keys of ranged records in a B+ tree database object.</p>

<dl class="api">
<dt><code>TCLIST *tcbdbrange2(TCBDB *<var>bdb</var>, const char *<var>bkstr</var>, bool <var>binc</var>, const char *<var>ekstr</var>, bool <var>einc</var>, int <var>max</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>bkstr</var>' specifies the string of the key of the beginning border.  If it is `NULL', the first record is specified.</dd>
<dd>`<var>binc</var>' specifies whether the beginning border is inclusive or not.</dd>
<dd>`<var>ekstr</var>' specifies the string of the key of the ending border.  If it is `NULL', the last record is specified.</dd>
<dd>`<var>einc</var>' specifies whether the ending border is inclusive or not.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the keys of the corresponding records.  This function does never fail.  It returns an empty list even if no record corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbfwmkeys' is used in order to get forward matching keys in a B+ tree database object.</p>

<dl class="api">
<dt><code>TCLIST *tcbdbfwmkeys(TCBDB *<var>bdb</var>, const void *<var>pbuf</var>, int <var>psiz</var>, int <var>max</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>pbuf</var>' specifies the pointer to the region of the prefix.</dd>
<dd>`<var>psiz</var>' specifies the size of the region of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbfwmkeys2' is used in order to get forward matching string keys in a B+ tree database object.</p>

<dl class="api">
<dt><code>TCLIST *tcbdbfwmkeys2(TCBDB *<var>bdb</var>, const char *<var>pstr</var>, int <var>max</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>pstr</var>' specifies the string of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbaddint' is used in order to add an integer to a record in a B+ tree database object.</p>

<dl class="api">
<dt><code>int tcbdbaddint(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int <var>num</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>If successful, the return value is the summation value, else, it is `INT_MIN'.</dd>
<dd>If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcbdbadddouble' is used in order to add a real number to a record in a B+ tree database object.</p>

<dl class="api">
<dt><code>double tcbdbadddouble(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, double <var>num</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>If successful, the return value is the summation value, else, it is Not-a-Number.</dd>
<dd>If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcbdbsync' is used in order to synchronize updated contents of a B+ tree database object with the file and the device.</p>

<dl class="api">
<dt><code>bool tcbdbsync(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function is useful when another process connects to the same database file.</dd>
</dl>

<p>The function `tcbdboptimize' is used in order to optimize the file of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdboptimize(TCBDB *<var>bdb</var>, int32_t <var>lmemb</var>, int32_t <var>nmemb</var>, int64_t <var>bnum</var>, int8_t <var>apow</var>, int8_t <var>fpow</var>, uint8_t <var>opts</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>lmemb</var>' specifies the number of members in each leaf page.  If it is not more than 0, the current setting is not changed.</dd>
<dd>`<var>nmemb</var>' specifies the number of members in each non-leaf page.  If it is not more than 0, the current setting is not changed.</dd>
<dd>`<var>bnum</var>' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is two times of the number of pages.</dd>
<dd>`<var>apow</var>' specifies the size of record alignment by power of 2.  If it is negative, the current setting is not changed.</dd>
<dd>`<var>fpow</var>' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the current setting is not changed.</dd>
<dd>`<var>opts</var>' specifies options by bitwise-or: `BDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64-bit bucket array, `BDBTDEFLATE' specifies that each record is compressed with Deflate encoding, `BDBTBZIP' specifies that each page is compressed with BZIP2 encoding, `BDBTTCBS' specifies that each page is compressed with TCBS encoding.  If it is `UINT8_MAX', the current setting is not changed.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function is useful to reduce the size of the database file with data fragmentation by successive updating.</dd>
</dl>

<p>The function `tcbdbvanish' is used in order to remove all records of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbvanish(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcbdbcopy' is used in order to copy the database file of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbcopy(TCBDB *<var>bdb</var>, const char *<var>path</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>path</var>' specifies the path of the destination file.  If it begins with `@', the trailing substring is executed as a command line.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if the executed command returns non-zero code.</dd>
<dd>The database file is assured to be kept synchronized and not modified while the copying or executing operation is in progress.  So, this function is useful to create a backup file of the database file.</dd>
</dl>

<p>The function `tcbdbtranbegin' is used in order to begin the transaction of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbtranbegin(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The database is locked by the thread while the transaction so that only one transaction can be activated with a database object at the same time.  Thus, the serializable isolation level is assumed if every database operation is performed in the transaction.  Because all pages are cached on memory while the transaction, the amount of referred records is limited by the memory capacity.  If the database is closed during transaction, the transaction is aborted implicitly.</dd>
</dl>

<p>The function `tcbdbtrancommit' is used in order to commit the transaction of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbtrancommit(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update in the transaction is fixed when it is committed successfully.</dd>
</dl>

<p>The function `tcbdbtranabort' is used in order to abort the transaction of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbtranabort(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update in the transaction is discarded when it is aborted.  The state of the database is rollbacked to before transaction.</dd>
</dl>

<p>The function `tcbdbpath' is used in order to get the file path of a B+ tree database object.</p>

<dl class="api">
<dt><code>const char *tcbdbpath(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>The return value is the path of the database file or `NULL' if the object does not connect to any database file.</dd>
</dl>

<p>The function `tcbdbrnum' is used in order to get the number of records of a B+ tree database object.</p>

<dl class="api">
<dt><code>uint64_t tcbdbrnum(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>The return value is the number of records or 0 if the object does not connect to any database file.</dd>
</dl>

<p>The function `tcbdbfsiz' is used in order to get the size of the database file of a B+ tree database object.</p>

<dl class="api">
<dt><code>uint64_t tcbdbfsiz(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>The return value is the size of the database file or 0 if the object does not connect to any database file.</dd>
</dl>

<p>The function `tcbdbcurnew' is used in order to create a cursor object.</p>

<dl class="api">
<dt><code>BDBCUR *tcbdbcurnew(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>The return value is the new cursor object.</dd>
<dd>Note that the cursor is available only after initialization with the `tcbdbcurfirst' or the `tcbdbcurjump' functions and so on.  Moreover, the position of the cursor will be indefinite when the database is updated after the initialization of the cursor.</dd>
</dl>

<p>The function `tcbdbcurdel' is used in order to delete a cursor object.</p>

<dl class="api">
<dt><code>void tcbdbcurdel(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
</dl>

<p>The function `tcbdbcurfirst' is used in order to move a cursor object to the first record.</p>

<dl class="api">
<dt><code>bool tcbdbcurfirst(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if there is no record in the database.</dd>
</dl>

<p>The function `tcbdbcurlast' is used in order to move a cursor object to the last record.</p>

<dl class="api">
<dt><code>bool tcbdbcurlast(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if there is no record in the database.</dd>
</dl>

<p>The function `tcbdbcurjump' is used in order to move a cursor object to the front of records corresponding a key.</p>

<dl class="api">
<dt><code>bool tcbdbcurjump(BDBCUR *<var>cur</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if there is no record corresponding the condition.</dd>
<dd>The cursor is set to the first record corresponding the key or the next substitute if completely matching record does not exist.</dd>
</dl>

<p>The function `tcbdbcurjump2' is used in order to move a cursor object to the front of records corresponding a key string.</p>

<dl class="api">
<dt><code>bool tcbdbcurjump2(BDBCUR *<var>cur</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if there is no record corresponding the condition.</dd>
<dd>The cursor is set to the first record corresponding the key or the next substitute if completely matching record does not exist.</dd>
</dl>

<p>The function `tcbdbcurprev' is used in order to move a cursor object to the previous record.</p>

<dl class="api">
<dt><code>bool tcbdbcurprev(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if there is no previous record.</dd>
</dl>

<p>The function `tcbdbcurnext' is used in order to move a cursor object to the next record.</p>

<dl class="api">
<dt><code>bool tcbdbcurnext(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if there is no next record.</dd>
</dl>

<p>The function `tcbdbcurput' is used in order to insert a record around a cursor object.</p>

<dl class="api">
<dt><code>bool tcbdbcurput(BDBCUR *<var>cur</var>, const void *<var>vbuf</var>, int <var>vsiz</var>, int <var>cpmode</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object of writer connection.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>`<var>cpmode</var>' specifies detail adjustment: `BDBCPCURRENT', which means that the value of the current record is overwritten, `BDBCPBEFORE', which means that the new record is inserted before the current record, `BDBCPAFTER', which means that the new record is inserted after the current record.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned when the cursor is at invalid position.</dd>
<dd>After insertion, the cursor is moved to the inserted record.</dd>
</dl>

<p>The function `tcbdbcurput2' is used in order to insert a string record around a cursor object.</p>

<dl class="api">
<dt><code>bool tcbdbcurput2(BDBCUR *<var>cur</var>, const char *<var>vstr</var>, int <var>cpmode</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object of writer connection.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>`<var>cpmode</var>' specifies detail adjustment: `BDBCPCURRENT', which means that the value of the current record is overwritten, `BDBCPBEFORE', which means that the new record is inserted before the current record, `BDBCPAFTER', which means that the new record is inserted after the current record.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned when the cursor is at invalid position.</dd>
<dd>After insertion, the cursor is moved to the inserted record.</dd>
</dl>

<p>The function `tcbdbcurout' is used in order to remove the record where a cursor object is.</p>

<dl class="api">
<dt><code>bool tcbdbcurout(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object of writer connection.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned when the cursor is at invalid position.</dd>
<dd>After deletion, the cursor is moved to the next record if possible.</dd>
</dl>

<p>The function `tcbdbcurkey' is used in order to get the key of the record where the cursor object is.</p>

<dl class="api">
<dt><code>void *tcbdbcurkey(BDBCUR *<var>cur</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the key, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbcurkey2' is used in order to get the key string of the record where the cursor object is.</p>

<dl class="api">
<dt><code>char *tcbdbcurkey2(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>If successful, the return value is the string of the key, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbcurkey3' is used in order to get the key of the record where the cursor object is, as a volatile buffer.</p>

<dl class="api">
<dt><code>const void *tcbdbcurkey3(BDBCUR *<var>cur</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the key, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is volatile and it may be spoiled by another operation of the database, the data should be copied into another involatile buffer immediately.</dd>
</dl>

<p>The function `tcbdbcurval' is used in order to get the value of the record where the cursor object is.</p>

<dl class="api">
<dt><code>void *tcbdbcurval(BDBCUR *<var>cur</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbcurval2' is used in order to get the value string of the record where the cursor object is.</p>

<dl class="api">
<dt><code>char *tcbdbcurval2(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>If successful, the return value is the string of the value, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbcurval3' is used in order to get the value of the record where the cursor object is, as a volatile buffer.</p>

<dl class="api">
<dt><code>const void *tcbdbcurval3(BDBCUR *<var>cur</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is volatile and it may be spoiled by another operation of the database, the data should be copied into another involatile buffer immediately.</dd>
</dl>

<p>The function `tcbdbcurrec' is used in order to get the key and the value of the record where the cursor object is.</p>

<dl class="api">
<dt><code>bool tcbdbcurrec(BDBCUR *<var>cur</var>, TCXSTR *<var>kxstr</var>, TCXSTR *<var>vxstr</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>kxstr</var>' specifies the object into which the key is wrote down.</dd>
<dd>`<var>vxstr</var>' specifies the object into which the value is wrote down.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned when the cursor is at invalid position.</dd>
</dl>

<h3 id="tcbdbapi_example">Example Code</h3>

<p>The following code is an example to use a B+ tree database.</p>

<pre>#include &lt;tcutil.h&gt;
#include &lt;tcbdb.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;

int main(int argc, char **argv){
  TCBDB *bdb;
  BDBCUR *cur;
  int ecode;
  char *key, *value;

  /* create the object */
  bdb = tcbdbnew();

  /* open the database */
  if(!tcbdbopen(bdb, "casket.tcb", BDBOWRITER | BDBOCREAT)){
    ecode = tcbdbecode(bdb);
    fprintf(stderr, "open error: %s\n", tcbdberrmsg(ecode));
  }

  /* store records */
  if(!tcbdbput2(bdb, "foo", "hop") ||
     !tcbdbput2(bdb, "bar", "step") ||
     !tcbdbput2(bdb, "baz", "jump")){
    ecode = tcbdbecode(bdb);
    fprintf(stderr, "put error: %s\n", tcbdberrmsg(ecode));
  }

  /* retrieve records */
  value = tcbdbget2(bdb, "foo");
  if(value){
    printf("%s\n", value);
    free(value);
  } else {
    ecode = tcbdbecode(bdb);
    fprintf(stderr, "get error: %s\n", tcbdberrmsg(ecode));
  }

  /* traverse records */
  cur = tcbdbcurnew(bdb);
  tcbdbcurfirst(cur);
  while((key = tcbdbcurkey2(cur)) != NULL){
    value = tcbdbcurval2(cur);
    if(value){
      printf("%s:%s\n", key, value);
      free(value);
    }
    free(key);
    tcbdbcurnext(cur);
  }
  tcbdbcurdel(cur);

  /* close the database */
  if(!tcbdbclose(bdb)){
    ecode = tcbdbecode(bdb);
    fprintf(stderr, "close error: %s\n", tcbdberrmsg(ecode));
  }

  /* delete the object */
  tcbdbdel(bdb);

  return 0;
}
</pre>

<h3 id="tcbdbapi_cli">CLI</h3>

<p>To use the B+ tree database API easily, the commands `<code>tcbtest</code>', `<code>tcbmttest</code>', and `<code>tcbmgr</code>' are provided.</p>

<p>The command `<code>tcbtest</code>' is a utility for facility test and performance test.  This command is used in the following format.  `<var>path</var>' specifies the path of a database file.  `<var>rnum</var>' specifies the number of iterations.  `<var>lmemb</var>' specifies the number of members in each leaf page.  `<var>nmemb</var>' specifies the number of members in each non-leaf page.  `<var>bnum</var>' specifies the number of buckets.  `<var>apow</var>' specifies the power of the alignment.  `<var>fpow</var>' specifies the power of the free block pool.</p>

<dl class="api">
<dt><code>tcbtest write [-mt] [-cd|-ci|-cj] [-tl] [-td|-tb|-tt|-tx] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-ls <var>num</var>] [-ca <var>num</var>] [-nl|-nb] [-rnd] <var>path</var> <var>rnum</var> [<var>lmemb</var> [<var>nmemb</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]]]</code></dt>
<dd>Store records with keys of 8 bytes.  They change as `00000001', `00000002'...</dd>
<dt><code>tcbtest read [-mt] [-cd|-ci|-cj] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-wb] [-rnd] <var>path</var></code></dt>
<dd>Retrieve all records of the database above.</dd>
<dt><code>tcbtest remove [-mt] [-cd|-ci|-cj] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-rnd] <var>path</var></code></dt>
<dd>Remove all records of the database above.</dd>
<dt><code>tcbtest rcat [-mt] [-cd|-ci|-cj] [-tl] [-td|-tb|-tt|-tx] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-ls <var>num</var>] [-ca <var>num</var>] [-nl|-nb] [-pn <var>num</var>] [-dai|-dad|-rl|-ru] <var>path</var> <var>rnum</var> [<var>lmemb</var> [<var>nmemb</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]]]</code></dt>
<dd>Store records with partway duplicated keys using concatenate mode.</dd>
<dt><code>tcbtest queue [-mt] [-cd|-ci|-cj] [-tl] [-td|-tb|-tt|-tx] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-ls <var>num</var>] [-ca <var>num</var>] [-nl|-nb] <var>path</var> <var>rnum</var> [<var>lmemb</var> [<var>nmemb</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]]]</code></dt>
<dd>Perform queueing and dequeueing.</dd>
<dt><code>tcbtest misc [-mt] [-tl] [-td|-tb|-tt|-tx] [-nl|-nb] <var>path</var> <var>rnum</var></code></dt>
<dd>Perform miscellaneous test of various operations.</dd>
<dt><code>tcbtest wicked [-mt] [-tl] [-td|-tb|-tt|-tx] [-nl|-nb] <var>path</var> <var>rnum</var></code></dt>
<dd>Perform updating operations selected at random.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-mt</code> : call the function `tchdbsetmutex'.</li>
<li><code>-cd</code> : use the comparison function `tccmpdecimal'.</li>
<li><code>-ci</code> : use the comparison function  `tccmpint32'.</li>
<li><code>-cj</code> : use the comparison function  `tccmpint64'.</li>
<li><code>-tl</code> : enable the option `BDBTLARGE'.</li>
<li><code>-td</code> : enable the option `BDBTDEFLATE'.</li>
<li><code>-tb</code> : enable the option `BDBTBZIP'.</li>
<li><code>-tt</code> : enable the option `BDBTTCBS'.</li>
<li><code>-tx</code> : enable the option `BDBTEXCODEC'.</li>
<li><code>-lc <var>num</var></code> : specify the number of cached leaf pages.</li>
<li><code>-nc <var>num</var></code> : specify the number of cached non-leaf pages.</li>
<li><code>-xm <var>num</var></code> : specify the size of the extra mapped memory.</li>
<li><code>-df <var>num</var></code> : specify the unit step number of auto defragmentation.</li>
<li><code>-ls <var>num</var></code> : specify the maximum size of each leaf page.</li>
<li><code>-ca <var>num</var></code> : specify the capacity number of records.</li>
<li><code>-nl</code> : enable the option `BDBNOLCK'.</li>
<li><code>-nb</code> : enable the option `BDBLCKNB'.</li>
<li><code>-rnd</code> : select keys at random.</li>
<li><code>-wb</code> : use the function `tcbdbget3' instead of `tcbdbget'.</li>
<li><code>-pn <var>num</var></code> : specify the number of patterns.</li>
<li><code>-dai</code> : use the function `tcbdbaddint' instead of `tcbdbputcat'.</li>
<li><code>-dad</code> : use the function `tcbdbadddouble' instead of `tcbdbputcat'.</li>
<li><code>-rl</code> : set the length of values at random.</li>
<li><code>-ru</code> : select update operations at random.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<p>The command `<code>tcbmttest</code>' is a utility for facility test and performance test.  This command is used in the following format.  `<var>path</var>' specifies the path of a database file.  `<var>tnum</var>' specifies the number of running threads.  `<var>rnum</var>' specifies the number of iterations.  `<var>lmemb</var>' specifies the number of members in each leaf page.  `<var>nmemb</var>' specifies the number of members in each non-leaf page.  `<var>bnum</var>' specifies the number of buckets.  `<var>apow</var>' specifies the power of the alignment.  `<var>fpow</var>' specifies the power of the free block pool.</p>

<dl class="api">
<dt><code>tcbmttest write [-tl] [-td|-tb|-tt|-tx] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-rnd] <var>path</var> <var>tnum</var> <var>rnum</var> [<var>lmemb</var> [<var>nmemb</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]]]</code></dt>
<dd>Store records with keys of 8 bytes.  They change as `00000001', `00000002'...</dd>
<dt><code>tcbmttest read [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-wb] [-rnd] <var>path</var> <var>tnum</var></code></dt>
<dd>Retrieve all records of the database above.</dd>
<dt><code>tcbmttest remove [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-rnd] <var>path</var> <var>tnum</var></code></dt>
<dd>Remove all records of the database above.</dd>
<dt><code>tcbmttest wicked [-tl] [-td|-tb|-tt|-tx] [-nl|-nb] [-nc] <var>path</var> <var>tnum</var> <var>rnum</var></code></dt>
<dd>Perform updating operations selected at random.</dd>
<dt><code>tcbmttest typical [-tl] [-td|-tb|-tt|-tx] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-nc] [-rr <var>num</var>] <var>path</var> <var>tnum</var> <var>rnum</var> [<var>lmemb</var> [<var>nmemb</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]]]</code></dt>
<dd>Perform typical operations selected at random.</dd>
<dt><code>tcbmttest race [-tl] [-td|-tb|-tt|-tx] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] <var>path</var> <var>tnum</var> <var>rnum</var> [<var>lmemb</var> [<var>nmemb</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]]]</code></dt>
<dd>Perform race condition test.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-tl</code> : enable the option `BDBTLARGE'.</li>
<li><code>-td</code> : enable the option `BDBTDEFLATE'.</li>
<li><code>-tb</code> : enable the option `BDBTBZIP'.</li>
<li><code>-tt</code> : enable the option `BDBTTCBS'.</li>
<li><code>-tx</code> : enable the option `BDBTEXCODEC'.</li>
<li><code>-xm <var>num</var></code> : specify the size of the extra mapped memory.</li>
<li><code>-df <var>num</var></code> : specify the unit step number of auto defragmentation.</li>
<li><code>-nl</code> : enable the option `BDBNOLCK'.</li>
<li><code>-nb</code> : enable the option `BDBLCKNB'.</li>
<li><code>-rnd</code> : select keys at random.</li>
<li><code>-wb</code> : use the function `tchdbget3' instead of `tchdbget'.</li>
<li><code>-nc</code> : omit the comparison test.</li>
<li><code>-rr <var>num</var></code> : specify the ratio of reading operation by percentage.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<p>The command `<code>tcbmgr</code>' is a utility for test and debugging of the B+ tree database API and its applications.  `<var>path</var>' specifies the path of a database file.  `<var>lmemb</var>' specifies the number of members in each leaf page.  `<var>nmemb</var>' specifies the number of members in each non-leaf page.  `<var>bnum</var>' specifies the number of buckets.  `<var>apow</var>' specifies the power of the alignment.  `<var>fpow</var>' specifies the power of the free block pool.  `<var>key</var>' specifies the key of a record.  `<var>value</var>' specifies the value of a record.  `<var>file</var>' specifies the input file.</p>

<dl class="api">
<dt><code>tcbmgr create [-cd|-ci|-cj] [-tl] [-td|-tb|-tt|-tx] <var>path</var> [<var>lmemb</var> [<var>nmemb</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]]]</code></dt>
<dd>Create a database file.</dd>
<dt><code>tcbmgr inform [-nl|-nb] <var>path</var></code></dt>
<dd>Print miscellaneous information to the standard output.</dd>
<dt><code>tcbmgr put [-cd|-ci|-cj] [-nl|-nb] [-sx] [-dk|-dc|-dd|-db|-dai|-dad] <var>path</var> <var>key</var> <var>value</var></code></dt>
<dd>Store a record.</dd>
<dt><code>tcbmgr out [-cd|-ci|-cj] [-nl|-nb] [-sx] <var>path</var> <var>key</var></code></dt>
<dd>Remove a record.</dd>
<dt><code>tcbmgr get [-cd|-ci|-cj] [-nl|-nb] [-sx] [-px] [-pz] <var>path</var> <var>key</var></code></dt>
<dd>Print the value of a record.</dd>
<dt><code>tcbmgr list [-cd|-ci|-cj] [-nl|-nb] [-m <var>num</var>] [-bk] [-pv] [-px] [-j <var>str</var>] [-rb <var>bkey</var> <var>ekey</var>] [-fm <var>str</var>] <var>path</var></code></dt>
<dd>Print keys of all records, separated by line feeds.</dd>
<dt><code>tcbmgr optimize [-cd|-ci|-cj] [-tl] [-td|-tb|-tt|-tx] [-tz] [-nl|-nb] [-df] <var>path</var> [<var>lmemb</var> [<var>nmemb</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]]]</code></dt>
<dd>Optimize a database file.</dd>
<dt><code>tcbmgr importtsv [-nl|-nb] [-sc] <var>path</var> [<var>file</var>]</code></dt>
<dd>Store records of TSV in each line of a file.</dd>
<dt><code>tcbmgr version</code></dt>
<dd>Print the version information of Tokyo Cabinet.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-cd</code> : use the comparison function `tccmpdecimal'.</li>
<li><code>-ci</code> : use the comparison function  `tccmpint32'.</li>
<li><code>-cj</code> : use the comparison function  `tccmpint64'.</li>
<li><code>-tl</code> : enable the option `BDBTLARGE'.</li>
<li><code>-td</code> : enable the option `BDBTDEFLATE'.</li>
<li><code>-tb</code> : enable the option `BDBTBZIP'.</li>
<li><code>-tt</code> : enable the option `BDBTTCBS'.</li>
<li><code>-tx</code> : enable the option `BDBTEXCODEC'.</li>
<li><code>-nl</code> : enable the option `BDBNOLCK'.</li>
<li><code>-nb</code> : enable the option `BDBLCKNB'.</li>
<li><code>-sx</code> : the input data is evaluated as a hexadecimal data string.</li>
<li><code>-dk</code> : use the function `tcbdbputkeep' instead of `tcbdbput'.</li>
<li><code>-dc</code> : use the function `tcbdbputcat' instead of `tcbdbput'.</li>
<li><code>-dd</code> : use the function `tcbdbputdup' instead of `tcbdbput'.</li>
<li><code>-db</code> : use the function `tcbdbputdupback' instead of `tcbdbput'.</li>
<li><code>-dai</code> : use the function `tcbdbaddint' instead of `tcbdbput'.</li>
<li><code>-dad</code> : use the function `tcbdbadddouble' instead of `tcbdbput'.</li>
<li><code>-px</code> : the output data is converted into a hexadecimal data string.</li>
<li><code>-pz</code> : do not append line feed at the end of the output.</li>
<li><code>-m <var>num</var></code> : specify the maximum number of the output.</li>
<li><code>-bk</code> : perform backword scanning.</li>
<li><code>-pv</code> : print values of records also.</li>
<li><code>-j <var>str</var></code> : specify the key where the cursor jump to.</li>
<li><code>-rb <var>bkey</var> <var>ekey</var></code> : specify the range of keys.</li>
<li><code>-fm <var>str</var></code> : specify the prefix of keys.</li>
<li><code>-tz</code> : enable the option `UINT8_MAX'.</li>
<li><code>-df</code> : perform defragmentation only.</li>
<li><code>-sc</code> : normalize keys as lower cases.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<hr />

<h2 id="tcfdbapi">The Fixed-length Database API</h2>

<p>Fixed-length database is a file containing an array of fixed-length elements and is handled with the fixed-length database API.  See `<code>tcfdb.h</code>' for the entire specification.</p>

<h3 id="tcfdbapi_description">Description</h3>

<p>To use the fixed-length database API, include `<code>tcutil.h</code>', `<code>tcfdb.h</code>', and related standard header files.  Usually, write the following description near the front of a source file.</p>

<dl>
<dt><code>#include &lt;tcutil.h&gt;</code></dt>
<dt><code>#include &lt;tcfdb.h&gt;</code></dt>
<dt><code>#include &lt;stdlib.h&gt;</code></dt>
<dt><code>#include &lt;stdbool.h&gt;</code></dt>
<dt><code>#include &lt;stdint.h&gt;</code></dt>
</dl>

<p>Objects whose type is pointer to `<code>TCFDB</code>' are used to handle fixed-length databases.  A fixed-length database object is created with the function `<code>tcfdbnew</code>' and is deleted with the function `<code>tcfdbdel</code>'.  To avoid memory leak, it is important to delete every object when it is no longer in use.</p>

<p>Before operations to store or retrieve records, it is necessary to open a database file and connect the fixed-length database object to it.  The function `<code>tcfdbopen</code>' is used to open a database file and the function `<code>tcfdbclose</code>' is used to close the database file.  To avoid data missing or corruption, it is important to close every database file when it is no longer in use.  It is forbidden for multible database objects in a process to open the same database at the same time.</p>

<h3 id="tcfdbapi_api">API</h3>

<p>The function `tcfdberrmsg' is used in order to get the message string corresponding to an error code.</p>

<dl class="api">
<dt><code>const char *tcfdberrmsg(int <var>ecode</var>);</code></dt>
<dd>`<var>ecode</var>' specifies the error code.</dd>
<dd>The return value is the message string of the error code.</dd>
</dl>

<p>The function `tcfdbnew' is used in order to create a fixed-length database object.</p>

<dl class="api">
<dt><code>TCFDB *tcfdbnew(void);</code></dt>
<dd>The return value is the new fixed-length database object.</dd>
</dl>

<p>The function `tcfdbdel' is used in order to delete a fixed-length database object.</p>

<dl class="api">
<dt><code>void tcfdbdel(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>If the database is not closed, it is closed implicitly.  Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tcfdbecode' is used in order to get the last happened error code of a fixed-length database object.</p>

<dl class="api">
<dt><code>int tcfdbecode(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>The return value is the last happened error code.</dd>
<dd>The following error codes are defined: `TCESUCCESS' for success, `TCETHREAD' for threading error, `TCEINVALID' for invalid operation, `TCENOFILE' for file not found, `TCENOPERM' for no permission, `TCEMETA' for invalid meta data, `TCERHEAD' for invalid record header, `TCEOPEN' for open error, `TCECLOSE' for close error, `TCETRUNC' for trunc error, `TCESYNC' for sync error, `TCESTAT' for stat error, `TCESEEK' for seek error, `TCEREAD' for read error, `TCEWRITE' for write error, `TCEMMAP' for mmap error, `TCELOCK' for lock error, `TCEUNLINK' for unlink error, `TCERENAME' for rename error, `TCEMKDIR' for mkdir error, `TCERMDIR' for rmdir error, `TCEKEEP' for existing record, `TCENOREC' for no record found, and `TCEMISC' for miscellaneous error.</dd>
</dl>

<p>The function `tcfdbsetmutex' is used in order to set mutual exclusion control of a fixed-length database object for threading.</p>

<dl class="api">
<dt><code>bool tcfdbsetmutex(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object which is not opened.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the mutual exclusion control is needed if the object is shared by plural threads and this function should be called before the database is opened.</dd>
</dl>

<p>The function `tcfdbtune' is used in order to set the tuning parameters of a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbtune(TCFDB *<var>fdb</var>, int32_t <var>width</var>, int64_t <var>limsiz</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object which is not opened.</dd>
<dd>`<var>width</var>' specifies the width of the value of each record.  If it is not more than 0, the default value is specified.  The default value is 255.</dd>
<dd>`<var>limsiz</var>' specifies the limit size of the database file.  If it is not more than 0, the default value is specified.  The default value is 268435456.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the tuning parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tcfdbopen' is used in order to open a database file and connect a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbopen(TCFDB *<var>fdb</var>, const char *<var>path</var>, int <var>omode</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object which is not opened.</dd>
<dd>`<var>path</var>' specifies the path of the database file.</dd>
<dd>`<var>omode</var>' specifies the connection mode: `FDBOWRITER' as a writer, `FDBOREADER' as a reader.  If the mode is `FDBOWRITER', the following may be added by bitwise-or: `FDBOCREAT', which means it creates a new database if not exist, `FDBOTRUNC', which means it creates a new database regardless if one exists, `FDBOTSYNC', which means every transaction synchronizes updated contents with the device.  Both of `FDBOREADER' and `FDBOWRITER' can be added to by bitwise-or: `FDBONOLCK', which means it opens the database file without file locking, or `FDBOLCKNB', which means locking is performed without blocking.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcfdbclose' is used in order to close a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbclose(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update of a database is assured to be written when the database is closed.  If a writer opens a database but does not close it appropriately, the database will be broken.</dd>
</dl>

<p>The function `tcfdbput' is used in order to store a record into a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbput(TCFDB *<var>fdb</var>, int64_t <var>id</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>id</var>' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDPREV', the number less by one than the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.  If it is `FDBIDNEXT', the number greater by one than the maximum ID number of existing records is specified.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.  If the size of the value is greater than the width tuning parameter of the database, the size is cut down to the width.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcfdbput2' is used in order to store a record with a decimal key into a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbput2(TCFDB *<var>fdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "prev", the number less by one than the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.  If it is "next", the number greater by one than the maximum ID number of existing records is specified.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.  If the size of the value is greater than the width tuning parameter of the database, the size is cut down to the width.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcfdbput3' is used in order to store a string record with a decimal key into a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbput3(TCFDB *<var>fdb</var>, const char *<var>kstr</var>, const void *<var>vstr</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "prev", the number less by one than the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.  If it is "next", the number greater by one than the maximum ID number of existing records is specified.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcfdbputkeep' is used in order to store a new record into a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbputkeep(TCFDB *<var>fdb</var>, int64_t <var>id</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>id</var>' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDPREV', the number less by one than the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.  If it is `FDBIDNEXT', the number greater by one than the maximum ID number of existing records is specified.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.  If the size of the value is greater than the width tuning parameter of the database, the size is cut down to the width.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcfdbputkeep2' is used in order to store a new record with a decimal key into a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbputkeep2(TCFDB *<var>fdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "prev", the number less by one than the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.  If it is "next", the number greater by one than the maximum ID number of existing records is specified.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.  If the size of the value is greater than the width tuning parameter of the database, the size is cut down to the width.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcfdbputkeep3' is used in order to store a new string record with a decimal key into a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbputkeep3(TCFDB *<var>fdb</var>, const char *<var>kstr</var>, const void *<var>vstr</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "prev", the number less by one than the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.  If it is "next", the number greater by one than the maximum ID number of existing records is specified.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcfdbputcat' is used in order to concatenate a value at the end of the existing record in a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbputcat(TCFDB *<var>fdb</var>, int64_t <var>id</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>id</var>' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDPREV', the number less by one than the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.  If it is `FDBIDNEXT', the number greater by one than the maximum ID number of existing records is specified.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.  If the size of the value is greater than the width tuning parameter of the database, the size is cut down to the width.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcfdbputcat2' is used in order to concatenate a value with a decimal key in a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbputcat2(TCFDB *<var>fdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "prev", the number less by one than the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.  If it is "next", the number greater by one than the maximum ID number of existing records is specified.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.  If the size of the value is greater than the width tuning parameter of the database, the size is cut down to the width.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcfdbputcat3' is used in order to concatenate a string value with a decimal key in a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbputcat3(TCFDB *<var>fdb</var>, const char *<var>kstr</var>, const void *<var>vstr</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "prev", the number less by one than the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.  If it is "next", the number greater by one than the maximum ID number of existing records is specified.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcfdbout' is used in order to remove a record of a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbout(TCFDB *<var>fdb</var>, int64_t <var>id</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>id</var>' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcfdbout2' is used in order to remove a record with a decimal key of a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbout2(TCFDB *<var>fdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcfdbout3' is used in order to remove a string record with a decimal key of a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbout3(TCFDB *<var>fdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcfdbget' is used in order to retrieve a record in a fixed-length database object.</p>

<dl class="api">
<dt><code>void *tcfdbget(TCFDB *<var>fdb</var>, int64_t <var>id</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>id</var>' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcfdbget2' is used in order to retrieve a record with a decimal key in a fixed-length database object.</p>

<dl class="api">
<dt><code>void *tcfdbget2(TCFDB *<var>fdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcfdbget3' is used in order to retrieve a string record with a decimal key in a fixed-length database object.</p>

<dl class="api">
<dt><code>char *tcfdbget3(TCFDB *<var>fdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.</dd>
<dd>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcfdbget4' is used in order to retrieve a record in a fixed-length database object and write the value into a buffer.</p>

<dl class="api">
<dt><code>int tcfdbget4(TCFDB *<var>fdb</var>, int64_t <var>id</var>, void *<var>vbuf</var>, int <var>max</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>id</var>' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the buffer into which the value of the corresponding record is written.</dd>
<dd>`<var>max</var>' specifies the size of the buffer.</dd>
<dd>If successful, the return value is the size of the written data, else, it is -1.  -1 is returned if no record corresponds to the specified key.</dd>
<dd>Note that an additional zero code is not appended at the end of the region of the writing buffer.</dd>
</dl>

<p>The function `tcfdbvsiz' is used in order to get the size of the value of a record in a fixed-length database object.</p>

<dl class="api">
<dt><code>int tcfdbvsiz(TCFDB *<var>fdb</var>, int64_t <var>id</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>id</var>' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tcfdbvsiz2' is used in order to get the size of the value with a decimal key in a fixed-length database object.</p>

<dl class="api">
<dt><code>int tcfdbvsiz2(TCFDB *<var>fdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tcfdbvsiz3' is used in order to get the size of the string value with a decimal key in a fixed-length database object.</p>

<dl class="api">
<dt><code>int tcfdbvsiz3(TCFDB *<var>fdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tcfdbiterinit' is used in order to initialize the iterator of a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbiterinit(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The iterator is used in order to access the key of every record stored in a database.</dd>
</dl>

<p>The function `tcfdbiternext' is used in order to get the next ID number of the iterator of a fixed-length database object.</p>

<dl class="api">
<dt><code>uint64_t tcfdbiternext(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>If successful, the return value is the next ID number of the iterator, else, it is 0.  0 is returned when no record is to be get out of the iterator.</dd>
<dd>It is possible to access every record by iteration of calling this function.  It is allowed to update or remove records whose keys are fetched while the iteration.  The order of this traversal access method is ascending of the ID number.</dd>
</dl>

<p>The function `tcfdbiternext2' is used in order to get the next decimay key of the iterator of a fixed-length database object.</p>

<dl class="api">
<dt><code>void *tcfdbiternext2(TCFDB *<var>fdb</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the next decimal key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  It is allowed to update or remove records whose keys are fetched while the iteration.  The order of this traversal access method is ascending of the ID number.</dd>
</dl>

<p>The function `tcfdbiternext3' is used in order to get the next decimay key string of the iterator of a fixed-length database object.</p>

<dl class="api">
<dt><code>char *tcfdbiternext3(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>If successful, the return value is the string of the next decimal key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  It is allowed to update or remove records whose keys are fetched while the iteration.  The order of this traversal access method is ascending of the ID number.</dd>
</dl>

<p>The function `tcfdbrange' is used in order to get range matching ID numbers in a fixed-length database object.</p>

<dl class="api">
<dt><code>uint64_t *tcfdbrange(TCFDB *<var>fdb</var>, int64_t <var>lower</var>, int64_t <var>upper</var>, int <var>max</var>, int *<var>np</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>lower</var>' specifies the lower limit of the range.  If it is `FDBIDMIN', the minimum ID is specified.</dd>
<dd>`<var>upper</var>' specifies the upper limit of the range.  If it is `FDBIDMAX', the maximum ID is specified.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>`<var>np</var>' specifies the pointer to the variable into which the number of elements of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to an array of ID numbers of the corresponding records.  `NULL' is returned on failure.  This function does never fail.  It returns an empty array even if no key corresponds.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcfdbrange2' is used in order to get range matching decimal keys in a fixed-length database object.</p>

<dl class="api">
<dt><code>TCLIST *tcfdbrange2(TCFDB *<var>fdb</var>, const void *<var>lbuf</var>, int <var>lsiz</var>, const void *<var>ubuf</var>, int <var>usiz</var>, int <var>max</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>lbuf</var>' specifies the pointer to the region of the lower key.  If it is "min", the minimum ID number of existing records is specified.</dd>
<dd>`<var>lsiz</var>' specifies the size of the region of the lower key.</dd>
<dd>`<var>ubuf</var>' specifies the pointer to the region of the upper key.  If it is "max", the maximum ID number of existing records is specified.</dd>
<dd>`<var>usiz</var>' specifies the size of the region of the upper key.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding decimal keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</dd>
</dl>

<p>The function `tcfdbrange3' is used in order to get range matching decimal keys with strings in a fixed-length database object.</p>

<dl class="api">
<dt><code>TCLIST *tcfdbrange3(TCFDB *<var>fdb</var>, const char *<var>lstr</var>, const char *<var>ustr</var>, int <var>max</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>lstr</var>' specifies the string of the lower key.  If it is "min", the minimum ID number of existing records is specified.</dd>
<dd>`<var>ustr</var>' specifies the string of the upper key.  If it is "max", the maximum ID number of existing records is specified.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding decimal keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</dd>
</dl>

<p>The function `tcfdbrange4' is used in order to get keys with an interval notation in a fixed-length database object.</p>

<dl class="api">
<dt><code>TCLIST *tcfdbrange4(TCFDB *<var>fdb</var>, const void *<var>ibuf</var>, int <var>isiz</var>, int <var>max</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>ibuf</var>' specifies the pointer to the region of the interval notation.</dd>
<dd>`<var>isiz</var>' specifies the size of the region of the interval notation.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding decimal keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</dd>
</dl>

<p>The function `tcfdbrange5' is used in order to get keys with an interval notation string in a fixed-length database object.</p>

<dl class="api">
<dt><code>TCLIST *tcfdbrange5(TCFDB *<var>fdb</var>, const void *<var>istr</var>, int <var>max</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>istr</var>' specifies the pointer to the region of the interval notation string.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding decimal keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</dd>
</dl>

<p>The function `tcfdbaddint' is used in order to add an integer to a record in a fixed-length database object.</p>

<dl class="api">
<dt><code>int tcfdbaddint(TCFDB *<var>fdb</var>, int64_t <var>id</var>, int <var>num</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>id</var>' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDPREV', the number less by one than the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.  If it is `FDBIDNEXT', the number greater by one than the maximum ID number of existing records is specified.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>If successful, the return value is the summation value, else, it is `INT_MIN'.</dd>
<dd>If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcfdbadddouble' is used in order to add a real number to a record in a fixed-length database object.</p>

<dl class="api">
<dt><code>double tcfdbadddouble(TCFDB *<var>fdb</var>, int64_t <var>id</var>, double <var>num</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>id</var>' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDPREV', the number less by one than the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.  If it is `FDBIDNEXT', the number greater by one than the maximum ID number of existing records is specified.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>If successful, the return value is the summation value, else, it is Not-a-Number.</dd>
<dd>If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcfdbsync' is used in order to synchronize updated contents of a fixed-length database object with the file and the device.</p>

<dl class="api">
<dt><code>bool tcfdbsync(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function is useful when another process connects to the same database file.</dd>
</dl>

<p>The function `tcfdboptimize' is used in order to optimize the file of a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdboptimize(TCFDB *<var>fdb</var>, int32_t <var>width</var>, int64_t <var>limsiz</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>width</var>' specifies the width of the value of each record.  If it is not more than 0, the current setting is not changed.</dd>
<dd>`<var>limsiz</var>' specifies the limit size of the database file.  If it is not more than 0, the current setting is not changed.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcfdbvanish' is used in order to remove all records of a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbvanish(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcfdbcopy' is used in order to copy the database file of a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbcopy(TCFDB *<var>fdb</var>, const char *<var>path</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>path</var>' specifies the path of the destination file.  If it begins with `@', the trailing substring is executed as a command line.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if the executed command returns non-zero code.</dd>
<dd>The database file is assured to be kept synchronized and not modified while the copying or executing operation is in progress.  So, this function is useful to create a backup file of the database file.</dd>
</dl>

<p>The function `tcfdbtranbegin' is used in order to begin the transaction of a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbtranbegin(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The database is locked by the thread while the transaction so that only one transaction can be activated with a database object at the same time.  Thus, the serializable isolation level is assumed if every database operation is performed in the transaction.  All updated regions are kept track of by write ahead logging while the transaction.  If the database is closed during transaction, the transaction is aborted implicitly.</dd>
</dl>

<p>The function `tcfdbtrancommit' is used in order to commit the transaction of a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbtrancommit(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update in the transaction is fixed when it is committed successfully.</dd>
</dl>

<p>The function `tcfdbtranabort' is used in order to abort the transaction of a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbtranabort(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update in the transaction is discarded when it is aborted.  The state of the database is rollbacked to before transaction.</dd>
</dl>

<p>The function `tcfdbpath' is used in order to get the file path of a fixed-length database object.</p>

<dl class="api">
<dt><code>const char *tcfdbpath(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>The return value is the path of the database file or `NULL' if the object does not connect to any database file.</dd>
</dl>

<p>The function `tcfdbrnum' is used in order to get the number of records of a fixed-length database object.</p>

<dl class="api">
<dt><code>uint64_t tcfdbrnum(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>The return value is the number of records or 0 if the object does not connect to any database file.</dd>
</dl>

<p>The function `tcfdbfsiz' is used in order to get the size of the database file of a fixed-length database object.</p>

<dl class="api">
<dt><code>uint64_t tcfdbfsiz(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>The return value is the size of the database file or 0 if the object does not connect to any database file.</dd>
</dl>

<h3 id="tcfdbapi_example">Example Code</h3>

<p>The following code is an example to use a hash database.</p>

<pre>#include &lt;tcutil.h&gt;
#include &lt;tcfdb.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;

int main(int argc, char **argv){
  TCFDB *fdb;
  int ecode;
  char *key, *value;

  /* create the object */
  fdb = tcfdbnew();

  /* open the database */
  if(!tcfdbopen(fdb, "casket.tcf", FDBOWRITER | FDBOCREAT)){
    ecode = tcfdbecode(fdb);
    fprintf(stderr, "open error: %s\n", tcfdberrmsg(ecode));
  }

  /* store records */
  if(!tcfdbput3(fdb, "1", "one") ||
     !tcfdbput3(fdb, "12", "twelve") ||
     !tcfdbput3(fdb, "144", "one forty four")){
    ecode = tcfdbecode(fdb);
    fprintf(stderr, "put error: %s\n", tcfdberrmsg(ecode));
  }

  /* retrieve records */
  value = tcfdbget3(fdb, "1");
  if(value){
    printf("%s\n", value);
    free(value);
  } else {
    ecode = tcfdbecode(fdb);
    fprintf(stderr, "get error: %s\n", tcfdberrmsg(ecode));
  }

  /* traverse records */
  tcfdbiterinit(fdb);
  while((key = tcfdbiternext3(fdb)) != NULL){
    value = tcfdbget3(fdb, key);
    if(value){
      printf("%s:%s\n", key, value);
      free(value);
    }
    free(key);
  }

  /* close the database */
  if(!tcfdbclose(fdb)){
    ecode = tcfdbecode(fdb);
    fprintf(stderr, "close error: %s\n", tcfdberrmsg(ecode));
  }

  /* delete the object */
  tcfdbdel(fdb);

  return 0;
}
</pre>

<h3 id="tcfdbapi_cli">CLI</h3>

<p>To use the fixed-length database API easily, the commands `<code>tcftest</code>', `<code>tcfmttest</code>', and `<code>tcfmgr</code>' are provided.</p>

<p>The command `<code>tcftest</code>' is a utility for facility test and performance test.  This command is used in the following format.  `<var>path</var>' specifies the path of a database file.  `<var>rnum</var>' specifies the number of iterations.  `<var>width</var>' specifies the width of the value of each record.  `<var>limsiz</var>' specifies the limit size of the database file.</p>

<dl class="api">
<dt><code>tcftest write [-mt] [-nl|-nb] [-rnd] <var>path</var> <var>rnum</var> [<var>width</var> [<var>limsiz</var>]]</code></dt>
<dd>Store records with keys of 8 bytes.  They change as `00000001', `00000002'...</dd>
<dt><code>tcftest read [-mt] [-nl|-nb] [-wb] [-rnd] <var>path</var></code></dt>
<dd>Retrieve all records of the database above.</dd>
<dt><code>tcftest remove [-mt] [-nl|-nb] [-rnd] <var>path</var></code></dt>
<dd>Remove all records of the database above.</dd>
<dt><code>tcftest rcat [-mt] [-nl|-nb] [-pn <var>num</var>] [-dai|-dad|-rl] <var>path</var> <var>rnum</var> [<var>limsiz</var>]]</code></dt>
<dd>Store records with partway duplicated keys using concatenate mode.</dd>
<dt><code>tcftest misc [-mt] [-nl|-nb] <var>path</var> <var>rnum</var></code></dt>
<dd>Perform miscellaneous test of various operations.</dd>
<dt><code>tcftest wicked [-mt] [-nl|-nb] <var>path</var> <var>rnum</var></code></dt>
<dd>Perform updating operations selected at random.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-mt</code> : call the function `tcfdbsetmutex'.</li>
<li><code>-nl</code> : enable the option `FDBNOLCK'.</li>
<li><code>-nb</code> : enable the option `FDBLCKNB'.</li>
<li><code>-rnd</code> : select keys at random.</li>
<li><code>-wb</code> : use the function `tcfdbget4' instead of `tcfdbget2'.</li>
<li><code>-pn <var>num</var></code> : specify the number of patterns.</li>
<li><code>-dai</code> : use the function `tcfdbaddint' instead of `tcfdbputcat'.</li>
<li><code>-dad</code> : use the function `tcfdbadddouble' instead of `tcfdbputcat'.</li>
<li><code>-rl</code> : set the length of values at random.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<p>The command `<code>tcfmttest</code>' is a utility for facility test under multi-thread situation.  This command is used in the following format.  `<var>path</var>' specifies the path of a database file.  `<var>tnum</var>' specifies the number of running threads.  `<var>rnum</var>' specifies the number of iterations.  `<var>width</var>' specifies the width of the value of each record.  `<var>limsiz</var>' specifies the limit size of the database file.</p>

<dl class="api">
<dt><code>tcfmttest write [-nl|-nb] [-rnd] <var>path</var> <var>tnum</var> <var>rnum</var> [<var>width</var> [<var>limsiz</var>]]</code></dt>
<dd>Store records with keys of 8 bytes.  They change as `00000001', `00000002'...</dd>
<dt><code>tcfmttest read [-nl|-nb] [-wb] [-rnd] <var>path</var> <var>tnum</var></code></dt>
<dd>Retrieve all records of the database above.</dd>
<dt><code>tcfmttest remove [-nl|-nb] [-rnd] <var>path</var> <var>tnum</var></code></dt>
<dd>Remove all records of the database above.</dd>
<dt><code>tcfmttest wicked [-nl|-nb] [-nc] <var>path</var> <var>tnum</var> <var>rnum</var></code></dt>
<dd>Perform updating operations selected at random.</dd>
<dt><code>tcfmttest typical [-nl|-nb] [-nc] [-rr <var>num</var>] <var>path</var> <var>tnum</var> <var>rnum</var> [<var>width</var> [<var>limsiz</var>]]</code></dt>
<dd>Perform typical operations selected at random.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-nl</code> : enable the option `FDBNOLCK'.</li>
<li><code>-nb</code> : enable the option `FDBLCKNB'.</li>
<li><code>-rnd</code> : select keys at random.</li>
<li><code>-wb</code> : use the function `tcfdbget4' instead of `tcfdbget2'.</li>
<li><code>-nc</code> : omit the comparison test.</li>
<li><code>-rr <var>num</var></code> : specify the ratio of reading operation by percentage.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<p>The command `<code>tcfmgr</code>' is a utility for test and debugging of the fixed-length database API and its applications.  `<var>path</var>' specifies the path of a database file.  `<var>width</var>' specifies the width of the value of each record.  `<var>limsiz</var>' specifies the limit size of the database file.  `<var>key</var>' specifies the key of a record.  `<var>value</var>' specifies the value of a record.  `<var>file</var>' specifies the input file.</p>

<dl class="api">
<dt><code>tcfmgr create <var>path</var> [<var>width</var> [<var>limsiz</var>]]</code></dt>
<dd>Create a database file.</dd>
<dt><code>tcfmgr inform [-nl|-nb] <var>path</var></code></dt>
<dd>Print miscellaneous information to the standard output.</dd>
<dt><code>tcfmgr put [-nl|-nb] [-sx] [-dk|-dc|-dai|-dad] <var>path</var> <var>key</var> <var>value</var></code></dt>
<dd>Store a record.</dd>
<dt><code>tcfmgr out [-nl|-nb] [-sx] <var>path</var> <var>key</var></code></dt>
<dd>Remove a record.</dd>
<dt><code>tcfmgr get [-nl|-nb] [-sx] [-px] [-pz] <var>path</var> <var>key</var></code></dt>
<dd>Print the value of a record.</dd>
<dt><code>tcfmgr list [-nl|-nb] [-m <var>num</var>] [-pv] [-px] [-rb <var>lkey</var> <var>ukey</var>] [-ri <var>str</var>] <var>path</var></code></dt>
<dd>Print keys of all records, separated by line feeds.</dd>
<dt><code>tcfmgr optimize [-nl|-nb] <var>path</var> [<var>width</var> [<var>limsiz</var>]]</code></dt>
<dd>Optimize a database file.</dd>
<dt><code>tcfmgr importtsv [-nl|-nb] [-sc] <var>path</var> [<var>file</var>]</code></dt>
<dd>Store records of TSV in each line of a file.</dd>
<dt><code>tcfmgr version</code></dt>
<dd>Print the version information of Tokyo Cabinet.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-nl</code> : enable the option `FDBNOLCK'.</li>
<li><code>-nb</code> : enable the option `FDBLCKNB'.</li>
<li><code>-sx</code> : the input data is evaluated as a hexadecimal data string.</li>
<li><code>-dk</code> : use the function `tcfdbputkeep' instead of `tcfdbput'.</li>
<li><code>-dc</code> : use the function `tcfdbputcat' instead of `tcfdbput'.</li>
<li><code>-dai</code> : use the function `tcfdbaddint' instead of `tcfdbput'.</li>
<li><code>-dad</code> : use the function `tcfdbadddouble' instead of `tcfdbput'.</li>
<li><code>-px</code> : the output data is converted into a hexadecimal data string.</li>
<li><code>-pz</code> : do not append line feed at the end of the output.</li>
<li><code>-m <var>num</var></code> : specify the maximum number of the output.</li>
<li><code>-pv</code> : print values of records also.</li>
<li><code>-rb <var>lkey</var> <var>ukey</var></code> : specify the range of keys.</li>
<li><code>-ri <var>str</var></code> : specify the interval notation of keys.</li>
<li><code>-sc</code> : normalize keys as lower cases.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<hr />

<h2 id="tctdbapi">The Table Database API</h2>

<p>Table database is a file containing records composed of the primary keys and arbitrary columns and is handled with the table database API.  See `<code>tctdb.h</code>' for the entire specification.</p>

<h3 id="tctdbapi_description">Description</h3>

<p>To use the table database API, include `<code>tcutil.h</code>', `<code>tctdb.h</code>', and related standard header files.  Usually, write the following description near the front of a source file.</p>

<dl>
<dt><code>#include &lt;tcutil.h&gt;</code></dt>
<dt><code>#include &lt;tctdb.h&gt;</code></dt>
<dt><code>#include &lt;stdlib.h&gt;</code></dt>
<dt><code>#include &lt;stdbool.h&gt;</code></dt>
<dt><code>#include &lt;stdint.h&gt;</code></dt>
</dl>

<p>Objects whose type is pointer to `<code>TCTDB</code>' are used to handle table databases.  A table database object is created with the function `<code>tctdbnew</code>' and is deleted with the function `<code>tctdbdel</code>'.  To avoid memory leak, it is important to delete every object when it is no longer in use.</p>

<p>Before operations to store or retrieve records, it is necessary to open a database file and connect the table database object to it.  The function `<code>tctdbopen</code>' is used to open a database file and the function `<code>tctdbclose</code>' is used to close the database file.  To avoid data missing or corruption, it is important to close every database file when it is no longer in use.  It is forbidden for multible database objects in a process to open the same database at the same time.</p>

<h3 id="tctdbapi_api">API</h3>

<p>The function `tctdberrmsg' is used in order to get the message string corresponding to an error code.</p>

<dl class="api">
<dt><code>const char *tctdberrmsg(int <var>ecode</var>);</code></dt>
<dd>`<var>ecode</var>' specifies the error code.</dd>
<dd>The return value is the message string of the error code.</dd>
</dl>

<p>The function `tctdbnew' is used in order to create a table database object.</p>

<dl class="api">
<dt><code>TCTDB *tctdbnew(void);</code></dt>
<dd>The return value is the new table database object.</dd>
</dl>

<p>The function `tctdbdel' is used in order to delete a table database object.</p>

<dl class="api">
<dt><code>void tctdbdel(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>If the database is not closed, it is closed implicitly.  Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tctdbecode' is used in order to get the last happened error code of a table database object.</p>

<dl class="api">
<dt><code>int tctdbecode(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>The return value is the last happened error code.</dd>
<dd>The following error codes are defined: `TCESUCCESS' for success, `TCETHREAD' for threading error, `TCEINVALID' for invalid operation, `TCENOFILE' for file not found, `TCENOPERM' for no permission, `TCEMETA' for invalid meta data, `TCERHEAD' for invalid record header, `TCEOPEN' for open error, `TCECLOSE' for close error, `TCETRUNC' for trunc error, `TCESYNC' for sync error, `TCESTAT' for stat error, `TCESEEK' for seek error, `TCEREAD' for read error, `TCEWRITE' for write error, `TCEMMAP' for mmap error, `TCELOCK' for lock error, `TCEUNLINK' for unlink error, `TCERENAME' for rename error, `TCEMKDIR' for mkdir error, `TCERMDIR' for rmdir error, `TCEKEEP' for existing record, `TCENOREC' for no record found, and `TCEMISC' for miscellaneous error.</dd>
</dl>

<p>The function `tctdbsetmutex' is used in order to set mutual exclusion control of a table database object for threading.</p>

<dl class="api">
<dt><code>bool tctdbsetmutex(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object which is not opened.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the mutual exclusion control is needed if the object is shared by plural threads and this function should be called before the database is opened.</dd>
</dl>

<p>The function `tctdbtune' is used in order to set the tuning parameters of a table database object.</p>

<dl class="api">
<dt><code>bool tctdbtune(TCTDB *<var>tdb</var>, int64_t <var>bnum</var>, int8_t <var>apow</var>, int8_t <var>fpow</var>, uint8_t <var>opts</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object which is not opened.</dd>
<dd>`<var>bnum</var>' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is 131071.  Suggested size of the bucket array is about from 0.5 to 4 times of the number of all records to be stored.</dd>
<dd>`<var>apow</var>' specifies the size of record alignment by power of 2.  If it is negative, the default value is specified.  The default value is 4 standing for 2^4=16.</dd>
<dd>`<var>fpow</var>' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the default value is specified.  The default value is 10 standing for 2^10=1024.</dd>
<dd>`<var>opts</var>' specifies options by bitwise-or: `TDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64-bit bucket array, `TDBTDEFLATE' specifies that each record is compressed with Deflate encoding, `TDBTBZIP' specifies that each record is compressed with BZIP2 encoding, `TDBTTCBS' specifies that each record is compressed with TCBS encoding.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the tuning parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tctdbsetcache' is set the caching parameters of a table database object.</p>

<dl class="api">
<dt><code>bool tctdbsetcache(TCTDB *<var>tdb</var>, int32_t <var>rcnum</var>, int32_t <var>lcnum</var>, int32_t <var>ncnum</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object which is not opened.</dd>
<dd>`<var>rcnum</var>' specifies the maximum number of records to be cached.  If it is not more than 0, the record cache is disabled.  It is disabled by default.</dd>
<dd>`<var>lcnum</var>' specifies the maximum number of leaf nodes to be cached.  If it is not more than 0, the default value is specified.  The default value is 4096.</dd>
<dd>`<var>ncnum</var>' specifies the maximum number of non-leaf nodes to be cached.  If it is not more than 0, the default value is specified.  The default value is 512.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the caching parameters should be set before the database is opened.  Leaf nodes and non-leaf nodes are used in column indices.</dd>
</dl>

<p>The function `tctdbsetxmsiz' is used in order to set the size of the extra mapped memory of a table database object.</p>

<dl class="api">
<dt><code>bool tctdbsetxmsiz(TCTDB *<var>tdb</var>, int64_t <var>xmsiz</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object which is not opened.</dd>
<dd>`<var>xmsiz</var>' specifies the size of the extra mapped memory.  If it is not more than 0, the extra mapped memory is disabled.  The default size is 67108864.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the mapping parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tctdbsetdfunit' is used in order to set the unit step number of auto defragmentation of a table database object.</p>

<dl class="api">
<dt><code>bool tctdbsetdfunit(TCTDB *<var>tdb</var>, int32_t <var>dfunit</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object which is not opened.</dd>
<dd>`<var>dfunit</var>' specifie the unit step number.  If it is not more than 0, the auto defragmentation is disabled.  It is disabled by default.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the defragmentation parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tctdbopen' is used in order to open a database file and connect a table database object.</p>

<dl class="api">
<dt><code>bool tctdbopen(TCTDB *<var>tdb</var>, const char *<var>path</var>, int <var>omode</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object which is not opened.</dd>
<dd>`<var>path</var>' specifies the path of the database file.</dd>
<dd>`<var>omode</var>' specifies the connection mode: `TDBOWRITER' as a writer, `TDBOREADER' as a reader.  If the mode is `TDBOWRITER', the following may be added by bitwise-or: `TDBOCREAT', which means it creates a new database if not exist, `TDBOTRUNC', which means it creates a new database regardless if one exists, `TDBOTSYNC', which means every transaction synchronizes updated contents with the device.  Both of `TDBOREADER' and `TDBOWRITER' can be added to by bitwise-or: `TDBONOLCK', which means it opens the database file without file locking, or `TDBOLCKNB', which means locking is performed without blocking.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tctdbclose' is used in order to close a table database object.</p>

<dl class="api">
<dt><code>bool tctdbclose(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update of a database is assured to be written when the database is closed.  If a writer opens a database but does not close it appropriately, the database will be broken.</dd>
</dl>

<p>The function `tctdbput' is used in order to store a record into a table database object.</p>

<dl class="api">
<dt><code>bool tctdbput(TCTDB *<var>tdb</var>, const void *<var>pkbuf</var>, int <var>pksiz</var>, TCMAP *<var>cols</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>pkbuf</var>' specifies the pointer to the region of the primary key.</dd>
<dd>`<var>pksiz</var>' specifies the size of the region of the primary key.</dd>
<dd>`<var>cols</var>' specifies a map object containing columns.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tctdbput2' is used in order to store a string record into a table database object with a zero separated column string.</p>

<dl class="api">
<dt><code>bool tctdbput2(TCTDB *<var>tdb</var>, const void *<var>pkbuf</var>, int <var>pksiz</var>, const void *<var>cbuf</var>, int <var>csiz</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>pkbuf</var>' specifies the pointer to the region of the primary key.</dd>
<dd>`<var>pksiz</var>' specifies the size of the region of the primary key.</dd>
<dd>`<var>cbuf</var>' specifies the pointer to the region of the zero separated column string where the name and the value of each column are situated one after the other.</dd>
<dd>`<var>csiz</var>' specifies the size of the region of the column string.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tctdbput3' is used in order to store a string record into a table database object with a tab separated column string.</p>

<dl class="api">
<dt><code>bool tctdbput3(TCTDB *<var>tdb</var>, const char *<var>pkstr</var>, const char *<var>cstr</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>pkstr</var>' specifies the string of the primary key.</dd>
<dd>`<var>cstr</var>' specifies the string of the the tab separated column string where the name and the value of each column are situated one after the other.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tctdbputkeep' is used in order to store a new record into a table database object.</p>

<dl class="api">
<dt><code>bool tctdbputkeep(TCTDB *<var>tdb</var>, const void *<var>pkbuf</var>, int <var>pksiz</var>, TCMAP *<var>cols</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>pkbuf</var>' specifies the pointer to the region of the primary key.</dd>
<dd>`<var>pksiz</var>' specifies the size of the region of the primary key.</dd>
<dd>`<var>cols</var>' specifies a map object containing columns.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tctdbputkeep2' is used in order to store a new string record into a table database object with a zero separated column string.</p>

<dl class="api">
<dt><code>bool tctdbputkeep2(TCTDB *<var>tdb</var>, const void *<var>pkbuf</var>, int <var>pksiz</var>, const void *<var>cbuf</var>, int <var>csiz</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>pkbuf</var>' specifies the pointer to the region of the primary key.</dd>
<dd>`<var>pksiz</var>' specifies the size of the region of the primary key.</dd>
<dd>`<var>cbuf</var>' specifies the pointer to the region of the zero separated column string where the name and the value of each column are situated one after the other.</dd>
<dd>`<var>csiz</var>' specifies the size of the region of the column string.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tctdbputkeep3' is used in order to store a new string record into a table database object with a tab separated column string.</p>

<dl class="api">
<dt><code>bool tctdbputkeep3(TCTDB *<var>tdb</var>, const char *<var>pkstr</var>, const char *<var>cstr</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>pkstr</var>' specifies the string of the primary key.</dd>
<dd>`<var>cstr</var>' specifies the string of the the tab separated column string where the name and the value of each column are situated one after the other.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tctdbputcat' is used in order to concatenate columns of the existing record in a table database object.</p>

<dl class="api">
<dt><code>bool tctdbputcat(TCTDB *<var>tdb</var>, const void *<var>pkbuf</var>, int <var>pksiz</var>, TCMAP *<var>cols</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>pkbuf</var>' specifies the pointer to the region of the primary key.</dd>
<dd>`<var>pksiz</var>' specifies the size of the region of the primary key.</dd>
<dd>`<var>cols</var>' specifies a map object containing columns.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tctdbputcat2' is used in order to concatenate columns in a table database object with a zero separated column string.</p>

<dl class="api">
<dt><code>bool tctdbputcat2(TCTDB *<var>tdb</var>, const void *<var>pkbuf</var>, int <var>pksiz</var>, const void *<var>cbuf</var>, int <var>csiz</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>pkbuf</var>' specifies the pointer to the region of the primary key.</dd>
<dd>`<var>pksiz</var>' specifies the size of the region of the primary key.</dd>
<dd>`<var>cbuf</var>' specifies the pointer to the region of the zero separated column string where the name and the value of each column are situated one after the other.</dd>
<dd>`<var>csiz</var>' specifies the size of the region of the column string.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tctdbputcat3' is used in order to concatenate columns in a table database object with with a tab separated column string.</p>

<dl class="api">
<dt><code>bool tctdbputcat3(TCTDB *<var>tdb</var>, const char *<var>pkstr</var>, const char *<var>cstr</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>pkstr</var>' specifies the string of the primary key.</dd>
<dd>`<var>cstr</var>' specifies the string of the the tab separated column string where the name and the value of each column are situated one after the other.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tctdbout' is used in order to remove a record of a table database object.</p>

<dl class="api">
<dt><code>bool tctdbout(TCTDB *<var>tdb</var>, const void *<var>pkbuf</var>, int <var>pksiz</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>pkbuf</var>' specifies the pointer to the region of the primary key.</dd>
<dd>`<var>pksiz</var>' specifies the size of the region of the primary key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tctdbout2' is used in order to remove a string record of a table database object.</p>

<dl class="api">
<dt><code>bool tctdbout2(TCTDB *<var>tdb</var>, const char *<var>pkstr</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>pkstr</var>' specifies the string of the primary key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tctdbget' is used in order to retrieve a record in a table database object.</p>

<dl class="api">
<dt><code>TCMAP *tctdbget(TCTDB *<var>tdb</var>, const void *<var>pkbuf</var>, int <var>pksiz</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>`<var>pkbuf</var>' specifies the pointer to the region of the primary key.</dd>
<dd>`<var>pksiz</var>' specifies the size of the region of the primary key.</dd>
<dd>If successful, the return value is a map object of the columns of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because the object of the return value is created with the function `tcmapnew', it should be deleted with the function `tcmapdel' when it is no longer in use.</dd>
</dl>

<p>The function `tctdbget2' is used in order to retrieve a record in a table database object as a zero separated column string.</p>

<dl class="api">
<dt><code>char *tctdbget2(TCTDB *<var>tdb</var>, const void *<var>pkbuf</var>, int <var>pksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>`<var>pkbuf</var>' specifies the pointer to the region of the primary key.</dd>
<dd>`<var>pksiz</var>' specifies the size of the region of the primary key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the column string of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tctdbget3' is used in order to retrieve a string record in a table database object as a tab separated column string.</p>

<dl class="api">
<dt><code>char *tctdbget3(TCTDB *<var>tdb</var>, const char *<var>pkstr</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>`<var>pkstr</var>' specifies the string of the primary key.</dd>
<dd>If successful, the return value is the tab separated column string of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tctdbvsiz' is used in order to get the size of the value of a record in a table database object.</p>

<dl class="api">
<dt><code>int tctdbvsiz(TCTDB *<var>tdb</var>, const void *<var>pkbuf</var>, int <var>pksiz</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the primary key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the primary key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tctdbvsiz2' is used in order to get the size of the value of a string record in a table database object.</p>

<dl class="api">
<dt><code>int tctdbvsiz2(TCTDB *<var>tdb</var>, const char *<var>pkstr</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the primary key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tctdbiterinit' is used in order to initialize the iterator of a table database object.</p>

<dl class="api">
<dt><code>bool tctdbiterinit(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The iterator is used in order to access the primary key of every record stored in a database.</dd>
</dl>

<p>The function `tctdbiternext' is used in order to get the next primary key of the iterator of a table database object.</p>

<dl class="api">
<dt><code>void *tctdbiternext(TCTDB *<var>tdb</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the next primary key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  It is allowed to update or remove records whose keys are fetched while the iteration.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.</dd>
</dl>

<p>The function `tctdbiternext2' is used in order to get the next primary key string of the iterator of a table database object.</p>

<dl class="api">
<dt><code>char *tctdbiternext2(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>If successful, the return value is the string of the next primary key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.</dd>
</dl>

<p>The function `tctdbiternext3' is used in order to get the columns of the next record of the iterator of a table database object.</p>

<dl class="api">
<dt><code>TCMAP *tctdbiternext3(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>If successful, the return value is a map object of the columns of the next record, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.  The primary key is added into the map as a column of an empty string key.</dd>
<dd>Because the object of the return value is created with the function `tcmapnew', it should be deleted with the function `tcmapdel' when it is no longer in use.  It is possible to access every record by iteration of calling this function.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.</dd>
</dl>

<p>The function `tctdbfwmkeys' is used in order to get forward matching primary keys in a table database object.</p>

<dl class="api">
<dt><code>TCLIST *tctdbfwmkeys(TCTDB *<var>tdb</var>, const void *<var>pbuf</var>, int <var>psiz</var>, int <var>max</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>`<var>pbuf</var>' specifies the pointer to the region of the prefix.</dd>
<dd>`<var>psiz</var>' specifies the size of the region of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</dd>
</dl>

<p>The function `tctdbfwmkeys2' is used in order to get forward matching string primary keys in a table database object.</p>

<dl class="api">
<dt><code>TCLIST *tctdbfwmkeys2(TCTDB *<var>tdb</var>, const char *<var>pstr</var>, int <var>max</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>`<var>pstr</var>' specifies the string of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</dd>
</dl>

<p>The function `tctdbaddint' is used in order to add an integer to a column of a record in a table database object.</p>

<dl class="api">
<dt><code>int tctdbaddint(TCTDB *<var>tdb</var>, const void *<var>pkbuf</var>, int <var>pksiz</var>, int <var>num</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the primary key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the primary key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>If successful, the return value is the summation value, else, it is `INT_MIN'.</dd>
<dd>The additional value is stored as a decimal string value of a column whose name is "_num".  If no record corresponds, a new record with the additional value is stored.</dd>
</dl>

<p>The function `tctdbadddouble' is used in order to add a real number to a column of a record in a table database object.</p>

<dl class="api">
<dt><code>double tctdbadddouble(TCTDB *<var>tdb</var>, const void *<var>pkbuf</var>, int <var>pksiz</var>, double <var>num</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the primary key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the primary key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>If successful, the return value is the summation value, else, it is Not-a-Number.</dd>
<dd>The additional value is stored as a decimal string value of a column whose name is "_num".  If no record corresponds, a new record with the additional value is stored.</dd>
</dl>

<p>The function `tctdbsync' is used in order to synchronize updated contents of a table database object with the file and the device.</p>

<dl class="api">
<dt><code>bool tctdbsync(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function is useful when another process connects to the same database file.</dd>
</dl>

<p>The function `tctdboptimize' is used in order to optimize the file of a table database object.</p>

<dl class="api">
<dt><code>bool tctdboptimize(TCTDB *<var>tdb</var>, int64_t <var>bnum</var>, int8_t <var>apow</var>, int8_t <var>fpow</var>, uint8_t <var>opts</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>bnum</var>' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is two times of the number of records.</dd>
<dd>`<var>apow</var>' specifies the size of record alignment by power of 2.  If it is negative, the current setting is not changed.</dd>
<dd>`<var>fpow</var>' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the current setting is not changed.</dd>
<dd>`<var>opts</var>' specifies options by bitwise-or: `TDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64-bit bucket array, `TDBTDEFLATE' specifies that each record is compressed with Deflate encoding, `TDBTBZIP' specifies that each record is compressed with BZIP2 encoding, `TDBTTCBS' specifies that each record is compressed with TCBS encoding.  If it is `UINT8_MAX', the current setting is not changed.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function is useful to reduce the size of the database file with data fragmentation by successive updating.</dd>
</dl>

<p>The function `tctdbvanish' is used in order to remove all records of a table database object.</p>

<dl class="api">
<dt><code>bool tctdbvanish(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tctdbcopy' is used in order to copy the database file of a table database object.</p>

<dl class="api">
<dt><code>bool tctdbcopy(TCTDB *<var>tdb</var>, const char *<var>path</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>`<var>path</var>' specifies the path of the destination file.  If it begins with `@', the trailing substring is executed as a command line.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if the executed command returns non-zero code.</dd>
<dd>The database file is assured to be kept synchronized and not modified while the copying or executing operation is in progress.  So, this function is useful to create a backup file of the database file.</dd>
</dl>

<p>The function `tctdbtranbegin' is used in order to begin the transaction of a table database object.</p>

<dl class="api">
<dt><code>bool tctdbtranbegin(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The database is locked by the thread while the transaction so that only one transaction can be activated with a database object at the same time.  Thus, the serializable isolation level is assumed if every database operation is performed in the transaction.  Because all pages are cached on memory while the transaction, the amount of referred records is limited by the memory capacity.  If the database is closed during transaction, the transaction is aborted implicitly.</dd>
</dl>

<p>The function `tctdbtrancommit' is used in order to commit the transaction of a table database object.</p>

<dl class="api">
<dt><code>bool tctdbtrancommit(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update in the transaction is fixed when it is committed successfully.</dd>
</dl>

<p>The function `tctdbtranabort' is used in order to abort the transaction of a table database object.</p>

<dl class="api">
<dt><code>bool tctdbtranabort(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update in the transaction is discarded when it is aborted.  The state of the database is rollbacked to before transaction.</dd>
</dl>

<p>The function `tctdbpath' is used in order to get the file path of a table database object.</p>

<dl class="api">
<dt><code>const char *tctdbpath(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>The return value is the path of the database file or `NULL' if the object does not connect to any database file.</dd>
</dl>

<p>The function `tctdbrnum' is used in order to get the number of records ccccof a table database object.</p>

<dl class="api">
<dt><code>uint64_t tctdbrnum(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>The return value is the number of records or 0 if the object does not connect to any database file.</dd>
</dl>

<p>The function `tctdbfsiz' is used in order to get the size of the database file of a table database object.</p>

<dl class="api">
<dt><code>uint64_t tctdbfsiz(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>The return value is the size of the database file or 0 if the object does not connect to any database file.</dd>
</dl>

<p>The function `tctdbsetindex' is used in order to set a column index to a table database object.</p>

<dl class="api">
<dt><code>bool tctdbsetindex(TCTDB *<var>tdb</var>, const char *<var>name</var>, int <var>type</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>name</var>' specifies the name of a column.  If the name of an existing index is specified, the index is rebuilt.  An empty string means the primary key.</dd>
<dd>`<var>type</var>' specifies the index type: `TDBITLEXICAL' for lexical string, `TDBITDECIMAL' for decimal string, `TDBITTOKEN' for token inverted index, `TDBITQGRAM' for q-gram inverted index.  If it is `TDBITOPT', the index is optimized.  If it is `TDBITVOID', the index is removed.  If `TDBITKEEP' is added by bitwise-or and the index exists, this function merely returns failure.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the setting indices should be set after the database is opened.</dd>
</dl>

<p>The function `tctdbgenuid' is used in order to generate a unique ID number of a table database object.</p>

<dl class="api">
<dt><code>int64_t tctdbgenuid(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>The return value is the new unique ID number or -1 on failure.</dd>
</dl>

<p>The function `tctdbqrynew' is used in order to create a query object.</p>

<dl class="api">
<dt><code>TDBQRY *tctdbqrynew(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>The return value is the new query object.</dd>
</dl>

<p>The function `tctdbqrydel' is used in order to delete a query object.</p>

<dl class="api">
<dt><code>void tctdbqrydel(TDBQRY *<var>qry</var>);</code></dt>
<dd>`<var>qry</var>' specifies the query object.</dd>
</dl>

<p>The function `tctdbqryaddcond' is used in order to add a narrowing condition to a query object.</p>

<dl class="api">
<dt><code>void tctdbqryaddcond(TDBQRY *<var>qry</var>, const char *<var>name</var>, int <var>op</var>, const char *<var>expr</var>);</code></dt>
<dd>`<var>qry</var>' specifies the query object.</dd>
<dd>`<var>name</var>' specifies the name of a column.  An empty string means the primary key.</dd>
<dd>`<var>op</var>' specifies an operation type: `TDBQCSTREQ' for string which is equal to the expression, `TDBQCSTRINC' for string which is included in the expression, `TDBQCSTRBW' for string which begins with the expression, `TDBQCSTREW' for string which ends with the expression, `TDBQCSTRAND' for string which includes all tokens in the expression, `TDBQCSTROR' for string which includes at least one token in the expression, `TDBQCSTROREQ' for string which is equal to at least one token in the expression, `TDBQCSTRRX' for string which matches regular expressions of the expression, `TDBQCNUMEQ' for number which is equal to the expression, `TDBQCNUMGT' for number which is greater than the expression, `TDBQCNUMGE' for number which is greater than or equal to the expression, `TDBQCNUMLT' for number which is less than the expression, `TDBQCNUMLE' for number which is less than or equal to the expression, `TDBQCNUMBT' for number which is between two tokens of the expression, `TDBQCNUMOREQ' for number which is equal to at least one token in the expression, `TDBQCFTSPH' for full-text search with the phrase of the expression, `TDBQCFTSAND' for full-text search with all tokens in the expression, `TDBQCFTSOR' for full-text search with at least one token in the expression, `TDBQCFTSEX' for full-text search with the compound expression.  All operations can be flagged by bitwise-or: `TDBQCNEGATE' for negation, `TDBQCNOIDX' for using no index.</dd>
<dd>`<var>expr</var>' specifies an operand exression.</dd>
</dl>

<p>The function `tctdbqrysetorder' is used in order to set the order of a query object.</p>

<dl class="api">
<dt><code>void tctdbqrysetorder(TDBQRY *<var>qry</var>, const char *<var>name</var>, int <var>type</var>);</code></dt>
<dd>`<var>qry</var>' specifies the query object.</dd>
<dd>`<var>name</var>' specifies the name of a column.  An empty string means the primary key.</dd>
<dd>`<var>type</var>' specifies the order type: `TDBQOSTRASC' for string ascending, `TDBQOSTRDESC' for string descending, `TDBQONUMASC' for number ascending, `TDBQONUMDESC' for number descending.</dd>
</dl>

<p>The function `tctdbqrysetlimit' is used in order to set the limit number of records of the result of a query object.</p>

<dl class="api">
<dt><code>void tctdbqrysetlimit(TDBQRY *<var>qry</var>, int <var>max</var>, int <var>skip</var>);</code></dt>
<dd>`<var>qry</var>' specifies the query object.</dd>
<dd>`<var>max</var>' specifies the maximum number of records of the result.  If it is negative, no limit is specified.</dd>
<dd>`<var>skip</var>' specifies the number of skipped records of the result.  If it is not more than 0, no record is skipped.</dd>
</dl>

<p>The function `tctdbqrysearch' is used in order to execute the search of a query object.</p>

<dl class="api">
<dt><code>TCLIST *tctdbqrysearch(TDBQRY *<var>qry</var>);</code></dt>
<dd>`<var>qry</var>' specifies the query object.</dd>
<dd>The return value is a list object of the primary keys of the corresponding records.  This function does never fail.  It returns an empty list even if no record corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tctdbqrysearchout' is used in order to remove each record corresponding to a query object.</p>

<dl class="api">
<dt><code>bool tctdbqrysearchout(TDBQRY *<var>qry</var>);</code></dt>
<dd>`<var>qry</var>' specifies the query object of the database connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tctdbqryproc' is used in order to process each record corresponding to a query object.</p>

<dl class="api">
<dt><code>bool tctdbqryproc(TDBQRY *<var>qry</var>, TDBQRYPROC <var>proc</var>, void *<var>op</var>);</code></dt>
<dd>`<var>qry</var>' specifies the query object of the database connected as a writer.</dd>
<dd>`<var>proc</var>' specifies the pointer to the iterator function called for each record.  It receives four parameters.  The first parameter is the pointer to the region of the primary key.  The second parameter is the size of the region of the primary key.  The third parameter is a map object containing columns.  The fourth parameter is the pointer to the optional opaque object.  It returns flags of the post treatment by bitwise-or: `TDBQPPUT' to modify the record, `TDBQPOUT' to remove the record, `TDBQPSTOP' to stop the iteration.</dd>
<dd>`<var>op</var>' specifies an arbitrary pointer to be given as a parameter of the iterator function.  If it is not needed, `NULL' can be specified.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tctdbqryhint' is used in order to get the hint string of a query object.</p>

<dl class="api">
<dt><code>const char *tctdbqryhint(TDBQRY *<var>qry</var>);</code></dt>
<dd>`<var>qry</var>' specifies the query object.</dd>
<dd>The return value is the hint string.</dd>
</dl>

<p>The function `tctdbmetasearch' is used in order to retrieve records with multiple query objects and get the set of the result.</p>

<dl class="api">
<dt><code>TCLIST *tctdbmetasearch(TDBQRY **<var>qrys</var>, int <var>num</var>, int <var>type</var>);</code></dt>
<dd>`<var>qrys</var>' specifies an array of the query objects.</dd>
<dd>`<var>num</var>' specifies the number of elements of the array.</dd>
<dd>`<var>type</var>' specifies a set operation type: `TDBMSUNION' for the union set, `TDBMSISECT' for the intersection set, `TDBMSDIFF' for the difference set.</dd>
<dd>The return value is a list object of the primary keys of the corresponding records.  This function does never fail.  It returns an empty list even if no record corresponds.</dd>
<dd>If the first query object has the order setting, the result array is sorted by the order.  Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<h3 id="tctdbapi_example">Example Code</h3>

<p>The following code is an example to use a table database.</p>

<pre>#include &lt;tcutil.h&gt;
#include &lt;tctdb.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;

int main(int argc, char **argv){
  TCTDB *tdb;
  int ecode, pksiz, i, rsiz;
  char pkbuf[256];
  const char *rbuf, *name;
  TCMAP *cols;
  TDBQRY *qry;
  TCLIST *res;

  /* create the object */
  tdb = tctdbnew();

  /* open the database */
  if(!tctdbopen(tdb, "casket.tct", TDBOWRITER | TDBOCREAT)){
    ecode = tctdbecode(tdb);
    fprintf(stderr, "open error: %s\n", tctdberrmsg(ecode));
  }

  /* store a record */
  pksiz = sprintf(pkbuf, "%ld", (long)tctdbgenuid(tdb));
  cols = tcmapnew3("name", "mikio", "age", "30", "lang", "ja,en,c", NULL);
  if(!tctdbput(tdb, pkbuf, pksiz, cols)){
    ecode = tctdbecode(tdb);
    fprintf(stderr, "put error: %s\n", tctdberrmsg(ecode));
  }
  tcmapdel(cols);

  /* store a record in a naive way */
  pksiz = sprintf(pkbuf, "12345");
  cols = tcmapnew();
  tcmapput2(cols, "name", "falcon");
  tcmapput2(cols, "age", "31");
  tcmapput2(cols, "lang", "ja");
  if(!tctdbput(tdb, pkbuf, pksiz, cols)){
    ecode = tctdbecode(tdb);
    fprintf(stderr, "put error: %s\n", tctdberrmsg(ecode));
  }
  tcmapdel(cols);

  /* store a record with a TSV string */
  if(!tctdbput3(tdb, "abcde", "name\tjoker\tage\t19\tlang\ten,es")){
    ecode = tctdbecode(tdb);
    fprintf(stderr, "put error: %s\n", tctdberrmsg(ecode));
  }

  /* search for records */
  qry = tctdbqrynew(tdb);
  tctdbqryaddcond(qry, "age", TDBQCNUMGE, "20");
  tctdbqryaddcond(qry, "lang", TDBQCSTROR, "ja,en");
  tctdbqrysetorder(qry, "name", TDBQOSTRASC);
  tctdbqrysetlimit(qry, 10, 0);
  res = tctdbqrysearch(qry);
  for(i = 0; i &lt; tclistnum(res); i++){
    rbuf = tclistval(res, i, &amp;rsiz);
    cols = tctdbget(tdb, rbuf, rsiz);
    if(cols){
      printf("%s", rbuf);
      tcmapiterinit(cols);
      while((name = tcmapiternext2(cols)) != NULL){
        printf("\t%s\t%s", name, tcmapget2(cols, name));
      }
      printf("\n");
      tcmapdel(cols);
    }
  }
  tclistdel(res);
  tctdbqrydel(qry);

  /* close the database */
  if(!tctdbclose(tdb)){
    ecode = tctdbecode(tdb);
    fprintf(stderr, "close error: %s\n", tctdberrmsg(ecode));
  }

  /* delete the object */
  tctdbdel(tdb);

  return 0;
}
</pre>

<h3 id="tctdbapi_cli">CLI</h3>

<p>To use the table database API easily, the commands `<code>tcttest</code>', `<code>tctmttest</code>', and `<code>tctmgr</code>' are provided.</p>

<p>The command `<code>tcttest</code>' is a utility for facility test and performance test.  This command is used in the following format.  `<var>path</var>' specifies the path of a database file.  `<var>rnum</var>' specifies the number of iterations.  `<var>bnum</var>' specifies the number of buckets.  `<var>apow</var>' specifies the power of the alignment.  `<var>fpow</var>' specifies the power of the free block pool.</p>

<dl class="api">
<dt><code>tcttest write [-mt] [-tl] [-td|-tb|-tt|-tx] [-rc <var>num</var>] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-ip] [-is] [-in] [-it] [-if] [-ix] [-nl|-nb] [-rnd] <var>path</var> <var>rnum</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>Store records with columns "str", "num", "type", and "flag".</dd>
<dt><code>tcttest read [-mt] [-rc <var>num</var>] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-rnd] <var>path</var></code></dt>
<dd>Retrieve all records of the database above.</dd>
<dt><code>tcttest remove [-mt] [-rc <var>num</var>] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-rnd] <var>path</var></code></dt>
<dd>Remove all records of the database above.</dd>
<dt><code>tcttest rcat [-mt] [-tl] [-td|-tb|-tt|-tx] [-rc <var>num</var>] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-ip] [-is] [-in] [-it] [-if] [-ix] [-nl|-nb] [-pn <var>num</var>] [-dai|-dad|-rl|-ru] <var>path</var> <var>rnum</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>Store records with partway duplicated keys using concatenate mode.</dd>
<dt><code>tcttest misc [-mt] [-tl] [-td|-tb|-tt|-tx] [-nl|-nb] <var>path</var> <var>rnum</var></code></dt>
<dd>Perform miscellaneous test of various operations.</dd>
<dt><code>tcttest wicked [-mt] [-tl] [-td|-tb|-tt|-tx] [-nl|-nb] <var>path</var> <var>rnum</var></code></dt>
<dd>Perform updating operations selected at random.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-mt</code> : call the function `tctdbsetmutex'.</li>
<li><code>-tl</code> : enable the option `TDBTLARGE'.</li>
<li><code>-td</code> : enable the option `TDBTDEFLATE'.</li>
<li><code>-tb</code> : enable the option `TDBTBZIP'.</li>
<li><code>-tt</code> : enable the option `TDBTTCBS'.</li>
<li><code>-tx</code> : enable the option `TDBTEXCODEC'.</li>
<li><code>-rc <var>num</var></code> : specify the number of cached records.</li>
<li><code>-lc <var>num</var></code> : specify the number of cached leaf pages.</li>
<li><code>-nc <var>num</var></code> : specify the number of cached non-leaf pages.</li>
<li><code>-xm <var>num</var></code> : specify the size of the extra mapped memory.</li>
<li><code>-df <var>num</var></code> : specify the unit step number of auto defragmentation.</li>
<li><code>-ip</code> : create the number index for the primary key.</li>
<li><code>-is</code> : create the string index for the column "str".</li>
<li><code>-in</code> : create the number index for the column "num".</li>
<li><code>-it</code> : create the string index for the column "type".</li>
<li><code>-if</code> : create the token inverted index for the column "flag".</li>
<li><code>-ix</code> : create the q-gram inverted index for the column "text".</li>
<li><code>-nl</code> : enable the option `TDBNOLCK'.</li>
<li><code>-nb</code> : enable the option `TDBLCKNB'.</li>
<li><code>-rnd</code> : select keys at random.</li>
<li><code>-pn <var>num</var></code> : specify the number of patterns.</li>
<li><code>-dai</code> : use the function `tctdbaddint' instead of `tctdbputcat'.</li>
<li><code>-dad</code> : use the function `tctdbadddouble' instead of `tctdbputcat'.</li>
<li><code>-rl</code> : set the length of values at random.</li>
<li><code>-ru</code> : select update operations at random.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<p>The command `<code>tctmttest</code>' is a utility for facility test under multi-thread situation.  This command is used in the following format.  `<var>path</var>' specifies the path of a database file.  `<var>tnum</var>' specifies the number of running threads.  `<var>rnum</var>' specifies the number of iterations.  `<var>bnum</var>' specifies the number of buckets.  `<var>apow</var>' specifies the power of the alignment.  `<var>fpow</var>' specifies the power of the free block pool.</p>

<dl class="api">
<dt><code>tctmttest write [-tl] [-td|-tb|-tt|-tx] [-rc <var>num</var>] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-ip] [-is] [-in] [-it] [-if] [-ix] [-nl|-nb] [-rnd] <var>path</var> <var>tnum</var> <var>rnum</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>Store records with columns "str", "num", "type", and "flag".</dd>
<dt><code>tctmttest read [-rc <var>num</var>] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-rnd] <var>path</var> <var>tnum</var></code></dt>
<dd>Retrieve all records of the database above.</dd>
<dt><code>tctmttest remove [-rc <var>num</var>] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-rnd] <var>path</var> <var>tnum</var></code></dt>
<dd>Remove all records of the database above.</dd>
<dt><code>tctmttest wicked [-tl] [-td|-tb|-tt|-tx] [-nl|-nb] <var>path</var> <var>tnum</var> <var>rnum</var></code></dt>
<dd>Perform updating operations selected at random.</dd>
<dt><code>tctmttest typical [-tl] [-td|-tb|-tt|-tx] [-rc <var>num</var>] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-rr <var>num</var>] <var>path</var> <var>tnum</var> <var>rnum</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]</code></dt>
<dd>Perform typical operations selected at random.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-tl</code> : enable the option `TDBTLARGE'.</li>
<li><code>-td</code> : enable the option `TDBTDEFLATE'.</li>
<li><code>-tb</code> : enable the option `TDBTBZIP'.</li>
<li><code>-tt</code> : enable the option `TDBTTCBS'.</li>
<li><code>-tx</code> : enable the option `TDBTEXCODEC'.</li>
<li><code>-rc <var>num</var></code> : specify the number of cached records.</li>
<li><code>-lc <var>num</var></code> : specify the number of cached leaf pages.</li>
<li><code>-nc <var>num</var></code> : specify the number of cached non-leaf pages.</li>
<li><code>-xm <var>num</var></code> : specify the size of the extra mapped memory.</li>
<li><code>-df <var>num</var></code> : specify the unit step number of auto defragmentation.</li>
<li><code>-ip</code> : create the number index for the primary key.</li>
<li><code>-is</code> : create the string index for the column "str".</li>
<li><code>-in</code> : create the number index for the column "num".</li>
<li><code>-it</code> : create the string index for the column "type".</li>
<li><code>-if</code> : create the token inverted index for the column "flag".</li>
<li><code>-ix</code> : create the q-gram inverted index for the column "text".</li>
<li><code>-nl</code> : enable the option `TDBNOLCK'.</li>
<li><code>-nb</code> : enable the option `TDBLCKNB'.</li>
<li><code>-rnd</code> : select keys at random.</li>
<li><code>-nc</code> : omit the comparison test.</li>
<li><code>-rr <var>num</var></code> : specify the ratio of reading operation by percentage.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<p>The command `<code>tctmgr</code>' is a utility for test and debugging of the table database API and its applications.  `<var>path</var>' specifies the path of a database file.  `<var>bnum</var>' specifies the number of buckets.  `<var>apow</var>' specifies the power of the alignment.  `<var>fpow</var>' specifies the power of the free block pool.  `<var>pkey</var>' specifies the primary key of a record.  `<var>cols</var>' specifies the names and the values of a record alternately.  `<var>name</var>' specifies the name of a column.  `<var>op</var>' specifies an operator.  `<var>expr</var>' specifies the condition expression.  `<var>file</var>' specifies the input file.</p>

<dl class="api">
<dt><code>tctmgr create [-tl] [-td|-tb|-tt|-tx] <var>path</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>Create a database file.</dd>
<dt><code>tctmgr inform [-nl|-nb] <var>path</var></code></dt>
<dd>Print miscellaneous information to the standard output.</dd>
<dt><code>tctmgr put [-nl|-nb] [-sx] [-dk|-dc|-dai|-dad] <var>path</var> <var>pkey</var> [<var>cols</var> ...]</code></dt>
<dd>Store a record.</dd>
<dt><code>tctmgr out [-nl|-nb] [-sx] <var>path</var> <var>pkey</var></code></dt>
<dd>Remove a record.</dd>
<dt><code>tctmgr get [-nl|-nb] [-sx] [-px] [-pz] <var>path</var> <var>pkey</var></code></dt>
<dd>Print the value of a record.</dd>
<dt><code>tctmgr list [-nl|-nb] [-m <var>num</var>] [-pv] [-px] [-fm <var>str</var>] <var>path</var></code></dt>
<dd>Print the primary keys of all records, separated by line feeds.</dd>
<dt><code>tctmgr search [-nl|-nb] [-ord <var>name</var> <var>type</var>] [-m <var>num</var>] [-sk <var>num</var>] [-kw] [-pv] [-px] [-ph] [-bt <var>num</var>] [-rm] [-ms <var>type</var>] <var>path</var> [<var>name</var> <var>op</var> <var>expr</var> ...]</code></dt>
<dd>Print records matching conditions, separated by line feeds.</dd>
<dt><code>tctmgr optimize [-tl] [-td|-tb|-tt|-tx] [-tz] [-nl|-nb] [-df] <var>path</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>Optimize a database file.</dd>
<dt><code>tctmgr setindex [-nl|-nb] [-it <var>type</var>] <var>path</var> <var>name</var></code></dt>
<dd>Set the index of a column.</dd>
<dt><code>tctmgr importtsv [-nl|-nb] [-sc] <var>path</var> [<var>file</var>]</code></dt>
<dd>Store records of TSV in each line of a file.</dd>
<dt><code>tctmgr version</code></dt>
<dd>Print the version information of Tokyo Cabinet.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-tl</code> : enable the option `TDBTLARGE'.</li>
<li><code>-td</code> : enable the option `TDBTDEFLATE'.</li>
<li><code>-tb</code> : enable the option `TDBTBZIP'.</li>
<li><code>-tt</code> : enable the option `TDBTTCBS'.</li>
<li><code>-tx</code> : enable the option `TDBTEXCODEC'.</li>
<li><code>-nl</code> : enable the option `TDBNOLCK'.</li>
<li><code>-nb</code> : enable the option `TDBLCKNB'.</li>
<li><code>-sx</code> : the input data is evaluated as a hexadecimal data string.</li>
<li><code>-dk</code> : use the function `tctdbputkeep' instead of `tctdbput'.</li>
<li><code>-dc</code> : use the function `tctdbputcat' instead of `tctdbput'.</li>
<li><code>-dai</code> : use the function `tctdbaddint' instead of `tctdbput'.</li>
<li><code>-dad</code> : use the function `tctdbadddouble' instead of `tctdbput'.</li>
<li><code>-px</code> : the output data is converted into a hexadecimal data string.</li>
<li><code>-pz</code> : do not append line feed at the end of the output.</li>
<li><code>-m <var>num</var></code> : specify the maximum number of the output.</li>
<li><code>-pv</code> : print values of records also.</li>
<li><code>-fm <var>str</var></code> : specify the prefix of keys.</li>
<li><code>-ord <var>name</var> <var>type</var></code> : specify the order of the result.</li>
<li><code>-sk <var>num</var></code> : specify the number of skipped records.</li>
<li><code>-kw</code> : print KWIC string.</li>
<li><code>-ph</code> : print hint information also.</li>
<li><code>-bt</code> : specify the number of benchmark tests.</li>
<li><code>-rm</code> : remove every record in the result.</li>
<li><code>-ms <var>type</var></code> : specify the set operation of meta search.</li>
<li><code>-tz</code> : enable the option `UINT8_MAX'.</li>
<li><code>-df</code> : perform defragmentation only.</li>
<li><code>-it <var>type</var></code> : specify the index type among "lexical", "decimal", "token", "qgram", and "void".</li>
<li><code>-cd</code> : create the number index instead of the string index.</li>
<li><code>-cv</code> : remove the existing index.</li>
<li><code>-sc</code> : normalize keys as lower cases.</li>
</ul>

<p>The operator of the `search' subcommand is one of "STREQ", "STRINC", "STRBW", "STREW", "STRAND", "STROR", "STROREQ", "STRRX", "NUMEQ", "NUMGT", "NUMGE", "NUMLT", "NUMLE", "NUMBT", "NUMOREQ", "FTSPH", "FTSAND", "FTSOR", and "FTSEX".  If "~" preposes each operator, the logical meaning is reversed.  If "+" preposes each operator, no index is used for the operator.  The type of the `-ord' option is one of "STRASC", "STRDESC", "NUMASC", and "NUMDESC".  The type of the `-ms' option is one of "UNION", "ISECT", and "DIFF".  This command returns 0 on success, another on failure.</p>

<hr />

<h2 id="tcadbapi">The Abstract Database API</h2>

<p>Abstract database is a set of interfaces to use on-memory hash database, on-memory tree database, hash database, B+ tree database, fixed-length database, and table database with the same API.  See `<code>tcadb.h</code>' for the entire specification.</p>

<h3 id="tcadbapi_description">Description</h3>

<p>To use the abstract database API, include `<code>tcutil.h</code>', `<code>tcadb.h</code>', and related standard header files.  Usually, write the following description near the front of a source file.</p>

<dl>
<dt><code>#include &lt;tcutil.h&gt;</code></dt>
<dt><code>#include &lt;tcadb.h&gt;</code></dt>
<dt><code>#include &lt;stdlib.h&gt;</code></dt>
<dt><code>#include &lt;stdbool.h&gt;</code></dt>
<dt><code>#include &lt;stdint.h&gt;</code></dt>
</dl>

<p>Objects whose type is pointer to `<code>TCADB</code>' are used to handle abstract databases.  An abstract database object is created with the function `<code>tcadbnew</code>' and is deleted with the function `<code>tcadbdel</code>'.  To avoid memory leak, it is important to delete every object when it is no longer in use.</p>

<p>Before operations to store or retrieve records, it is necessary to connect the abstract database object to the concrete one.  The function `<code>tcadbopen</code>' is used to open a concrete database and the function `<code>tcadbclose</code>' is used to close the database.  To avoid data missing or corruption, it is important to close every database instance when it is no longer in use.  It is forbidden for multible database objects in a process to open the same database at the same time.</p>

<h3 id="tcadbapi_api">API</h3>

<p>The function `tcadbnew' is used in order to create an abstract database object.</p>

<dl class="api">
<dt><code>TCADB *tcadbnew(void);</code></dt>
<dd>The return value is the new abstract database object.</dd>
</dl>

<p>The function `tcadbdel' is used in order to delete an abstract database object.</p>

<dl class="api">
<dt><code>void tcadbdel(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
</dl>

<p>The function `tcadbopen' is used in order to open an abstract database.</p>

<dl class="api">
<dt><code>bool tcadbopen(TCADB *<var>adb</var>, const char *<var>name</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>name</var>' specifies the name of the database.  If it is "*", the database will be an on-memory hash database.  If it is "+", the database will be an on-memory tree database.  If its suffix is ".tch", the database will be a hash database.  If its suffix is ".tcb", the database will be a B+ tree database.  If its suffix is ".tcf", the database will be a fixed-length database.  If its suffix is ".tct", the database will be a table database.  Otherwise, this function fails.  Tuning parameters can trail the name, separated by "#".  Each parameter is composed of the name and the value, separated by "=".  On-memory hash database supports "bnum", "capnum", and "capsiz".  On-memory tree database supports "capnum" and "capsiz".  Hash database supports "mode", "bnum", "apow", "fpow", "opts", "rcnum", "xmsiz", and "dfunit".  B+ tree database supports "mode", "lmemb", "nmemb", "bnum", "apow", "fpow", "opts", "lcnum", "ncnum", "xmsiz", and "dfunit".  Fixed-length database supports "mode", "width", and "limsiz".  Table database supports "mode", "bnum", "apow", "fpow", "opts", "rcnum", "lcnum", "ncnum", "xmsiz", "dfunit", and "idx".</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The tuning parameter "capnum" specifies the capacity number of records.  "capsiz" specifies the capacity size of using memory.  Records spilled the capacity are removed by the storing order.  "mode" can contain "w" of writer, "r" of reader, "c" of creating, "t" of truncating, "e" of no locking, and "f" of non-blocking lock.  The default mode is relevant to "wc".  "opts" can contains "l" of large option, "d" of Deflate option, "b" of BZIP2 option, and "t" of TCBS option.  "idx" specifies the column name of an index and its type separated by ":".  For example, "casket.tch#bnum=1000000#opts=ld" means that the name of the database file is "casket.tch", and the bucket number is 1000000, and the options are large and Deflate.</dd>
</dl>

<p>The function `tcadbclose' is used in order to close an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbclose(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update of a database is assured to be written when the database is closed.  If a writer opens a database but does not close it appropriately, the database will be broken.</dd>
</dl>

<p>The function `tcadbput' is used in order to store a record into an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbput(TCADB *<var>adb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcadbput2' is used in order to store a string record into an abstract object.</p>

<dl class="api">
<dt><code>bool tcadbput2(TCADB *<var>adb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcadbputkeep' is used in order to store a new record into an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbputkeep(TCADB *<var>adb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcadbputkeep2' is used in order to store a new string record into an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbputkeep2(TCADB *<var>adb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcadbputcat' is used in order to concatenate a value at the end of the existing record in an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbputcat(TCADB *<var>adb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcadbputcat2' is used in order to concatenate a string value at the end of the existing record in an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbputcat2(TCADB *<var>adb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcadbout' is used in order to remove a record of an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbout(TCADB *<var>adb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcadbout2' is used in order to remove a string record of an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbout2(TCADB *<var>adb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcadbget' is used in order to retrieve a record in an abstract database object.</p>

<dl class="api">
<dt><code>void *tcadbget(TCADB *<var>adb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcadbget2' is used in order to retrieve a string record in an abstract database object.</p>

<dl class="api">
<dt><code>char *tcadbget2(TCADB *<var>adb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcadbvsiz' is used in order to get the size of the value of a record in an abstract database object.</p>

<dl class="api">
<dt><code>int tcadbvsiz(TCADB *<var>adb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tcadbvsiz2' is used in order to get the size of the value of a string record in an abstract database object.</p>

<dl class="api">
<dt><code>int tcadbvsiz2(TCADB *<var>adb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tcadbiterinit' is used in order to initialize the iterator of an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbiterinit(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The iterator is used in order to access the key of every record stored in a database.</dd>
</dl>

<p>The function `tcadbiternext' is used in order to get the next key of the iterator of an abstract database object.</p>

<dl class="api">
<dt><code>void *tcadbiternext(TCADB *<var>adb</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  It is allowed to update or remove records whose keys are fetched while the iteration.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.</dd>
</dl>

<p>The function `tcadbiternext2' is used in order to get the next key string of the iterator of an abstract database object.</p>

<dl class="api">
<dt><code>char *tcadbiternext2(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>If successful, the return value is the string of the next key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.</dd>
</dl>

<p>The function `tcadbfwmkeys' is used in order to get forward matching keys in an abstract database object.</p>

<dl class="api">
<dt><code>TCLIST *tcadbfwmkeys(TCADB *<var>adb</var>, const void *<var>pbuf</var>, int <var>psiz</var>, int <var>max</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>pbuf</var>' specifies the pointer to the region of the prefix.</dd>
<dd>`<var>psiz</var>' specifies the size of the region of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</dd>
</dl>

<p>The function `tcadbfwmkeys2' is used in order to get forward matching string keys in an abstract database object.</p>

<dl class="api">
<dt><code>TCLIST *tcadbfwmkeys2(TCADB *<var>adb</var>, const char *<var>pstr</var>, int <var>max</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>pstr</var>' specifies the string of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</dd>
</dl>

<p>The function `tcadbaddint' is used in order to add an integer to a record in an abstract database object.</p>

<dl class="api">
<dt><code>int tcadbaddint(TCADB *<var>adb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int <var>num</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>If successful, the return value is the summation value, else, it is `INT_MIN'.</dd>
<dd>If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcadbadddouble' is used in order to add a real number to a record in an abstract database object.</p>

<dl class="api">
<dt><code>double tcadbadddouble(TCADB *<var>adb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, double <var>num</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>If successful, the return value is the summation value, else, it is Not-a-Number.</dd>
<dd>If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcadbsync' is used in order to synchronize updated contents of an abstract database object with the file and the device.</p>

<dl class="api">
<dt><code>bool tcadbsync(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcadboptimize' is used in order to optimize the storage of an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadboptimize(TCADB *<var>adb</var>, const char *<var>params</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>params</var>' specifies the string of the tuning parameters, which works as with the tuning of parameters the function `tcadbopen'.  If it is `NULL', it is not used.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function is useful to reduce the size of the database storage with data fragmentation by successive updating.</dd>
</dl>

<p>The function `tcadbvanish' is used in order to remove all records of an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbvanish(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcadbcopy' is used in order to copy the database file of an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbcopy(TCADB *<var>adb</var>, const char *<var>path</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>path</var>' specifies the path of the destination file.  If it begins with `@', the trailing substring is executed as a command line.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if the executed command returns non-zero code.</dd>
<dd>The database file is assured to be kept synchronized and not modified while the copying or executing operation is in progress.  So, this function is useful to create a backup file of the database file.</dd>
</dl>

<p>The function `tcadbtranbegin' is used in order to begin the transaction of an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbtranbegin(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The database is locked by the thread while the transaction so that only one transaction can be activated with a database object at the same time.  Thus, the serializable isolation level is assumed if every database operation is performed in the transaction.  All updated regions are kept track of by write ahead logging while the transaction.  If the database is closed during transaction, the transaction is aborted implicitly.</dd>
</dl>

<p>The function `tcadbtrancommit' is used in order to commit the transaction of an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbtrancommit(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update in the transaction is fixed when it is committed successfully.</dd>
</dl>

<p>The function `tcadbtranabort' is used in order to abort the transaction of an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbtranabort(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update in the transaction is discarded when it is aborted.  The state of the database is rollbacked to before transaction.</dd>
</dl>

<p>The function `tcadbpath' is used in order to get the file path of an abstract database object.</p>

<dl class="api">
<dt><code>const char *tcadbpath(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>The return value is the path of the database file or `NULL' if the object does not connect to any database.  "*" stands for on-memory hash database.  "+" stands for on-memory tree database.</dd>
</dl>

<p>The function `tcadbrnum' is used in order to get the number of records of an abstract database object.</p>

<dl class="api">
<dt><code>uint64_t tcadbrnum(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>The return value is the number of records or 0 if the object does not connect to any database instance.</dd>
</dl>

<p>The function `tcadbsize' is used in order to get the size of the database of an abstract database object.</p>

<dl class="api">
<dt><code>uint64_t tcadbsize(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>The return value is the size of the database or 0 if the object does not connect to any database instance.</dd>
</dl>

<p>The function `tcadbmisc' is used in order to call a versatile function for miscellaneous operations of an abstract database object.</p>

<dl class="api">
<dt><code>TCLIST *tcadbmisc(TCADB *<var>adb</var>, const char *<var>name</var>, const TCLIST *<var>args</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>name</var>' specifies the name of the function.  All databases support "put", "out", "get", "putlist", "outlist", "getlist", and "getpart".  "put" is to store a record.  It receives a key and a value, and returns an empty list.  "out" is to remove a record.  It receives a key, and returns an empty list.  "get" is to retrieve a record.  It receives a key, and returns a list of the values.  "putlist" is to store records.  It receives keys and values one after the other, and returns an empty list.  "outlist" is to remove records.  It receives keys, and returns an empty list.  "getlist" is to retrieve records.  It receives keys, and returns keys and values of corresponding records one after the other.  "getpart" is to retrieve the partial value of a record.  It receives a key, the offset of the region, and the length of the region.</dd>
<dd>`<var>args</var>' specifies a list object containing arguments.</dd>
<dd>If successful, the return value is a list object of the result.  `NULL' is returned on failure.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<h3 id="tcadbapi_example">Example Code</h3>

<p>The following code is an example to use an abstract database.</p>

<pre>#include &lt;tcutil.h&gt;
#include &lt;tcadb.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;

int main(int argc, char **argv){
  TCADB *adb;
  char *key, *value;

  /* create the object */
  adb = tcadbnew();

  /* open the database */
  if(!tcadbopen(adb, "casket.tch")){
    fprintf(stderr, "open error\n");
  }

  /* store records */
  if(!tcadbput2(adb, "foo", "hop") ||
     !tcadbput2(adb, "bar", "step") ||
     !tcadbput2(adb, "baz", "jump")){
    fprintf(stderr, "put error\n");
  }

  /* retrieve records */
  value = tcadbget2(adb, "foo");
  if(value){
    printf("%s\n", value);
    free(value);
  } else {
    fprintf(stderr, "get error\n");
  }

  /* traverse records */
  tcadbiterinit(adb);
  while((key = tcadbiternext2(adb)) != NULL){
    value = tcadbget2(adb, key);
    if(value){
      printf("%s:%s\n", key, value);
      free(value);
    }
    free(key);
  }

  /* close the database */
  if(!tcadbclose(adb)){
    fprintf(stderr, "close error\n");
  }

  /* delete the object */
  tcadbdel(adb);

  return 0;
}
</pre>

<h3 id="tcadbapi_cli">CLI</h3>

<p>To use the abstract database API easily, the commands `<code>tcatest</code>', `<code>tcamttest</code>' and `<code>tcamgr</code>' are provided.</p>

<p>The command `<code>tcatest</code>' is a utility for facility test and performance test.  This command is used in the following format.  `<var>name</var>' specifies the database name.  `<var>rnum</var>' specifies the number of iterations.  `<var>tnum</var>' specifies the number of transactions.</p>

<dl class="api">
<dt><code>tcatest write <var>name</var> <var>rnum</var></code></dt>
<dd>Store records with keys of 8 bytes.  They change as `00000001', `00000002'...</dd>
<dt><code>tcatest read <var>name</var></code></dt>
<dd>Retrieve all records of the database above.</dd>
<dt><code>tcatest remove <var>name</var></code></dt>
<dd>Remove all records of the database above.</dd>
<dt><code>tcatest rcat <var>name</var> <var>rnum</var></code></dt>
<dd>Store records with partway duplicated keys using concatenate mode.</dd>
<dt><code>tcatest misc <var>name</var> <var>rnum</var></code></dt>
<dd>Perform miscellaneous test of various operations.</dd>
<dt><code>tcatest wicked <var>name</var> <var>rnum</var></code></dt>
<dd>Perform updating operations of list and map selected at random.</dd>
<dt><code>tcatest compare <var>name</var> <var>tnum</var> <var>rnum</var></code></dt>
<dd>Perform comparison test of database schema.</dd>
</dl>

<p>This command returns 0 on success, another on failure.</p>

<p>The command `<code>tcamttest</code>' is a utility for facility test under multi-thread situation.  This command is used in the following format.  `<var>name</var>' specifies the database name.  `<var>tnum</var>' specifies the number of running threads.  `<var>rnum</var>' specifies the number of iterations.</p>

<dl class="api">
<dt><code>tcamttest write <var>name</var> <var>tnum</var> <var>rnum</var></code></dt>
<dd>Store records with keys of 8 bytes.  They change as `00000001', `00000002'...</dd>
<dt><code>tcamttest read <var>name</var> <var>tnum</var></code></dt>
<dd>Retrieve all records of the database above.</dd>
<dt><code>tcamttest remove <var>name</var> <var>tnum</var></code></dt>
<dd>Remove all records of the database above.</dd>
</dl>

<p>This command returns 0 on success, another on failure.</p>

<p>The command `<code>tcamgr</code>' is a utility for test and debugging of the abstract database API and its applications.  `<var>name</var>' specifies the name of a database.  `<var>key</var>' specifies the key of a record.  `<var>value</var>' specifies the value of a record.  `<var>params</var>' specifies the tuning parameters.  `<var>func</var>' specifies the name of a function.  `<var>arg</var>' specifies the arguments of the function.  `<var>dest</var>' specifies the path of the destination file.</p>

<dl class="api">
<dt><code>tcamgr create <var>name</var></code></dt>
<dd>Create a database file.</dd>
<dt><code>tcamgr inform <var>name</var></code></dt>
<dd>Print miscellaneous information to the standard output.</dd>
<dt><code>tcamgr put [-sx] [-sep <var>chr</var>] [-dk|-dc|-dai|-dad] <var>name</var> <var>key</var> <var>value</var></code></dt>
<dd>Store a record.</dd>
<dt><code>tcamgr out [-sx] [-sep <var>chr</var>] <var>name</var> <var>key</var></code></dt>
<dd>Remove a record.</dd>
<dt><code>tcamgr get [-sx] [-sep <var>chr</var>] [-px] [-pz] <var>name</var> <var>key</var></code></dt>
<dd>Print the value of a record.</dd>
<dt><code>tcamgr list [-sep <var>chr</var>] [-m <var>num</var>] [-pv] [-px] [-fm <var>str</var>] <var>name</var></code></dt>
<dd>Print keys of all records, separated by line feeds.</dd>
<dt><code>tcamgr optimize <var>name</var> <var>params</var></code></dt>
<dd>Optimize a database file.</dd>
<dt><code>tcamgr misc [-sx] [-sep <var>chr</var>] [-px] <var>name</var> <var>func</var> [<var>arg</var>...]</code></dt>
<dd>Call a versatile function for miscellaneous operations.</dd>
<dt><code>tcamgr map [-fm <var>str</var>] <var>name</var> <var>dest</var></code></dt>
<dd>Map records into another B+ tree database.</dd>
<dt><code>tcamgr version</code></dt>
<dd>Print the version information of Tokyo Cabinet.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-sx</code> : the input data is evaluated as a hexadecimal data string.</li>
<li><code>-sep <var>chr</var></code> : specify the separator of the input data.</li>
<li><code>-dk</code> : use the function `tcadbputkeep' instead of `tcadbput'.</li>
<li><code>-dc</code> : use the function `tcadbputcat' instead of `tcadbput'.</li>
<li><code>-dai</code> : use the function `tcadbaddint' instead of `tcadbput'.</li>
<li><code>-dad</code> : use the function `tcadbadddouble' instead of `tcadbput'.</li>
<li><code>-px</code> : the output data is converted into a hexadecimal data string.</li>
<li><code>-pz</code> : do not append line feed at the end of the output.</li>
<li><code>-m <var>num</var></code> : specify the maximum number of the output.</li>
<li><code>-pv</code> : print values of records also.</li>
<li><code>-fm <var>str</var></code> : specify the prefix of keys.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<h3 id="tcadbapi_cgi">CGI</h3>

<p>To use the abstract database API easily, the CGI script `<code>tcawmgr.cgi</code>' is provided.</p>

<p>The CGI script `<code>tcawmgr.cgi</code>' is a utility to browse and edit an abstract database by Web interface.  The database should be placed in the same directory of the CGI script and named as "<code>casket.tch</code>", "<code>casket.tcb</code>", or "<code>casket.tcf</code>".  And, its permission should allow reading and writing by the user executing the CGI script.  Install the CGI script in a public directory of your Web server then you can start to use the CGI script by accessing the assigned URL.</p>

<hr />

<h2 id="fileformat">File Format</h2>

<p>This section describes the format of the database files of Tokyo Cabinet.</p>

<h3 id="fileformat_tchdb">File Format of Hash Database</h3>

<p>There are four sections in the file managed by the hash database; the header section, the bucket section, the free block pool section, and the record section.  Numeric values in the file are serialized in the little endian order or in the variable length format.  The latter format is delta encoding based on the 128-radix numbering.</p>

<p>The header section is from the top of the file and its length is 256 bytes.  There are the following information.</p>

<table summary="database header format">
<tr>
<td class="label">name</td>
<td class="label">offset</td>
<td class="label">length</td>
<td class="label">feature</td>
</tr>
<tr>
<td>magic number</td>
<td class="number">0</td>
<td class="number">32</td>
<td>identification of the database.  Begins with "ToKyO CaBiNeT"</td>
</tr>
<tr>
<td>database type</td>
<td class="number">32</td>
<td class="number">1</td>
<td>hash (0x01) / B+ tree (0x02) / fixed-length (0x03) / table (0x04)</td>
</tr>
<tr>
<td>additional flags</td>
<td class="number">33</td>
<td class="number">1</td>
<td>logical union of open (1&lt;&lt;0) and fatal (1&lt;&lt;1)</td>
</tr>
<tr>
<td>alignment power</td>
<td class="number">34</td>
<td class="number">1</td>
<td>the alignment size, by power of 2</td>
</tr>
<tr>
<td>free block pool power</td>
<td class="number">35</td>
<td class="number">1</td>
<td>the number of elements in the free block pool, by power of 2</td>
</tr>
<tr>
<td>options</td>
<td class="number">36</td>
<td class="number">1</td>
<td>logical union of large (1&lt;&lt;0), Deflate (1&lt;&lt;1), BZIP2 (1&lt;&lt;2), TCBS (1&lt;&lt;3), extra codec (1&lt;&lt;4)</td>
</tr>
<tr>
<td>bucket number</td>
<td class="number">40</td>
<td class="number">8</td>
<td>the number of elements of the bucket array</td>
</tr>
<tr>
<td>record number</td>
<td class="number">48</td>
<td class="number">8</td>
<td>the number of records in the database</td>
</tr>
<tr>
<td>file size</td>
<td class="number">56</td>
<td class="number">8</td>
<td>the file size of the database</td>
</tr>
<tr>
<td>first record</td>
<td class="number">64</td>
<td class="number">8</td>
<td>the offset of the first record</td>
</tr>
<tr>
<td>opaque region</td>
<td class="number">128</td>
<td class="number">128</td>
<td>users can use this region arbitrarily</td>
</tr>
</table>

<p>The bucket section trails the header section and its size is defined by the bucket number.  Each element of the bucket array indicates the offset of the first record of the hash chain.  The format of each element is the fixed length number and its size is 4 bytes in the normal mode or 8 bytes in the large mode.  The offset is recorded as the quotient by the alignment.</p>

<p>The free block pool section trails the bucket section and its size is defined by the free block pool number.  Each element of the free block pool indicates the offset and the size of each free block.  The offset is recorded as the difference of the former free block and as the quotient by the alignment.  The offset and the size are serialized in the variable length format.</p>

<p>The record section trails the free block pool section and occupies the rest region to the end of the file.  Each element has the following information.  The region of each record begins at the offset of the multiple of the alignment.</p>

<table summary="record format">
<tr>
<td class="label">name</td>
<td class="label">offset</td>
<td class="label">length</td>
<td class="label">feature</td>
</tr>
<tr>
<td>magic number</td>
<td class="number">0</td>
<td class="number">1</td>
<td>identification of record block. always 0xC8</td>
</tr>
<tr>
<td>hash value</td>
<td class="number">1</td>
<td class="number">1</td>
<td>the hash value to decide the path of the hash chain</td>
</tr>
<tr>
<td>left chain</td>
<td class="number">2</td>
<td class="number">4</td>
<td>the alignment quotient of the destination of the left chain</td>
</tr>
<tr>
<td>right chain</td>
<td class="number">6</td>
<td class="number">4</td>
<td>the alignment quotient of the destination of the right chain</td>
</tr>
<tr>
<td>padding size</td>
<td class="number">10</td>
<td class="number">2</td>
<td>the size of the padding</td>
</tr>
<tr>
<td>key size</td>
<td class="number">12</td>
<td class="number">vary</td>
<td>the size of the key</td>
</tr>
<tr>
<td>value size</td>
<td class="number">vary</td>
<td class="number">vary</td>
<td>the size of the value</td>
</tr>
<tr>
<td>key</td>
<td class="number">vary</td>
<td class="number">vary</td>
<td>the data of the key</td>
</tr>
<tr>
<td>value</td>
<td class="number">vary</td>
<td class="number">vary</td>
<td>the data of the value</td>
</tr>
<tr>
<td>padding</td>
<td class="number">vary</td>
<td class="number">vary</td>
<td>useless data</td>
</tr>
</table>

<p>However, regions of free blocks contain the following information.</p>

<table summary="free block format">
<tr>
<td class="label">name</td>
<td class="label">offset</td>
<td class="label">length</td>
<td class="label">feature</td>
</tr>
<tr>
<td>magic number</td>
<td class="number">0</td>
<td class="number">1</td>
<td>identification of record block. always 0xB0</td>
</tr>
<tr>
<td>block size</td>
<td class="number">1</td>
<td class="number">4</td>
<td>size of the block</td>
</tr>
</table>

<p>The transaction log is recorded in the file whose name is composed of the database name and the suffix ".wal".  The top eight bytes indicate the file size of the beginning of the transaction.  After that, there are the following information.</p>

<table summary="transaction log format">
<tr>
<td class="label">name</td>
<td class="label">offset</td>
<td class="label">length</td>
<td class="label">feature</td>
</tr>
<tr>
<td>offset</td>
<td class="number">0</td>
<td class="number">8</td>
<td>the offset of the updated region</td>
</tr>
<tr>
<td>size</td>
<td class="number">8</td>
<td class="number">4</td>
<td>the size of the updated region</td>
</tr>
<tr>
<td>data</td>
<td class="number">12</td>
<td class="number">vary</td>
<td>the data before update</td>
</tr>
</table>

<h3 id="fileformat_tcbdb">File Format of B+ Tree Database</h3>

<p>All data managed by the B+ tree database are recorded in the hash database.  Recorded data are classified into meta data and logical pages.  Logical pages are classified into leaf nodes and non-leaf nodes.  The formats of the fixed length number and the variable length number are the same as with the hash database.</p>

<p>Meta data are recorded in the opaque region in the header of the hash database and have the following information.</p>

<table summary="database header format">
<tr>
<td class="label">name</td>
<td class="label">offset</td>
<td class="label">length</td>
<td class="label">feature</td>
</tr>

<tr>
<td>comparison function</td>
<td class="number">0</td>
<td class="number">1</td>
<td>tccmplexical (0x00), tccmpdecimal (0x01), tccmpint32 (0x02), tccmpint64 (0x03), other (0xff)</td>
</tr>
<tr>
<td>reserved region</td>
<td class="number">1</td>
<td class="number">7</td>
<td>not used</td>
</tr>
<tr>
<td>record number of leaf node</td>
<td class="number">8</td>
<td class="number">4</td>
<td>the maximum number of records in a leaf node</td>
</tr>
<tr>
<td>index number of non-leaf node</td>
<td class="number">12</td>
<td class="number">4</td>
<td>the maximum number of indices in a leaf node</td>
</tr>
<tr>
<td>root node ID</td>
<td class="number">16</td>
<td class="number">8</td>
<td>the page ID of the root node of B+ tree</td>
</tr>
<tr>
<td>first leaf ID</td>
<td class="number">24</td>
<td class="number">8</td>
<td>the page ID of the first leaf node</td>
</tr>
<tr>
<td>last leaf ID</td>
<td class="number">32</td>
<td class="number">8</td>
<td>the page ID of the last leaf node</td>
</tr>
<tr>
<td>leaf number</td>
<td class="number">40</td>
<td class="number">8</td>
<td>the number of the leaf nodes</td>
</tr>
<tr>
<td>non-leaf number</td>
<td class="number">48</td>
<td class="number">8</td>
<td>the number of the non-leaf nodes</td>
</tr>
<tr>
<td>record number</td>
<td class="number">56</td>
<td class="number">8</td>
<td>the number of records in the database</td>
</tr>
</table>

<p>Each leaf node contains a list of records.  Each non-leaf node contains a list of indices to child nodes.  Though each record is a logical unit of user data, records with the same key are integrated into one record physically.  Each physical record has the following information.</p>

<table summary="record format">
<tr>
<td class="label">name</td>
<td class="label">offset</td>
<td class="label">length</td>
<td class="label">feature</td>
</tr>
<tr>
<td>key size</td>
<td class="number">0</td>
<td class="number">vary</td>
<td>the size of the key</td>
</tr>
<tr>
<td>value size</td>
<td class="number">vary</td>
<td class="number">vary</td>
<td>the size of the value</td>
</tr>
<tr>
<td>duplication number</td>
<td class="number">vary</td>
<td class="number">vary</td>
<td>the number of values with the same key</td>
</tr>
<tr>
<td>key</td>
<td class="number">vary</td>
<td class="number">vary</td>
<td>the data of the key</td>
</tr>
<tr>
<td>value</td>
<td class="number">vary</td>
<td class="number">vary</td>
<td>the data of the value</td>
</tr>
<tr>
<td>duplicated records</td>
<td class="number">vary</td>
<td class="number">vary</td>
<td>a list of value sizes and value data</td>
</tr>
</table>

<p>Each leaf node is a physical unit of a set of records.  Each leaf node is identified by the sequential ID number from 1.  Each leaf node is recorded in the hash database.  The key is a string in the hexadecimal numbering.  The value has the following information.  Records are kept in the ascending order of keys.</p>

<table summary="leaf node format">
<tr>
<td class="label">name</td>
<td class="label">offset</td>
<td class="label">length</td>
<td class="label">feature</td>
</tr>
<tr>
<td>previous leaf</td>
<td class="number">0</td>
<td class="number">vary</td>
<td>the ID number of the previous leaf node</td>
</tr>
<tr>
<td>next leaf</td>
<td class="number">vary</td>
<td class="number">vary</td>
<td>the ID number of the next leaf node</td>
</tr>
<tr>
<td>record list</td>
<td class="number">vary</td>
<td class="number">vary</td>
<td>the serialized data of all records in the node</td>
</tr>
</table>

<p>Each index is a logical unit of pointer to the child node.  Each index has the following information.</p>

<table summary="index format">
<tr>
<td class="label">name</td>
<td class="label">offset</td>
<td class="label">length</td>
<td class="label">feature</td>
</tr>
<tr>
<td>page ID</td>
<td class="number">0</td>
<td class="number">vary</td>
<td>the ID number of the referred page</td>
</tr>
<tr>
<td>key size</td>
<td class="number">vary</td>
<td class="number">vary</td>
<td>the size of the key</td>
</tr>
<tr>
<td>key</td>
<td class="number">vary</td>
<td class="number">vary</td>
<td>the data of the key</td>
</tr>
</table>

<p>Each non-leaf node is a physical unit of a set of indices.  Each non-leaf node is identified by the sequential number from 281474976710657.  Each non-leaf node is recorded in the hash database.  The key is a string begins with "#" and is trailed by the hexadecimal number of the ID number subtracted by 281474976710657.  The value has the following information.  Indices are kept in the ascending order of keys.</p>

<table summary="non-leaf format">
<tr>
<td class="label">name</td>
<td class="label">offset</td>
<td class="label">length</td>
<td class="label">feature</td>
</tr>
<tr>
<td>accession ID</td>
<td class="number">0</td>
<td class="number">vary</td>
<td>the ID number of the first child node</td>
</tr>
<tr>
<td>index list</td>
<td class="number">vary</td>
<td class="number">vary</td>
<td>the serialized data of all indices in the node</td>
</tr>
</table>

<h3 id="fileformat_tcfdb">File Format of Fixed-length Database</h3>

<p>There are two sections in the file managed by the fixed-length database; the header section, and the record section.  Numeric values in the file are serialized in the little endian order.</p>

<p>The header section is from the top of the file and its length is 256 bytes. There are the following information.</p>

<table summary="database header format">
<tr>
<td class="label">name</td>
<td class="label">offset</td>
<td class="label">length</td>
<td class="label">feature</td>
</tr>
<tr>
<td>magic number</td>
<td class="number">0</td>
<td class="number">32</td>
<td>identification of the database. Begins with "ToKyO CaBiNeT"</td>
</tr>
<tr>
<td>database type</td>
<td class="number">32</td>
<td class="number">1</td>
<td>always 0x03</td>
</tr>
<tr>
<td>additional flags</td>
<td class="number">33</td>
<td class="number">1</td>
<td>logical union of open (1&lt;&lt;0) and fatal (1&lt;&lt;1)</td>
</tr>
<tr>
<td>record number</td>
<td class="number">48</td>
<td class="number">8</td>
<td>the number of records in the database</td>
</tr>
<tr>
<td>file size</td>
<td class="number">56</td>
<td class="number">8</td>
<td>the file size of the database</td>
</tr>
<tr>
<td>record width</td>
<td class="number">64</td>
<td class="number">8</td>
<td>the width of each record</td>
</tr>
<tr>
<td>limit size</td>
<td class="number">72</td>
<td class="number">8</td>
<td>the limit size of the database</td>
</tr>
<tr>
<td>least ID</td>
<td class="number">80</td>
<td class="number">8</td>
<td>the least ID number of records</td>
</tr>
<tr>
<td>greatest ID</td>
<td class="number">88</td>
<td class="number">8</td>
<td>the greatest ID number of records</td>
</tr>
<tr>
<td>opaque region</td>
<td class="number">128</td>
<td class="number">128</td>
<td>users can use this region arbitrarily</td>
</tr>
</table>

<p>The record section trails the header section and occupies the rest region to the end of the file. Each element has the following information.  The size region takes 1 byte if the record width is less than 256 bytes, or takes 2 bytes if the record width is less than 65536, else takes 4 bytes.  The size of each record is the summation of the size of the width region and the record width.  So, the region of each record begins at the offset generated by the ID number subtracted by 1 and multiplied by the record width and the added by 256.</p>

<table summary="record format">
<tr>
<td class="label">name</td>
<td class="label">offset</td>
<td class="label">length</td>
<td class="label">feature</td>
</tr>
<tr>
<td>value size</td>
<td class="number">0</td>
<td class="number">vary</td>
<td>the size of the value</td>
</tr>
<tr>
<td>value</td>
<td class="number">vary</td>
<td class="number">vary</td>
<td>the data of the value</td>
</tr>
<tr>
<td>padding</td>
<td class="number">vary</td>
<td class="number">vary</td>
<td>padding.  If the size of the value is 0, the first byte indicates whether the record exists or not</td>
</tr>
</table>

<p>The naming convention and the file format of the transaction log file is the same as the one of the hash database.</p>

<h3 id="fileformat_note">Note</h3>

<p>Because database files are not sparse, you can copy them as with normal files.  Moreover, the database formats don't depend on the byte order of the running environment, you can migrate the database files between environments with different byte orders.</p>

<p>If possible, set the MIME type `<code>application/x-tokyocabinet-hash</code>' when sending files of the hash database.  The suffix of the file name should be `<code>.tch</code>'.  As for the B+ tree database, `<code>application/x-tokyocabinet-btree</code>' and `<code>.tcb</code>'.  As for the fixed-length database, `<code>application/x-tokyocabinet-fixed</code>' and `<code>.tcf</code>'.  As for the table database, `<code>application/x-tokyocabinet-btree</code>' and `<code>.tct</code>'.</p>

<p>To make the `<code>file</code>' command identify the database formats, append the following lines to the `<code>magic</code>' file.</p>

<pre># Tokyo Cabinet magic data
0       string    ToKyO\ CaBiNeT\n   Tokyo Cabinet
&gt;14     string    x                  \b (%s)
&gt;32     byte      0                  \b, Hash
!:mime  application/x-tokyocabinet-hash
&gt;32     byte      1                  \b, B+ tree
!:mime  application/x-tokyocabinet-btree
&gt;32     byte      2                  \b, Fixed-length
!:mime  application/x-tokyocabinet-fixed
&gt;32     byte      3                  \b, Table
!:mime  application/x-tokyocabinet-table
&gt;33     byte      &amp;1                 \b, [open]
&gt;33     byte      &amp;2                 \b, [fatal]
&gt;34     byte      x                  \b, apow=%d
&gt;35     byte      x                  \b, fpow=%d
&gt;36     byte      &amp;1                 \b, [large]
&gt;36     byte      &amp;2                 \b, [deflate]
&gt;36     byte      &amp;4                 \b, [bzip]
&gt;36     byte      &amp;8                 \b, [tcbs]
&gt;36     byte      &amp;16                \b, [excodec]
&gt;40     lequad    x                  \b, bnum=%lld
&gt;48     lequad    x                  \b, rnum=%lld
&gt;56     lequad    x                  \b, fsiz=%lld
</pre>

<hr />

<h2 id="license">License</h2>

<p>Tokyo Cabinet is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License or any later version.</p>

<p>Tokyo Cabinet is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.</p>

<p>You should have received a copy of the GNU Lesser General Public License along with Tokyo Cabinet (See the file `<code>COPYING</code>'); if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.</p>

<p>Tokyo Cabinet was written by FAL Labs.  You can contact the author by e-mail to `<code>info@fallabs.com</code>'.</p>

<hr />

</body>

</html>

<!-- END OF FILE -->
