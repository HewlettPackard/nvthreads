<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">

<head>
<meta http-equiv="Content-Language" content="ja" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta name="author" content="FAL Labs" />
<meta name="keywords" content="Tokyo Cabinet, tokyocabinet, database, DBM" />
<meta name="description" content="Specifications of Tokyo Cabinet" />
<link rel="contents" href="./" />
<link rel="alternate" href="spex-en.html" hreflang="en" title="the English version" />
<link rel="stylesheet" href="common.css" />
<link rel="icon" href="icon16.png" />
<link rev="made" href="mailto:info@fallabs.com" />
<title>Fundamental Specifications of Tokyo Cabinet Version 1 (Japanese)</title>
</head>

<body>

<h1 id="headline">Tokyo Cabinet第1版基本仕様書</h1>

<div class="note">Copyright (C) 2006-2012 FAL Labs</div>
<div class="note">Last Update: Sat, 18 Aug 2012 11:05:00 +0900</div>
<div class="navi">[<a href="spex-en.html" hreflang="en">English</a>/<span class="void">Japanese</span>] [<a href="index.ja.html">HOME</a>]</div>

<hr />

<h2 id="contents">目次</h2>

<ol>
<li><a href="#introduction">はじめに</a></li>
<li><a href="#features">特徴</a></li>
<li><a href="#installation">インストール</a></li>
<li><a href="#tcutilapi">ユーティリティAPI</a></li>
<li><a href="#tchdbapi">ハッシュデータベースAPI</a></li>
<li><a href="#tcbdbapi">B+木データベースAPI</a></li>
<li><a href="#tcfdbapi">固定長データベースAPI</a></li>
<li><a href="#tctdbapi">テーブルデータベースAPI</a></li>
<li><a href="#tcadbapi">抽象データベースAPI</a></li>
<li><a href="#tips">ちょっとしたコツ</a></li>
<li><a href="#fileformat">ファイルフォーマット</a></li>
<li><a href="#faq">よく聞かれる質問</a></li>
<li><a href="#license">ライセンス</a></li>
</ol>

<hr />

<h2 id="introduction">はじめに</h2>

<p>Tokyo Cabinetはデータベースを扱うルーチン群のライブラリです。データベースといっても単純なもので、キーと値のペアからなるレコード群を格納したデータファイルです。キーと値は任意の長さを持つ一連のバイト列であり、文字列でもバイナリでも扱うことができます。テーブルやデータ型の概念はありません。レコードはハッシュ表かB+木か固定長配列で編成されます。</p>

<p>ハッシュ表のデータベースでは、キーはデータベース内で一意であり、キーが重複する複数のレコードを格納することはできません。このデータベースに対しては、キーと値を指定してレコードを格納したり、キーを指定して対応するレコードを削除したり、キーを指定して対応するレコードを検索したりすることができます。また、データベースに格納してある全てのキーを順不同に一つずつ取り出すこともできます。このような操作は、UNIX標準で定義されているDBMライブラリおよびその追従であるNDBMやGDBMに類するものです。Tokyo CabinetはDBMのより良い代替として利用することができます。</p>

<p>B+木のデータベースでは、キーが重複する複数のレコードを格納することができます。このデータベースに対しては、ハッシュ表のデータベースと同様に、キーを指定してレコードを格納したり取り出したり削除したりすることができます。レコードはユーザが指示した比較関数に基づいて整列されて格納されます。カーソルを用いて各レコードを昇順または降順で参照することができます。この機構によって、文字列の前方一致検索や数値の範囲検索が可能になります。</p>

<p>固定長配列のデータベースでは、一意な自然数をキーとしてレコードが格納されます。キーが重複する複数のレコードを格納することはできません。また、各レコードの値の長さは一定以下に制限されます。提供される操作はハッシュデータベースとほぼ同様です。</p>

<p>ハッシュ表のデータベース変種として、テーブルのデータベースも提供されます。各レコードは主キーで識別されるとともに、名前付きコラムの集合を値として持ちます。データスキーマの概念はありませんが、任意のコラムに張られたインデックスを用いることで複雑な条件に基づくレコードの検索を効率化することができます。</p>

<p>Tokyo CabinetはC言語で記述され、CとPerlとRubyとJavaとLuaのAPIとして提供されます。Tokyo CabinetはC99およびPOSIX準拠のAPIを備えるプラットフォームで利用できます。Tokyo CabinetはGNU Lesser General Public Licenseに基づくフリーソフトウェアです。</p>

<hr />

<h2 id="features">特徴</h2>

<p>Tokyo CabinetはQDBMの後継であり、空間効率と時間効率と使いやすさを向上させた製品です。この節ではTokyo Cabinetの特徴について説明します。</p>

<h3 id="features_dinosaur">DBM一族の最右翼</h3>

<p>Tokyo CabinetはGDBMやQDBMの後継として次の点を目標として開発されました。これらの目標は達成されており、Tokyo Cabinetは従来のDBMを置き換える製品だと言えます。</p>

<ul>
<li><strong>空間効率</strong>の向上 : データベースファイルがより小さい</li>
<li><strong>時間効率</strong>の向上 : 処理がより高速である</li>
<li><strong>並列性</strong>の向上 : マルチスレッド環境での同時実行性能の向上</li>
<li><strong>利便性</strong>の向上 : APIがより単純である</li>
<li><strong>堅牢性</strong>の向上 : 不慮の事態でもデータベースファイルが壊れにくい</li>
<li><strong>64ビット</strong>対応 : 巨大なメモリ空間とデータベースファイルを扱える</li>
</ul>

<p>Tokyo CabinetはQDBMと同様に、伝統的なDBMが抱える三つの制限事項を回避しています。すなわち、プロセス内で複数のデータベースを扱うことができ、キーと値のサイズに制限がなく、データベースファイルがスパースではありません。さらに、QDBMが抱える三つの制限事項を回避しています。すなわち、2GB以上のデータベースファイルを扱うことができ、バイトオーダの異なる環境間でデータベースファイルを共有することができ、複数のスレッドが同時にデータベースの探索を行うことができます。</p>

<p>Tokyo Cabinetは高速に動作します。例えば100万件のレコードの登録にかかる時間は、ハッシュデータベースで0.7秒ほど、B+木データベースで1.6秒ほどです。そしてTokyo Cabinetのデータベースは小さいです。例えば1レコードあたりのオーバーヘッドは、ハッシュデータベースで16バイトほど、B+木データベースで5バイトほどです。さらにTokyo Cabinetで扱えるデータの規模は莫大です。最大8EB（9.22e18バイト）までのデータベースファイルを扱うことができます。</p>

<h3 id="features_tchdb">効率的なハッシュデータベースの実装</h3>

<p>Tokyo Cabinetはレコードの探索にハッシュアルゴリズムを用います。バケット配列に十分な要素数があれば、レコードの探索にかかる時間計算量は O(1) です。すなわち、レコードの探索に必要な時間はデータベースの規模に関わらず一定です。追加や削除に関しても同様です。ハッシュ値の衝突はセパレートチェーン法で管理します。チェーンのデータ構造は二分探索木です。したがって、バケット配列の要素数が著しく少ない場合でも、探索等の時間計算量は O(log n) に抑えられます。</p>

<p>Tokyo Cabinetはバケット配列を全てRAM上に保持することによって、処理の高速化を図ります。バケット配列がRAM上にあれば、ほぼ1パスのファイル操作でレコードに該当するファイル上の領域を参照することができます。ファイルに記録されたバケット配列は `read' コールでRAM上に読み込むのではなく、`mmap' コールでRAMに直接マッピングされます。したがって、データベースに接続する際の準備時間が極めて短く、また、複数のプロセスでメモリマップを共有することができます。</p>

<p>バケット配列の要素数が格納するレコード数の半分ほどであれば、データの性質によって多少前後しますが、ハッシュ値の衝突率は56.7%ほどです（等倍だと36.8%、2倍だと21.3%、4倍だと11.5%、8倍だと6.0%ほど）。そのような場合、平均2パス以下のファイル操作でレコードを探索することができます。これを性能指標とするならば、例えば100万個のレコードを格納するためには50万要素のバケット配列が求められます。バケット配列の各要素は4バイトです。すなわち、2MバイトのRAMが利用できれば100万レコードのデータベースが構築できます。</p>

<p>伝統的なDBMにはレコードの追加操作に関して「挿入」モードと「置換」モードがあります。前者では、キーが既存のレコードと重複する際に既存の値を残します。後者では、キーが既存のレコードと重複した際に新しい値に置き換えます。Tokyo Cabinetはその２つに加えて「連結」モードがあります。既存の値の末尾に指定された値を連結して格納する操作です。レコードの値を配列として扱う場合、要素を追加するには連結モードが役に立ちます。</p>

<p>一般的に、データベースの更新処理を続けるとファイル内の利用可能領域の断片化（フラグメンテーション）が起き、ファイルのサイズが肥大化してしまいます。Tokyo Cabinetは隣接する不要領域を連結して再利用することによってこの問題に対処します。既存のレコードの値をより大きなサイズの値に上書きする場合、そのレコードの領域をファイル中の別の位置に移動させる必要があります。この処理の時間計算量はレコードのサイズに依存するので、値を拡張していく場合には効率が悪くなります。しかし、Tokyo Cabinetはアラインメントによってこの問題に対処します。増分がパディングに収まれば領域を移動させる必要はありません。</p>

<p>不要領域を効率的に再利用するための「フリーブロックプール」も実装されています。これは不要になった領域をリストに記憶しておき、新しい領域が要求された際ににリストの中から最も小さい不要領域（ベストフィット）を選択して再利用するものです。それでも断片化は避けられないので、レコードの領域を詰め直して最適化（デフラグ）する二種類の機能も実装されています。一つめは静的な最適化で、全てのレコードを別ファイルに配置しなおしてから一気に書き戻すものです。二つめは動的な最適化で、レコードと不要領域の位置を入れ替える操作を少しずつ行って不要領域を集結させていくものです。</p>

<h3 id="features_tcbdb">便利なB+木データベースの実装</h3>

<p>B+木データベースはハッシュデータベースより遅いのですが、ユーザが定義した順序に基づいて各レコードを参照できることが特長です。B+木は複数のレコードを整列させた状態で論理的なページにまとめて管理します。各ページに対してはB木すなわち多進平衡木によって階層化された疎インデックスが維持されます。したがって、各レコードの探索等にかかる時間計算量は O(log n) です。各レコードを順番に参照するためにカーソルが提供されます。カーソルの場所はキーを指定して飛ばすことができ、また現在の場所から次のレコードに進めたり前のレコードに戻したりすることができます。各ページは双方向リンクリストで編成されるので、カーソルを前後に移動させる操作の時間計算量は O(1) です。</p>

<p>B+木データベースは上述のハッシュデータベースを基盤として実装されます。B+木の各ページはハッシュデータベースのレコードとして記録されるので、ハッシュデータベースの記憶管理の効率性を継承しています。B+木では各レコードのヘッダが小さく、アラインメントはページの単位でとられるので、ほとんどの場合、ハッシュデータベースに較べてデータベースファイルのサイズが半減します。B+木を更新する際には多くのページを操作する必要がありますが、Tokyo Cabinetはページをキャッシュすることによってファイル操作を減らして処理を効率化します。ほとんどの場合、疎インデックス全体がメモリ上にキャッシュされるので、各レコードを参照するのに必要なファイル操作は平均1パス以下です。</p>

<p>各ページを圧縮して保存する機能も提供されます。圧縮方式はZLIBのDeflateとBZIP2のブロックソーティングの2種類をサポートしています。同一ページ内の各レコードは似たようなパターンを持つため、Lempel-ZivやBWTなどのアルゴリズムを適用すると高い圧縮効率が期待できます。テキストデータを扱う場合、データベースのサイズが元の25%程度になります。データベースの規模が大きくディスクI/Oがボトルネックとなる場合は、圧縮機能を有効化すると処理速度が大幅に改善されます。</p>

<h3 id="features_tcfdb">素朴な固定長データベースの実装</h3>

<p>固定長データベースは、キーが自然数でなくてはならず、また値のサイズが制限されますが、その条件を受諾できる場合には最も効率的です。レコード群は固定長の要素の配列として保持され、各レコードはキーの倍数から算出されるオフセットの位置に格納されます。したがって、各レコードの探索等にかかる時間計算量は O(1) です。提供される操作群はハッシュデータベースとほぼ同じです。</p>

<p>データベース全体を `mmap' コールでメモリ上にマッピングして多次元配列として参照するので、ファイルI/Oにかかるオーバーヘッドは極小化されます。構造が単純なおかげで、固定長データベースはハッシュデータベースよりもさらに高速に動作するとともに、マルチスレッド環境での並列実行性能も傑出しています。</p>

<p>データベースのサイズは、キーの変域と値の制限長に比例します。すなわち、キーの変域が小さく、値のサイズが小さいほど、空間効率は向上します。例えば、キーの最大値が100万で、値の制限長が100バイトの場合、データベースのサイズは100MBほどになります。RAM上に読み込まれるのは実際に参照されたレコードの周辺の領域のみなので、データベースのサイズは仮想メモリのサイズまで大きくすることができます。</p>

<h3 id="features_tctdb">柔軟なテーブルデータベースの実装</h3>

<p>テーブルデータベースは、単純なキーと値の構造ではなく、リレーショナルデータベースの表のような構造を表現します。各レコードは主キーで識別されるとともに、任意の文字列で名前を付けられたコラムの集合を値として持ちます。例えば、社員番号を主キーにして、名前や部署や給与などのコラムを構造化して格納することができます。リレーショナルデータベースと違ってデータスキーマを事前に定義する必要はなく、レコード毎に異なる種類のコラムを持たせることができます。</p>

<p>テーブルデータベースに対しては、主キー以外の条件でも問い合わせを行うことができます。条件はコラムの名前と条件式で構成されます。条件式の演算子としては、文字列型に関しては完全一致や前方一致や正規表現などが提供され、数値型に関しては完全一致や範囲一致が提供されます。タグ検索や全文検索の演算子も提供されます。クエリに複数の条件式を持たせることで論理積条件を指定できます。複数のクエリを使って検索を行うことで論理和条件を指定できます。検索結果の順序は文字列または数値の昇順または降順を指定することができます。</p>

<p>コラムを使った検索やソートを高速化するために、コラム毎のインデックスを作成することができます。コラムには型の概念はありませんが、インデックスには文字列型もしくは数値型の区別があります。空白区切りトークンと文字N-gramトークンの転置インデックスもサポートされます。クエリオプティマイザは検索条件やソート条件に応じた最適な順序でインデックスを利用します。インデックスはB+木データベースの外部ファイルとして実装されます。</p>

<h3 id="features_practical">実用的な機能性</h3>

<p>ファイルシステム上のデータベースはトランザクション機構を提供します。トランザクションを開始してから終了するまでの一連の操作を一括してデータベースにコミットしたり、一連の更新操作を破棄してデータベースの状態をトランザクションの開始前の状態にロールバックしたりすることができます。トランザクションの分離レベルは2種類あります。データベースに対する全ての操作をトランザクション内で行うと直列化可能（serializable）トランザクションとなり、トランザクション外の操作を同時に行うと非コミット読み取り（read uncommitted）トランザクションとなります。耐久性はログ先行書き込みとシャドウページングによって担保されます。</p>

<p>Tokyo Cabinetにはデータベースに接続するモードとして、「リーダ」と「ライタ」の二種類があります。リーダは読み込み専用で、ライタは読み書き両用です。データベースにはファイルロックによってプロセス間での排他制御が行われます。ライタが接続している間は、他のプロセスはリーダとしてもライタとしても接続できません。リーダが接続している間は、他のプロセスのリーダは接続できるが、ライタは接続できません。この機構によって、マルチタスク環境での同時接続に伴うデータの整合性が保証されます。</p>

<p>Tokyo CabinetのAPIの各関数はリエントラントであり、マルチスレッド環境で安全に利用することができます。別個のデータベースオブジェクトに対しては全ての操作を完全に並列に行うことができます。同一のデータベースオブジェクトに対しては、リードライトロックで排他制御を行います。すなわち、読み込みを行うスレッド同士は並列に実行でき、書き込みを行うスレッドは他の読み込みや書き込みをブロックします。ロックの粒度は、ハッシュデータベースと固定長データベースではレコード単位、それ以外のデータベースではファイル単位です。</p>

<h3 id="features_simple">単純だが多様なインタフェース群</h3>

<p>Tokyo Cabinetはオブジェクト指向に基づいた簡潔なAPIを提供します。データベースに対する全ての操作はデータベースオブジェクトにカプセル化され、開く（open）、閉じる（close）、挿入する（put）、削除する（out）、取得する（get）といった関数（メソッド）を呼ぶことでプログラミングを進めていけます。ハッシュデータベースとB+木データベースと固定長データベースのAPIは互いに酷似しているので、アプリケーションを一方から他方に移植することも簡単です。さらに、それらのAPI群を全く同じインターフェイスで操作するための抽象APIも提供されます。抽象APIを用いると実行時にデータベースの種類を決定することができます。</p>

<p>メモリ上でレコードを簡単に扱うために、ユーティリティAPIが提供されます。リストやマップといった基本的なデータ構造をはじめ、メモリプールや文字列処理や符号処理など、プログラミングで良く使う機能を詰め込んでいます。</p>

<p>C言語のAPIには、ユーティリティAPI、ハッシュデータベースAPI、B+木データベースAPI、固定長データベースAPI、テーブルデータベースAPI、抽象データベースAPIの6種類があります。各APIに対応したコマンドラインインタフェースも用意されています。それらはプロトタイピングやテストやデバッグなどで活躍するでしょう。Tokyo CabinetはC言語の他にも、PerlとRubyとJavaとLuaのAPIを提供します。その他の言語のインターフェイスも第三者によって提供されるでしょう。</p>

<p>複数のプロセスが同時にデータベースを操作したい場合やリモートホストにあるデータベースを操作したい場合には、リモートサービスを使うと便利です。リモートサービスはデータベースサーバとそのアクセスライブラリからなり、アプリケーションはリモートデータベースAPIを介してデータベースサーバを操作することができます。HTTPやmemcachedプロトコルもサポートするので、ほぼ全てのプラットフォームからデータベースサーバを簡単に操作することができます。</p>

<hr />

<h2 id="installation">インストール</h2>

<p>Tokyo Cabinetのソースパッケージからのインストール方法を説明します。バイナリパッケージのインストール方法についてはそれぞれのパッケージの説明書をご覧ください。</p>

<h3 id="installation_preparation">前提</h3>

<p>Tokyo Cabinetの現在バージョンは、UNIX系のOSで利用することができます。少なくとも、以下の環境では動作するはずです。</p>

<ul>
<li>Linux 2.4以降 (x86-32/x86-64/PowerPC/Alpha/SPARC)</li>
<li>Mac OS X 10.3以降 (x86-32/x86-64/PowerPC)</li>
</ul>

<p>ソースパッケージを用いてTokyo Cabinetをインストールするには、<code>gcc</code>のバージョン3.1以降と<code>make</code>が必要です。それらはLinuxやFreeBSDなどには標準的にインストールされています。</p>

<p>Tokyo Cabinetは、以下のライブラリを利用しています。予めインストールしておいてください。</p>

<ul>
<li><a href="http://www.zlib.net/">zlib</a> : 可逆データ圧縮。バージョン1.2.3以降推奨。</li>
<li><a href="http://www.bzip.org/">bzip2</a> : 可逆データ圧縮。バージョン1.0.5以降推奨。</li>
</ul>

<h3 id="installation_installation">ビルドとインストール</h3>

<p>Tokyo Cabinetの配布用アーカイブファイルを展開したら、作成されたディレクトリに入ってインストール作業を行います。</p>

<p><code>configure</code>スクリプトを実行して、ビルド環境を設定します。</p>

<pre>./configure
</pre>

<p>プログラムをビルドします。</p>

<pre>make
</pre>

<p>プログラムの自己診断テストを行います。</p>

<pre>make check
</pre>

<p>プログラムをインストールします。作業は<code>root</code>ユーザで行います。</p>

<pre>make install
</pre>

<h3 id="installation_result">結果</h3>

<p>一連の作業が終ると、以下のファイルがインストールされます。</p>

<pre>/usr/local/include/tcutil.h
/usr/local/include/tchdb.h
/usr/local/include/tcbdb.h
/usr/local/include/tcfdb.h
/usr/local/include/tctdb.h
/usr/local/include/tcadb.h
/usr/local/lib/libtokyocabinet.a
/usr/local/lib/libtokyocabinet.so.x.y.z
/usr/local/lib/libtokyocabinet.so.x
/usr/local/lib/libtokyocabinet.so
/usr/local/lib/pkgconfig/tokyocabinet.pc
/usr/local/bin/tcutest
/usr/local/bin/tcumttest
/usr/local/bin/tcucodec
/usr/local/bin/tchtest
/usr/local/bin/tchmttest
/usr/local/bin/tchmgr
/usr/local/bin/tcbmgr
/usr/local/bin/tcbtest
/usr/local/bin/tcbmttest
/usr/local/bin/tcftest
/usr/local/bin/tcfmttest
/usr/local/bin/tcfmgr
/usr/local/bin/tcttest
/usr/local/bin/tctmttest
/usr/local/bin/tctmgr
/usr/local/bin/tcatest
/usr/local/bin/tcamttest
/usr/local/bin/tcamgr
/usr/local/libexec/tcawmgr.cgi
/usr/local/share/tokyocabinet/...
/usr/local/man/man1/...
/usr/local/man/man3/...
</pre>

<h3 id="installation_option">configureのオプション</h3>

<p>「<code>./configure</code>」を実行する際には、以下のオプションを指定することができます。</p>

<ul class="options">
<li><code>--enable-debug</code> : デバッグ用にビルドする。デバッグシンボルを有効化し、最適化を行わず、静的にリンクする。</li>
<li><code>--enable-devel</code> : 開発用にビルドする。デバッグシンボルを有効化し、最適化を行い、動的にリンクする。</li>
<li><code>--enable-profile</code> : プロファイル用にビルドする。プロファイルオプションを有効化し、最適化を行い、動的にリンクする。</li>
<li><code>--enable-static</code> : 静的にリンクする。</li>
<li><code>--enable-fastest</code> : 最高速になるように最適化を行う。</li>
<li><code>--enable-off64</code> : 32ビット環境でも64ビットのファイルオフセットを用いる。</li>
<li><code>--enable-swab</code> : バイトオーダの変換を強制する。</li>
<li><code>--enable-uyield</code> : レースコンディションの検出用にビルドする。</li>
<li><code>--disable-zlib</code> : ZLIBによるレコード圧縮を無効にする。</li>
<li><code>--disable-bzip</code> : BZIP2によるレコード圧縮を無効にする。</li>
<li><code>--disable-pthread</code> : POSIXスレッドのサポートを無効にする。</li>
<li><code>--disable-shared</code> : 共有ライブラリのビルドを行わない。</li>
</ul>

<p>`<code>--prefix</code>' などのオプションも一般的なUNIXソフトウェアのパッケージと同様に利用可能です。`<code>/usr/local</code>' 以下ではなく '<code>/usr</code>' 以下にインストールしたい場合は `<code>--prefix=/usr</code>' を指定してください。なお、ライブラリ検索パスに `<code>/usr/local/lib</code>' が入っていない環境では、Tokyo Cabinetのアプリケーションを実行する際に環境変数 `<code>LD_LIBRARY_PATH</code>' の値に `<code>/usr/local/lib</code>' を含めておくようにしてください。</p>

<h3 id="installation_library">ライブラリの使い方</h3>

<p>Tokyo CabinetはC言語のAPIを提供し、それはC89標準（ANSI C）またはC99標準に準拠したプログラムから利用することができます。Tokyo Cabinetヘッダは `<code>tcutil.h</code>'、`<code>tchdb.h</code>'、`<code>tcbdb.h</code>'、`<code>tcadb.h</code>' として提供されますので、適宜それらをアプリケーションのソースコード中でインクルードした上で、APIの各種機能を利用してください。ライブラリは `<code>libtokyocabinet.a</code>' および `<code>libtokyocabinet.so</code>' として提供され、それらは `<code>libz.so</code>'、`<code>libbz2.so</code>', `<code>librt.so</code>', `<code>libpthread.so</code>'、`<code>libm.so</code>'、`<code>libc.so</code>' に依存しますので、アプリケーションプログラムをビルドする際にはそれらに対応するリンカオプションをつけてください。最も典型的なビルド手順は以下のようになります。</p>

<pre>gcc -I/usr/local/include tc_example.c -o tc_example \
  -L/usr/local/lib -ltokyocabinet -lz -lbz2 -lrt -lpthread -lm -lc
</pre>

<p>Tokyo CabinetはC++言語のプログラムからも利用することができます。各ヘッダは暗黙的にCリンケージ（「<code>extern "C"</code>」ブロック）で包まれているので、単にインクルードするだけで利用することができます。</p>

<hr />

<h2 id="tcutilapi">ユーティリティAPI</h2>

<p>ユーティリティAPIは、メモリ上で簡単にレコードを扱うためのルーチン集です。特に拡張可能文字列と配列リストがハッシュマップと順序木が便利です。`<code>tcutil.h</code>' にAPIの仕様の完全な記述があります。</p>

<h3 id="tcutilapi_description">概要</h3>

<p>ユーティリティAPIを使うためには、`<code>tcutil.h</code>' および関連する標準ヘッダファイルをインクルードしてください。通常、ソースファイルの冒頭付近で以下の記述を行います。</p>

<dl>
<dt><code>#include &lt;tcutil.h&gt;</code></dt>
<dt><code>#include &lt;stdlib.h&gt;</code></dt>
<dt><code>#include &lt;stdbool.h&gt;</code></dt>
<dt><code>#include &lt;stdint.h&gt;</code></dt>
</dl>

<p>拡張可能文字列を扱う際には、`<code>TCXSTR</code>' 型へのポインタをオブジェクトとして用います。拡張可能文字列オブジェクトは、関数 `<code>tcxstrnew</code>' で作成し、関数 `<code>tcxstrdel</code>' で破棄します。配列リストを扱う際には、`<code>TCLIST</code>' 型へのポインタをオブジェクトとして用います。リストオブジェクトは、関数 `<code>tclistnew</code>' で作成し、関数 `<code>tclistdel</code>' で破棄します。ハッシュマップを扱う際には、`<code>TCMAP</code>' 型へのポインタをオブジェクトとして用います。マップオブジェクトは、関数 `<code>tcmapopen</code>' で作成し、関数 `<code>tcmapdel</code>' で破棄します。順序木を扱う際には、`<code>TCTREE</code>' 型へのポインタをオブジェクトとして用います。ツリーオブジェクトは、関数 `<code>tctreeopen</code>' で作成し、関数 `<code>tctreedel</code>' で破棄します。作成したオブジェクトを使い終わったら必ず破棄してください。そうしないとメモリリークが発生します。</p>

<h3 id="tcutilapi_basicapi">基礎的なユーティリティのAPI（英語御免）</h3>

<p>The constant `tcversion' is the string containing the version information.</p>

<dl class="api">
<dt><code>extern const char *tcversion;</code></dt>
</dl>

<p>The variable `tcfatalfunc' is the pointer to the call back function for handling a fatal error.</p>

<dl class="api">
<dt><code>extern void (*tcfatalfunc)(const char *);</code></dt>
<dd>The argument specifies the error message.</dd>
<dd>The initial value of this variable is `NULL'.  If the value is `NULL', the default function is called when a fatal error occurs.  A fatal error occurs when memory allocation is failed.</dd>
</dl>

<p>The function `tcmalloc' is used in order to allocate a region on memory.</p>

<dl class="api">
<dt><code>void *tcmalloc(size_t <var>size</var>);</code></dt>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the pointer to the allocated region.</dd>
<dd>This function handles failure of memory allocation implicitly.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tccalloc' is used in order to allocate a nullified region on memory.</p>

<dl class="api">
<dt><code>void *tccalloc(size_t <var>nmemb</var>, size_t <var>size</var>);</code></dt>
<dd>`<var>nmemb</var>' specifies the number of elements.</dd>
<dd>`<var>size</var>' specifies the size of each element.</dd>
<dd>The return value is the pointer to the allocated nullified region.</dd>
<dd>This function handles failure of memory allocation implicitly.  Because the region of the return value is allocated with the `calloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcrealloc' is used in order to re-allocate a region on memory.</p>

<dl class="api">
<dt><code>void *tcrealloc(void *<var>ptr</var>, size_t <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the pointer to the re-allocated region.</dd>
<dd>This function handles failure of memory allocation implicitly.  Because the region of the return value is allocated with the `realloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmemdup' is used in order to duplicate a region on memory.</p>

<dl class="api">
<dt><code>void *tcmemdup(const void *<var>ptr</var>, size_t <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the pointer to the allocated region of the duplicate.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcstrdup' is used in order to duplicate a string on memory.</p>

<dl class="api">
<dt><code>char *tcstrdup(const void *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string.</dd>
<dd>The return value is the allocated string equivalent to the specified string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcfree' is used in order to free a region on memory.</p>

<dl class="api">
<dt><code>void tcfree(void *<var>ptr</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.  If it is `NULL', this function has no effect.</dd>
<dd>Although this function is just a wrapper of `free' call, this is useful in applications using another package of the `malloc' series.</dd>
</dl>

<h3 id="tcutilapi_xstrapi">拡張可能文字列のAPI（英語御免）</h3>

<p>The function `tcxstrnew' is used in order to create an extensible string object.</p>

<dl class="api">
<dt><code>TCXSTR *tcxstrnew(void);</code></dt>
<dd>The return value is the new extensible string object.</dd>
</dl>

<p>The function `tcxstrnew2' is used in order to create an extensible string object from a character string.</p>

<dl class="api">
<dt><code>TCXSTR *tcxstrnew2(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string of the initial content.</dd>
<dd>The return value is the new extensible string object containing the specified string.</dd>
</dl>

<p>The function `tcxstrnew3' is used in order to create an extensible string object with the initial allocation size.</p>

<dl class="api">
<dt><code>TCXSTR *tcxstrnew3(int <var>asiz</var>);</code></dt>
<dd>`<var>asiz</var>' specifies the initial allocation size.</dd>
<dd>The return value is the new extensible string object.</dd>
</dl>

<p>The function `tcxstrdup' is used in order to copy an extensible string object.</p>

<dl class="api">
<dt><code>TCXSTR *tcxstrdup(const TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>The return value is the new extensible string object equivalent to the specified object.</dd>
</dl>

<p>The function `tcxstrdel' is used in order to delete an extensible string object.</p>

<dl class="api">
<dt><code>void tcxstrdel(TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tcxstrcat' is used in order to concatenate a region to the end of an extensible string object.</p>

<dl class="api">
<dt><code>void tcxstrcat(TCXSTR *<var>xstr</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region to be appended.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
</dl>

<p>The function `tcxstrcat2' is used in order to concatenate a character string to the end of an extensible string object.</p>

<dl class="api">
<dt><code>void tcxstrcat2(TCXSTR *<var>xstr</var>, const char *<var>str</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>`<var>str</var>' specifies the string to be appended.</dd>
</dl>

<p>The function `tcxstrptr' is used in order to get the pointer of the region of an extensible string object.</p>

<dl class="api">
<dt><code>const void *tcxstrptr(const TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>The return value is the pointer of the region of the object.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.</dd>
</dl>

<p>The function `tcxstrsize' is used in order to get the size of the region of an extensible string object.</p>

<dl class="api">
<dt><code>int tcxstrsize(const TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>The return value is the size of the region of the object.</dd>
</dl>

<p>The function `tcxstrclear' is used in order to clear an extensible string object.</p>

<dl class="api">
<dt><code>void tcxstrclear(TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>The internal buffer of the object is cleared and the size is set zero.</dd>
</dl>

<p>The function `tcxstrprintf' is used in order to perform formatted output into an extensible string object.</p>

<dl class="api">
<dt><code>void tcxstrprintf(TCXSTR *<var>xstr</var>, const char *<var>format</var>, ...);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>`<var>format</var>' specifies the printf-like format string.  The conversion character `%' can be used with such flag characters as `s', `d', `o', `u', `x', `X', `c', `e', `E', `f', `g', `G', `@', `?', `b', and `%'.  `@' works as with `s' but escapes meta characters of XML.  `?' works as with `s' but escapes meta characters of URL.  `b' converts an integer to the string as binary numbers.  The other conversion character work as with each original.</dd>
<dd>The other arguments are used according to the format string.</dd>
</dl>

<p>The function `tcsprintf' is used in order to allocate a formatted string on memory.</p>

<dl class="api">
<dt><code>char *tcsprintf(const char *<var>format</var>, ...);</code></dt>
<dd>`<var>format</var>' specifies the printf-like format string.  The conversion character `%' can be used with such flag characters as `s', `d', `o', `u', `x', `X', `c', `e', `E', `f', `g', `G', `@', `?', `b', and `%'.  `@' works as with `s' but escapes meta characters of XML.  `?' works as with `s' but escapes meta characters of URL.  `b' converts an integer to the string as binary numbers.  The other conversion character work as with each original.</dd>
<dd>The other arguments are used according to the format string.</dd>
<dd>The return value is the pointer to the region of the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<h3 id="tcutilapi_listapi">配列リストのAPI（英語御免）</h3>

<p>The function `tclistnew' is used in order to create a list object.</p>

<dl class="api">
<dt><code>TCLIST *tclistnew(void);</code></dt>
<dd>The return value is the new list object.</dd>
</dl>

<p>The function `tclistnew2' is used in order to create a list object with expecting the number of elements.</p>

<dl class="api">
<dt><code>TCLIST *tclistnew2(int <var>anum</var>);</code></dt>
<dd>`<var>anum</var>' specifies the number of elements expected to be stored in the list.</dd>
<dd>The return value is the new list object.</dd>
</dl>

<p>The function `tclistnew3' is used in order to create a list object with initial string elements.</p>

<dl class="api">
<dt><code>TCLIST *tclistnew3(const char *<var>str</var>, ...);</code></dt>
<dd>`<var>str</var>' specifies the string of the first element.</dd>
<dd>The other arguments are other elements.  They should be trailed by a `NULL' argument.</dd>
<dd>The return value is the new list object.</dd>
</dl>

<p>The function `tclistdup' is used in order to copy a list object.</p>

<dl class="api">
<dt><code>TCLIST *tclistdup(const TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>The return value is the new list object equivalent to the specified object.</dd>
</dl>

<p>The function `tclistdel' is used in order to delete a list object.</p>

<dl class="api">
<dt><code>void tclistdel(TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tclistnum' is used in order to get the number of elements of a list object.</p>

<dl class="api">
<dt><code>int tclistnum(const TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>The return value is the number of elements of the list.</dd>
</dl>

<p>The function `tclistval' is used in order to get the pointer to the region of an element of a list object.</p>

<dl class="api">
<dt><code>const void *tclistval(const TCLIST *<var>list</var>, int <var>index</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the element.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the value.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  If `index' is equal to or more than the number of elements, the return value is `NULL'.</dd>
</dl>

<p>The function `tclistval2' is used in order to get the string of an element of a list object.</p>

<dl class="api">
<dt><code>const char *tclistval2(const TCLIST *<var>list</var>, int <var>index</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the element.</dd>
<dd>The return value is the string of the value.</dd>
<dd>If `index' is equal to or more than the number of elements, the return value is `NULL'.</dd>
</dl>

<p>The function `tclistpush' is used in order to add an element at the end of a list object.</p>

<dl class="api">
<dt><code>void tclistpush(TCLIST *<var>list</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region of the new element.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
</dl>

<p>The function `tclistpush2' is used in order to add a string element at the end of a list object.</p>

<dl class="api">
<dt><code>void tclistpush2(TCLIST *<var>list</var>, const char *<var>str</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>str</var>' specifies the string of the new element.</dd>
</dl>

<p>The function `tclistpop' is used in order to remove an element of the end of a list object.</p>

<dl class="api">
<dt><code>void *tclistpop(TCLIST *<var>list</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the removed element.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If the list is empty, the return value is `NULL'.</dd>
</dl>

<p>The function `tclistpop2' is used in order to remove a string element of the end of a list object.</p>

<dl class="api">
<dt><code>char *tclistpop2(TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>The return value is the string of the removed element.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If the list is empty, the return value is `NULL'.</dd>
</dl>

<p>The function `tclistunshift' is used in order to add an element at the top of a list object.</p>

<dl class="api">
<dt><code>void tclistunshift(TCLIST *<var>list</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region of the new element.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
</dl>

<p>The function `tclistunshift2' is used in order to add a string element at the top of a list object.</p>

<dl class="api">
<dt><code>void tclistunshift2(TCLIST *<var>list</var>, const char *<var>str</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>str</var>' specifies the string of the new element.</dd>
</dl>

<p>The function `tclistshift' is used in order to remove an element of the top of a list object.</p>

<dl class="api">
<dt><code>void *tclistshift(TCLIST *<var>list</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the removed element.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If the list is empty, the return value is `NULL'.</dd>
</dl>

<p>The function `tclistshift2' is used in order to remove a string element of the top of a list object.</p>

<dl class="api">
<dt><code>char *tclistshift2(TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>The return value is the string of the removed element.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If the list is empty, the return value is `NULL'.</dd>
</dl>

<p>The function `tclistinsert' is used in order to add an element at the specified location of a list object.</p>

<dl class="api">
<dt><code>void tclistinsert(TCLIST *<var>list</var>, int <var>index</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the new element.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region of the new element.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>If `index' is equal to or more than the number of elements, this function has no effect.</dd>
</dl>

<p>The function `tclistinsert2' is used in order to add a string element at the specified location of a list object.</p>

<dl class="api">
<dt><code>void tclistinsert2(TCLIST *<var>list</var>, int <var>index</var>, const char *<var>str</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the new element.</dd>
<dd>`<var>str</var>' specifies the string of the new element.</dd>
<dd>If `index' is equal to or more than the number of elements, this function has no effect.</dd>
</dl>

<p>The function `tclistremove' is used in order to remove an element at the specified location of a list object.</p>

<dl class="api">
<dt><code>void *tclistremove(TCLIST *<var>list</var>, int <var>index</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the element to be removed.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the removed element.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If `index' is equal to or more than the number of elements, no element is removed and the return value is `NULL'.</dd>
</dl>

<p>The function `tclistremove2' is used in order to remove a string element at the specified location of a list object.</p>

<dl class="api">
<dt><code>char *tclistremove2(TCLIST *<var>list</var>, int <var>index</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the element to be removed.</dd>
<dd>The return value is the string of the removed element.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If `index' is equal to or more than the number of elements, no element is removed and the return value is `NULL'.</dd>
</dl>

<p>The function `tclistover' is used in order to overwrite an element at the specified location of a list object.</p>

<dl class="api">
<dt><code>void tclistover(TCLIST *<var>list</var>, int <var>index</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the element to be overwritten.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region of the new content.</dd>
<dd>`<var>size</var>' specifies the size of the new content.</dd>
<dd>If `index' is equal to or more than the number of elements, this function has no effect.</dd>
</dl>

<p>The function `tclistover2' is used in order to overwrite a string element at the specified location of a list object.</p>

<dl class="api">
<dt><code>void tclistover2(TCLIST *<var>list</var>, int <var>index</var>, const char *<var>str</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the element to be overwritten.</dd>
<dd>`<var>str</var>' specifies the string of the new content.</dd>
<dd>If `index' is equal to or more than the number of elements, this function has no effect.</dd>
</dl>

<p>The function `tclistsort' is used in order to sort elements of a list object in lexical order.</p>

<dl class="api">
<dt><code>void tclistsort(TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
</dl>

<p>The function `tclistlsearch' is used in order to search a list object for an element using liner search.</p>

<dl class="api">
<dt><code>int tclistlsearch(const TCLIST *<var>list</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the index of a corresponding element or -1 if there is no corresponding element.</dd>
<dd>If two or more elements correspond, the former returns.</dd>
</dl>

<p>The function `tclistbsearch' is used in order to search a list object for an element using binary search.</p>

<dl class="api">
<dt><code>int tclistbsearch(const TCLIST *<var>list</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.  It should be sorted in lexical order.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the index of a corresponding element or -1 if there is no corresponding element.</dd>
<dd>If two or more elements correspond, which returns is not defined.</dd>
</dl>

<p>The function `tclistclear' is used in order to clear a list object.</p>

<dl class="api">
<dt><code>void tclistclear(TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>All elements are removed.</dd>
</dl>

<p>The function `tclistdump' is used in order to serialize a list object into a byte array.</p>

<dl class="api">
<dt><code>void *tclistdump(const TCLIST *<var>list</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the result serial region.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tclistload' is used in order to create a list object from a serialized byte array.</p>

<dl class="api">
<dt><code>TCLIST *tclistload(const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region of serialized byte array.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is a new list object.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<h3 id="tcutilapi_mapapi">ハッシュマップのAPI（英語御免）</h3>

<p>The function `tcmapnew' is used in order to create a map object.</p>

<dl class="api">
<dt><code>TCMAP *tcmapnew(void);</code></dt>
<dd>The return value is the new map object.</dd>
</dl>

<p>The function `tcmapnew2' is used in order to create a map object with specifying the number of the buckets.</p>

<dl class="api">
<dt><code>TCMAP *tcmapnew2(uint32_t <var>bnum</var>);</code></dt>
<dd>`<var>bnum</var>' specifies the number of the buckets.</dd>
<dd>The return value is the new map object.</dd>
</dl>

<p>The function `tcmapnew3' is used in order to create a map object with initial string elements.</p>

<dl class="api">
<dt><code>TCMAP *tcmapnew3(const char *<var>str</var>, ...);</code></dt>
<dd>`<var>str</var>' specifies the string of the first element.</dd>
<dd>The other arguments are other elements.  They should be trailed by a `NULL' argument.</dd>
<dd>The return value is the new map object.</dd>
<dd>The key and the value of each record are situated one after the other.</dd>
</dl>

<p>The function `tcmapdup' is used in order to copy a map object.</p>

<dl class="api">
<dt><code>TCMAP *tcmapdup(const TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>The return value is the new map object equivalent to the specified object.</dd>
</dl>

<p>The function `tcmapdel' is used in order to delete a map object.</p>

<dl class="api">
<dt><code>void tcmapdel(TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tcmapput' is used in order to store a record into a map object.</p>

<dl class="api">
<dt><code>void tcmapput(TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If a record with the same key exists in the map, it is overwritten.</dd>
</dl>

<p>The function `tcmapput2' is used in order to store a string record into a map object.</p>

<dl class="api">
<dt><code>void tcmapput2(TCMAP *<var>map</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If a record with the same key exists in the map, it is overwritten.</dd>
</dl>

<p>The function `tcmapputkeep' is used in order to store a new record into a map object.</p>

<dl class="api">
<dt><code>bool tcmapputkeep(TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the map, this function has no effect.</dd>
</dl>

<p>The function `tcmapputkeep2' is used in order to store a new string record into a map object.</p>

<dl class="api">
<dt><code>bool tcmapputkeep2(TCMAP *<var>map</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the map, this function has no effect.</dd>
</dl>

<p>The function `tcmapputcat' is used in order to concatenate a value at the end of the value of the existing record in a map object.</p>

<dl class="api">
<dt><code>void tcmapputcat(TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcmapputcat2' is used in order to concatenate a string value at the end of the value of the existing record in a map object.</p>

<dl class="api">
<dt><code>void tcmapputcat2(TCMAP *<var>map</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcmapout' is used in order to remove a record of a map object.</p>

<dl class="api">
<dt><code>bool tcmapout(TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcmapout2' is used in order to remove a string record of a map object.</p>

<dl class="api">
<dt><code>bool tcmapout2(TCMAP *<var>map</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcmapget' is used in order to retrieve a record in a map object.</p>

<dl class="api">
<dt><code>const void *tcmapget(const TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.</dd>
</dl>

<p>The function `tcmapget2' is used in order to retrieve a string record in a map object.</p>

<dl class="api">
<dt><code>const char *tcmapget2(const TCMAP *<var>map</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
</dl>

<p>The function `tcmapmove' is used in order to move a record to the edge of a map object.</p>

<dl class="api">
<dt><code>bool tcmapmove(TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, bool <var>head</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of a key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>head</var>' specifies the destination which is the head if it is true or the tail if else.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcmapmove2' is used in order to move a string record to the edge of a map object.</p>

<dl class="api">
<dt><code>bool tcmapmove2(TCMAP *<var>map</var>, const char *<var>kstr</var>, bool <var>head</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kstr</var>' specifies the string of a key.</dd>
<dd>`<var>head</var>' specifies the destination which is the head if it is true or the tail if else.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcmapiterinit' is used in order to initialize the iterator of a map object.</p>

<dl class="api">
<dt><code>void tcmapiterinit(TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>The iterator is used in order to access the key of every record stored in the map object.</dd>
</dl>

<p>The function `tcmapiternext' is used in order to get the next key of the iterator of a map object.</p>

<dl class="api">
<dt><code>const void *tcmapiternext(TCMAP *<var>map</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  The order of iteration is assured to be the same as the stored order.</dd>
</dl>

<p>The function `tcmapiternext2' is used in order to get the next key string of the iterator of a map object.</p>

<dl class="api">
<dt><code>const char *tcmapiternext2(TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</dd>
<dd>The order of iteration is assured to be the same as the stored order.</dd>
</dl>

<p>The function `tcmaprnum' is used in order to get the number of records stored in a map object.</p>

<dl class="api">
<dt><code>uint64_t tcmaprnum(const TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>The return value is the number of the records stored in the map object.</dd>
</dl>

<p>The function `tcmapmsiz' is used in order to get the total size of memory used in a map object.</p>

<dl class="api">
<dt><code>uint64_t tcmapmsiz(const TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>The return value is the total size of memory used in a map object.</dd>
</dl>

<p>The function `tcmapkeys' is used in order to create a list object containing all keys in a map object.</p>

<dl class="api">
<dt><code>TCLIST *tcmapkeys(const TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>The return value is the new list object containing all keys in the map object.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcmapvals' is used in order to create a list object containing all values in a map object.</p>

<dl class="api">
<dt><code>TCLIST *tcmapvals(const TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>The return value is the new list object containing all values in the map object.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcmapaddint' is used in order to add an integer to a record in a map object.</p>

<dl class="api">
<dt><code>int tcmapaddint(TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int <var>num</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>The return value is the summation value.</dd>
<dd>If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcmapadddouble' is used in order to add a real number to a record in a map object.</p>

<dl class="api">
<dt><code>double tcmapadddouble(TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, double <var>num</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>The return value is the summation value.</dd>
<dd>If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcmapclear' is used in order to clear a map object.</p>

<dl class="api">
<dt><code>void tcmapclear(TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>All records are removed.</dd>
</dl>

<p>The function `tcmapcutfront' is used in order to remove front records of a map object.</p>

<dl class="api">
<dt><code>void tcmapcutfront(TCMAP *<var>map</var>, int <var>num</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>num</var>' specifies the number of records to be removed.</dd>
</dl>

<p>The function `tcmapdump' is used in order to serialize a map object into a byte array.</p>

<dl class="api">
<dt><code>void *tcmapdump(const TCMAP *<var>map</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the result serial region.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmapload' is used in order to create a map object from a serialized byte array.</p>

<dl class="api">
<dt><code>TCMAP *tcmapload(const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region of serialized byte array.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is a new map object.</dd>
<dd>Because the object of the return value is created with the function `tcmapnew', it should be deleted with the function `tcmapdel' when it is no longer in use.</dd>
</dl>

<h3 id="tcutilapi_treeapi">順序木のAPI（英語御免）</h3>

<p>The function `tctreenew' is used in order to create a tree object.</p>

<dl class="api">
<dt><code>TCTREE *tctreenew(void);</code></dt>
<dd>The return value is the new tree object.</dd>
</dl>

<p>The function `tctreenew2' is used in order to create a tree object with specifying the custom comparison function.</p>

<dl class="api">
<dt><code>TCTREE *tctreenew2(TCCMP <var>cmp</var>, void *<var>cmpop</var>);</code></dt>
<dd>`<var>cmp</var>' specifies the pointer to the custom comparison function.  It receives five parameters.  The first parameter is the pointer to the region of one key.  The second parameter is the size of the region of one key.  The third parameter is the pointer to the region of the other key.  The fourth parameter is the size of the region of the other key.  The fifth parameter is the pointer to the optional opaque object.  It returns positive if the former is big, negative if the latter is big, 0 if both are equivalent.</dd>
<dd>`<var>cmpop</var>' specifies an arbitrary pointer to be given as a parameter of the comparison function.  If it is not needed, `NULL' can be specified.</dd>
<dd>The return value is the new tree object.</dd>
<dd>The default comparison function compares keys of two records by lexical order.  The functions `tccmplexical' (dafault), `tccmpdecimal', `tccmpint32', and `tccmpint64' are built-in.</dd>
</dl>

<p>The function `tctreedup' is used in order to copy a tree object.</p>

<dl class="api">
<dt><code>TCTREE *tctreedup(const TCTREE *<var>tree</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>The return value is the new tree object equivalent to the specified object.</dd>
</dl>

<p>The function `tctreedel' is used in order to delete a tree object.</p>

<dl class="api">
<dt><code>void tctreedel(TCTREE *<var>tree</var>);</code></dt>
<dd>`tree' specifies the tree object.</dd>
<dd>Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tctreeput' is used in order to store a record into a tree object.</p>

<dl class="api">
<dt><code>void tctreeput(TCTREE *<var>tree</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If a record with the same key exists in the tree, it is overwritten.</dd>
</dl>

<p>The function `tctreeput2' is used in order to store a string record into a tree object.</p>

<dl class="api">
<dt><code>void tctreeput2(TCTREE *<var>tree</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If a record with the same key exists in the tree, it is overwritten.</dd>
</dl>

<p>The function `tctreeputkeep' is used in order to store a new record into a tree object.</p>

<dl class="api">
<dt><code>bool tctreeputkeep(TCTREE *<var>tree</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the tree, this function has no effect.</dd>
</dl>

<p>The function `tctreeputkeep2' is used in order to store a new string record into a tree object.</p>

<dl class="api">
<dt><code>bool tctreeputkeep2(TCTREE *<var>tree</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the tree, this function has no effect.</dd>
</dl>

<p>The function `tctreeputcat' is used in order to concatenate a value at the end of the value of the existing record in a tree object.</p>

<dl class="api">
<dt><code>void tctreeputcat(TCTREE *<var>tree</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tctreeputcat2' is used in order to concatenate a string value at the end of the value of the existing record in a tree object.</p>

<dl class="api">
<dt><code>void tctreeputcat2(TCTREE *<var>tree</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tctreeout' is used in order to remove a record of a tree object.</p>

<dl class="api">
<dt><code>bool tctreeout(TCTREE *<var>tree</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tctreeout2' is used in order to remove a string record of a tree object.</p>

<dl class="api">
<dt><code>bool tctreeout2(TCTREE *<var>tree</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tctreeget' is used in order to retrieve a record in a tree object.</p>

<dl class="api">
<dt><code>const void *tctreeget(TCTREE *<var>tree</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.</dd>
</dl>

<p>The function `tctreeget2' is used in order to retrieve a string record in a tree object.</p>

<dl class="api">
<dt><code>const char *tctreeget2(TCTREE *<var>tree</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
</dl>

<p>The function `tctreeiterinit' is used in order to initialize the iterator of a tree object.</p>

<dl class="api">
<dt><code>void tctreeiterinit(TCTREE *<var>tree</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>The iterator is used in order to access the key of every record stored in the tree object.</dd>
</dl>

<p>The function `tctreeiternext' is used in order to get the next key of the iterator of a tree object.</p>

<dl class="api">
<dt><code>const void *tctreeiternext(TCTREE *<var>tree</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  The order of iteration is assured to be ascending of the keys.</dd>
</dl>

<p>The function `tctreeiternext2' is used in order to get the next key string of the iterator of a tree object.</p>

<dl class="api">
<dt><code>const char *tctreeiternext2(TCTREE *<var>tree</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</dd>
<dd>The order of iteration is assured to be ascending of the keys.</dd>
</dl>

<p>The function `tctreernum' is used in order to get the number of records stored in a tree object.</p>

<dl class="api">
<dt><code>uint64_t tctreernum(const TCTREE *<var>tree</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>The return value is the number of the records stored in the tree object.</dd>
</dl>

<p>The function `tctreemsiz' is used in order to get the total size of memory used in a tree object.</p>

<dl class="api">
<dt><code>uint64_t tctreemsiz(const TCTREE *<var>tree</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>The return value is the total size of memory used in a tree object.</dd>
</dl>

<p>The function `tctreekeys' is used in order to create a list object containing all keys in a tree object.</p>

<dl class="api">
<dt><code>TCLIST *tctreekeys(const TCTREE *<var>tree</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>The return value is the new list object containing all keys in the tree object.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tctreevals' is used in order to create a list object containing all values in a tree object.</p>

<dl class="api">
<dt><code>TCLIST *tctreevals(const TCTREE *<var>tree</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>The return value is the new list object containing all values in the tree object.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tctreeaddint' is used in order to add an integer to a record in a tree object.</p>

<dl class="api">
<dt><code>int tctreeaddint(TCTREE *<var>tree</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int <var>num</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>The return value is the summation value.</dd>
<dd>If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tctreeadddouble' is used in order to add a real number to a record in a tree object.</p>

<dl class="api">
<dt><code>double tctreeadddouble(TCTREE *<var>tree</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, double <var>num</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>The return value is the summation value.</dd>
<dd>If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tctreeclear' is used in order to clear a tree object.</p>

<dl class="api">
<dt><code>void tctreeclear(TCTREE *<var>tree</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>All records are removed.</dd>
</dl>

<p>The function `tctreecutfringe' is used in order to remove fringe records of a tree object.</p>

<dl class="api">
<dt><code>void tctreecutfringe(TCTREE *<var>tree</var>, int <var>num</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>num</var>' specifies the number of records to be removed.</dd>
</dl>

<p>The function `tctreedump' is used in order to serialize a tree object into a byte array.</p>

<dl class="api">
<dt><code>void *tctreedump(const TCTREE *<var>tree</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>tree</var>' specifies the tree object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the result serial region.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tctreeload' is used in order to create a tree object from a serialized byte array.</p>

<dl class="api">
<dt><code>TCTREE *tctreeload(const void *<var>ptr</var>, int <var>size</var>, TCCMP <var>cmp</var>, void *<var>cmpop</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region of serialized byte array.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>cmp</var>' specifies the pointer to the custom comparison function.</dd>
<dd>`<var>cmpop</var>' specifies an arbitrary pointer to be given as a parameter of the comparison function.</dd>
<dd>If it is not needed, `NULL' can be specified.</dd>
<dd>The return value is a new tree object.</dd>
<dd>Because the object of the return value is created with the function `tctreenew', it should be deleted with the function `tctreedel' when it is no longer in use.</dd>
</dl>

<h3 id="tcutilapi_mdbapi">オンメモリハッシュデータベースのAPI（英語御免）</h3>

<p>The function `tcmdbnew' is used in order to create an on-memory hash database object.</p>

<dl class="api">
<dt><code>TCMDB *tcmdbnew(void);</code></dt>
<dd>The return value is the new on-memory hash database object.</dd>
<dd>The object can be shared by plural threads because of the internal mutex.</dd>
</dl>

<p>The function `tcmdbnew2' is used in order to create an on-memory hash database object with specifying the number of the buckets.</p>

<dl class="api">
<dt><code>TCMDB *tcmdbnew2(uint32_t <var>bnum</var>);</code></dt>
<dd>`<var>bnum</var>' specifies the number of the buckets.</dd>
<dd>The return value is the new on-memory hash database object.</dd>
<dd>The object can be shared by plural threads because of the internal mutex.</dd>
</dl>

<p>The function `tcmdbdel' is used in order to delete an on-memory hash database object.</p>

<dl class="api">
<dt><code>void tcmdbdel(TCMDB *<var>mdb</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
</dl>

<p>The function `tcmdbput' is used in order to store a record into an on-memory hash database object.</p>

<dl class="api">
<dt><code>void tcmdbput(TCMDB *<var>mdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcmdbput2' is used in order to store a string record into an on-memory hash database object.</p>

<dl class="api">
<dt><code>void tcmdbput2(TCMDB *<var>mdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcmdbputkeep' is used in order to store a new record into an on-memory hash database object.</p>

<dl class="api">
<dt><code>bool tcmdbputkeep(TCMDB *<var>mdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcmdbputkeep2' is used in order to store a new string record into an on-memory hash database object.</p>

<dl class="api">
<dt><code>bool tcmdbputkeep2(TCMDB *<var>mdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcmdbputcat' is used in order to concatenate a value at the end of the existing record in an on-memory hash database.</p>

<dl class="api">
<dt><code>void tcmdbputcat(TCMDB *<var>mdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcmdbputcat2' is used in order to concatenate a string at the end of the existing record in an on-memory hash database.</p>

<dl class="api">
<dt><code>void tcmdbputcat2(TCMDB *<var>mdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcmdbout' is used in order to remove a record of an on-memory hash database object.</p>

<dl class="api">
<dt><code>bool tcmdbout(TCMDB *<var>mdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcmdbout2' is used in order to remove a string record of an on-memory hash database object.</p>

<dl class="api">
<dt><code>bool tcmdbout2(TCMDB *<var>mdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcmdbget' is used in order to retrieve a record in an on-memory hash database object.</p>

<dl class="api">
<dt><code>void *tcmdbget(TCMDB *<var>mdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmdbget2' is used in order to retrieve a string record in an on-memory hash database object.</p>

<dl class="api">
<dt><code>char *tcmdbget2(TCMDB *<var>mdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmdbvsiz' is used in order to get the size of the value of a record in an on-memory hash database object.</p>

<dl class="api">
<dt><code>int tcmdbvsiz(TCMDB *<var>mdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tcmdbvsiz2' is used in order to get the size of the value of a string record in an on-memory hash database object.</p>

<dl class="api">
<dt><code>int tcmdbvsiz2(TCMDB *<var>mdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tcmdbiterinit' is used in order to initialize the iterator of an on-memory hash database object.</p>

<dl class="api">
<dt><code>void tcmdbiterinit(TCMDB *<var>mdb</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>The iterator is used in order to access the key of every record stored in the on-memory hash database.</dd>
</dl>

<p>The function `tcmdbiternext' is used in order to get the next key of the iterator of an on-memory hash database object.</p>

<dl class="api">
<dt><code>void *tcmdbiternext(TCMDB *<var>mdb</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return</dd>
<dd>value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  The order of iteration is assured to be the same as the stored order.</dd>
</dl>

<p>The function `tcmdbiternext2' is used in order to get the next key string of the iterator of an on-memory hash database object.</p>

<dl class="api">
<dt><code>char *tcmdbiternext2(TCMDB *<var>mdb</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  The order of iteration is assured to be the same as the stored order.</dd>
</dl>

<p>The function `tcmdbfwmkeys' is used in order to get forward matching keys in an on-memory hash database object.</p>

<dl class="api">
<dt><code>TCLIST *tcmdbfwmkeys(TCMDB *<var>mdb</var>, const void *<var>pbuf</var>, int <var>psiz</var>, int <var>max</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>pbuf</var>' specifies the pointer to the region of the prefix.</dd>
<dd>`<var>psiz</var>' specifies the size of the region of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</dd>
</dl>

<p>The function `tcmdbfwmkeys2' is used in order to get forward matching string keys in an on-memory hash database object.</p>

<dl class="api">
<dt><code>TCLIST *tcmdbfwmkeys2(TCMDB *<var>mdb</var>, const char *<var>pstr</var>, int <var>max</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>pstr</var>' specifies the string of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</dd>
</dl>

<p>The function `tcmdbrnum' is used in order to get the number of records stored in an on-memory hash database object.</p>

<dl class="api">
<dt><code>uint64_t tcmdbrnum(TCMDB *<var>mdb</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>The return value is the number of the records stored in the database.</dd>
</dl>

<p>The function `tcmdbmsiz' is used in order to get the total size of memory used in an on-memory hash database object.</p>

<dl class="api">
<dt><code>uint64_t tcmdbmsiz(TCMDB *<var>mdb</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>The return value is the total size of memory used in the database.</dd>
</dl>

<p>The function `tcmdbaddint' is used in order to add an integer to a record in an on-memory hash database object.</p>

<dl class="api">
<dt><code>int tcmdbaddint(TCMDB *<var>mdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int <var>num</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>The return value is the summation value.</dd>
<dd>If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcmdbadddouble' is used in order to add a real number to a record in an on-memory hash database object.</p>

<dl class="api">
<dt><code>double tcmdbadddouble(TCMDB *<var>mdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, double <var>num</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>The return value is the summation value.</dd>
<dd>If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcmdbvanish' is used in order to clear an on-memory hash database object.</p>

<dl class="api">
<dt><code>void tcmdbvanish(TCMDB *<var>mdb</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>All records are removed.</dd>
</dl>

<p>The function `tcmdbcutfront' is used in order to remove front records of an on-memory hash database object.</p>

<dl class="api">
<dt><code>void tcmdbcutfront(TCMDB *<var>mdb</var>, int <var>num</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory hash database object.</dd>
<dd>`<var>num</var>' specifies the number of records to be removed.</dd>
</dl>

<h3 id="tcutilapi_ndbapi">オンメモリツリーデータベースのAPI（英語御免）</h3>

<p>The function `tcndbnew' is used in order to create an on-memory tree database object.</p>

<dl class="api">
<dt><code>TCNDB *tcndbnew(void);</code></dt>
<dd>The return value is the new on-memory tree database object.</dd>
<dd>The object can be shared by plural threads because of the internal mutex.</dd>
</dl>

<p>The function `tcndbnew2' is used in order to create an on-memory tree database object with specifying the custom comparison function.</p>

<dl class="api">
<dt><code>TCNDB *tcndbnew2(TCCMP <var>cmp</var>, void *<var>cmpop</var>);</code></dt>
<dd>`<var>cmp</var>' specifies the pointer to the custom comparison function.</dd>
<dd>`<var>cmpop</var>' specifies an arbitrary pointer to be given as a parameter of the comparison function.  If it is not needed, `NULL' can be specified.</dd>
<dd>The return value is the new on-memory tree database object.</dd>
<dd>The default comparison function compares keys of two records by lexical order.  The functions `tccmplexical' (dafault), `tccmpdecimal', `tccmpint32', and `tccmpint64' are built-in.  The object can be shared by plural threads because of the internal mutex.</dd>
</dl>

<p>The function `tcndbdel' is used in order to delete an on-memory tree database object.</p>

<dl class="api">
<dt><code>void tcndbdel(TCNDB *<var>ndb</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
</dl>

<p>The function `tcndbput' is used in order to store a record into an on-memory tree database object.</p>

<dl class="api">
<dt><code>void tcndbput(TCNDB *<var>ndb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcndbput2' is used in order to store a string record into an on-memory tree database object.</p>

<dl class="api">
<dt><code>void tcndbput2(TCNDB *<var>ndb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcndbputkeep' is used in order to store a new record into an on-memory tree database object.</p>

<dl class="api">
<dt><code>bool tcndbputkeep(TCNDB *<var>ndb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcndbputkeep2' is used in order to store a new string record into an on-memory tree database object.</p>

<dl class="api">
<dt><code>bool tcndbputkeep2(TCNDB *<var>ndb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcndbputcat' is used in order to concatenate a value at the end of the existing record in an on-memory tree database.</p>

<dl class="api">
<dt><code>void tcndbputcat(TCNDB *<var>ndb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcndbputcat2' is used in order to concatenate a string at the end of the existing record in an on-memory tree database.</p>

<dl class="api">
<dt><code>void tcndbputcat2(TCNDB *<var>ndb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcndbout' is used in order to remove a record of an on-memory tree database object.</p>

<dl class="api">
<dt><code>bool tcndbout(TCNDB *<var>ndb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcndbout2' is used in order to remove a string record of an on-memory tree database object.</p>

<dl class="api">
<dt><code>bool tcndbout2(TCNDB *<var>ndb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcndbget' is used in order to retrieve a record in an on-memory tree database object.</p>

<dl class="api">
<dt><code>void *tcndbget(TCNDB *<var>ndb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcndbget2' is used in order to retrieve a string record in an on-memory tree database object.</p>

<dl class="api">
<dt><code>char *tcndbget2(TCNDB *<var>ndb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcndbvsiz' is used in order to get the size of the value of a record in an on-memory tree database object.</p>

<dl class="api">
<dt><code>int tcndbvsiz(TCNDB *<var>ndb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tcndbvsiz2' is used in order to get the size of the value of a string record in an on-memory tree database object.</p>

<dl class="api">
<dt><code>int tcndbvsiz2(TCNDB *<var>ndb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tcndbiterinit' is used in order to initialize the iterator of an on-memory tree database object.</p>

<dl class="api">
<dt><code>void tcndbiterinit(TCNDB *<var>ndb</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>The iterator is used in order to access the key of every record stored in the on-memory database.</dd>
</dl>

<p>The function `tcndbiternext' is used in order to get the next key of the iterator of an on-memory tree database object.</p>

<dl class="api">
<dt><code>void *tcndbiternext(TCNDB *<var>ndb</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  The order of iteration is assured to be the same as the stored order.</dd>
</dl>

<p>The function `tcndbiternext2' is used in order to get the next key string of the iterator of an on-memory tree database object.</p>

<dl class="api">
<dt><code>char *tcndbiternext2(TCNDB *<var>ndb</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  The order of iteration is assured to be the same as the stored order.</dd>
</dl>

<p>The function `tcndbfwmkeys' is used in order to get forward matching keys in an on-memory tree database object.</p>

<dl class="api">
<dt><code>TCLIST *tcndbfwmkeys(TCNDB *<var>ndb</var>, const void *<var>pbuf</var>, int <var>psiz</var>, int <var>max</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>pbuf</var>' specifies the pointer to the region of the prefix.</dd>
<dd>`<var>psiz</var>' specifies the size of the region of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcndbfwmkeys2' is used in order to get forward matching string keys in an on-memory tree database object.</p>

<dl class="api">
<dt><code>TCLIST *tcndbfwmkeys2(TCNDB *<var>ndb</var>, const char *<var>pstr</var>, int <var>max</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>pstr</var>' specifies the string of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcndbrnum' is used in order to get the number of records stored in an on-memory tree database object.</p>

<dl class="api">
<dt><code>uint64_t tcndbrnum(TCNDB *<var>ndb</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>The return value is the number of the records stored in the database.</dd>
</dl>

<p>The function `tcndbmsiz' is used in order to get the total size of memory used in an on-memory tree database object.</p>

<dl class="api">
<dt><code>uint64_t tcndbmsiz(TCNDB *<var>ndb</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>The return value is the total size of memory used in the database.</dd>
</dl>

<p>The function `tcndbaddint' is used in order to add an integer to a record in an on-memory tree database object.</p>

<dl class="api">
<dt><code>int tcndbaddint(TCNDB *<var>ndb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int <var>num</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>The return value is the summation value.</dd>
<dd>If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcndbadddouble' is used in order to add a real number to a record in an on-memory tree database object.</p>

<dl class="api">
<dt><code>double tcndbadddouble(TCNDB *<var>ndb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, double <var>num</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>The return value is the summation value.</dd>
<dd>If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcndbvanish' is used in order to clear an on-memory tree database object.</p>

<dl class="api">
<dt><code>void tcndbvanish(TCNDB *<var>ndb</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>All records are removed.</dd>
</dl>

<p>The function `tcndbcutfringe' is used in order to remove fringe records of an on-memory tree database object.</p>

<dl class="api">
<dt><code>void tcndbcutfringe(TCNDB *<var>ndb</var>, int <var>num</var>);</code></dt>
<dd>`<var>ndb</var>' specifies the on-memory tree database object.</dd>
<dd>`<var>num</var>' specifies the number of records to be removed.</dd>
</dl>

<h3 id="tcutilapi_mpoolapi">メモリプールのAPI（英語御免）</h3>

<p>The function `tcmpoolnew' is used in order to create a memory pool object.</p>

<dl class="api">
<dt><code>TCMPOOL *tcmpoolnew(void);</code></dt>
<dd>The return value is the new memory pool object.</dd>
</dl>

<p>The function `tcmpooldel' is used in order to delete a memory pool object.</p>

<dl class="api">
<dt><code>void tcmpooldel(TCMPOOL *<var>mpool</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tcmpoolpush' is used in order to relegate an arbitrary object to a memory pool object.</p>

<dl class="api">
<dt><code>void *tcmpoolpush(TCMPOOL *<var>mpool</var>, void *<var>ptr</var>, void (*<var>del</var>)(void *));</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the object to be relegated.  If it is `NULL', this function has no effect.</dd>
<dd>`<var>del</var>' specifies the pointer to the function to delete the object.</dd>
<dd>The return value is the pointer to the given object.</dd>
<dd>This function assures that the specified object is deleted when the memory pool object is deleted.</dd>
</dl>

<p>The function `tcmpoolpushptr' is used in order to relegate an allocated region to a memory pool object.</p>

<dl class="api">
<dt><code>void *tcmpoolpushptr(TCMPOOL *<var>mpool</var>, void *<var>ptr</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region to be relegated.  If it is `NULL', this function has no effect.</dd>
<dd>The return value is the pointer to the given object.</dd>
<dd>This function assures that the specified region is released when the memory pool object is deleted.</dd>
</dl>

<p>The function `tcmpoolpushxstr' is used in order to relegate an extensible string object to a memory pool object.</p>

<dl class="api">
<dt><code>TCXSTR *tcmpoolpushxstr(TCMPOOL *<var>mpool</var>, TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>`<var>xstr</var>' specifies the extensible string object.  If it is `NULL', this function has no effect.</dd>
<dd>The return value is the pointer to the given object.</dd>
<dd>This function assures that the specified object is deleted when the memory pool object is deleted.</dd>
</dl>

<p>The function `tcmpoolpushlist' is used in order to relegate a list object to a memory pool object.</p>

<dl class="api">
<dt><code>TCLIST *tcmpoolpushlist(TCMPOOL *<var>mpool</var>, TCLIST *<var>list</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>`<var>list</var>' specifies the list object.  If it is `NULL', this function has no effect.</dd>
<dd>The return value is the pointer to the given object.</dd>
<dd>This function assures that the specified object is deleted when the memory pool object is deleted.</dd>
</dl>

<p>The function `tcmpoolpushmap' is used in order to relegate a map object to a memory pool object.</p>

<dl class="api">
<dt><code>TCMAP *tcmpoolpushmap(TCMPOOL *<var>mpool</var>, TCMAP *<var>map</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>`<var>map</var>' specifies the map object.  If it is `NULL', this function has no effect.</dd>
<dd>The return value is the pointer to the given object.</dd>
<dd>This function assures that the specified object is deleted when the memory pool object is deleted.</dd>
</dl>

<p>The function `tcmpoolpushtree' is used in order to relegate a tree object to a memory pool object.</p>

<dl class="api">
<dt><code>TCTREE *tcmpoolpushtree(TCMPOOL *<var>mpool</var>, TCTREE *<var>tree</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>`<var>tree</var>' specifies the tree object.  If it is `NULL', this function has no effect.</dd>
<dd>The return value is the pointer to the given object.</dd>
<dd>This function assures that the specified object is deleted when the memory pool object is deleted.</dd>
</dl>

<p>The function `tcmpoolmalloc' is used in order to allocate a region relegated to a memory pool object.</p>

<dl class="api">
<dt><code>void *tcmpoolmalloc(TCMPOOL *<var>mpool</var>, size_t <var>size</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>The return value is the pointer to the allocated region under the memory pool.</dd>
</dl>

<p>The function `tcmpoolxstrnew' is used in order to create an extensible string object relegated to a memory pool object.</p>

<dl class="api">
<dt><code>TCXSTR *tcmpoolxstrnew(TCMPOOL *<var>mpool</var>);</code></dt>
<dd>The return value is the new extensible string object under the memory pool.</dd>
</dl>

<p>The function `tcmpoollistnew' is used in order to create a list object relegated to a memory pool object.</p>

<dl class="api">
<dt><code>TCLIST *tcmpoollistnew(TCMPOOL *<var>mpool</var>);</code></dt>
<dd>The return value is the new list object under the memory pool.</dd>
</dl>

<p>The function `tcmpoolmapnew' is used in order to create a map object relegated to a memory pool object.</p>

<dl class="api">
<dt><code>TCMAP *tcmpoolmapnew(TCMPOOL *<var>mpool</var>);</code></dt>
<dd>The return value is the new map object under the memory pool.</dd>
</dl>

<p>The function `tcmpooltreenew' is used in order to create a tree object relegated to a memory pool object.</p>

<dl class="api">
<dt><code>TCTREE *tcmpooltreenew(TCMPOOL *<var>mpool</var>);</code></dt>
<dd>The return value is the new tree object under the memory pool.</dd>
</dl>

<p>The function `tcmpoolpop' is used in order to remove the most recently installed cleanup handler of a memory pool object.</p>

<dl class="api">
<dt><code>void tcmpoolpop(TCMPOOL *<var>mpool</var>, bool <var>exe</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>`<var>exe</var>' specifies whether to execute the destructor of the removed handler.</dd>
</dl>

<p>The function `tcmpoolclear' is used in order to remove all cleanup handler of a memory pool object.</p>

<dl class="api">
<dt><code>void tcmpoolclear(TCMPOOL *<var>mpool</var>, bool <var>exe</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>`<var>exe</var>' specifies whether to execute the destructors of the removed handlers.</dd>
</dl>

<p>The function `tcmpoolglobal' is used in order to get the global memory pool object.</p>

<dl class="api">
<dt><code>TCMPOOL *tcmpoolglobal(void);</code></dt>
<dd>The return value is the global memory pool object.</dd>
<dd>The global memory pool object is a singleton and assured to be deleted when the process is terminating normally.</dd>
</dl>

<h3 id="tcutilapi_miscapi">雑多なユーティリティのAPI（英語御免）</h3>

<p>The function `tclmax' is used in order to get the larger value of two integers.</p>

<dl class="api">
<dt><code>long tclmax(long <var>a</var>, long <var>b</var>);</code></dt>
<dd>`<var>a</var>' specifies an integer.</dd>
<dd>`<var>b</var>' specifies the other integer.</dd>
<dd>The return value is the larger value of the two.</dd>
</dl>

<p>The function `tclmin' is used in order to get the lesser value of two integers.</p>

<dl class="api">
<dt><code>long tclmin(long <var>a</var>, long <var>b</var>);</code></dt>
<dd>`<var>a</var>' specifies an integer.</dd>
<dd>`<var>b</var>' specifies the other integer.</dd>
<dd>The return value is the lesser value of the two.</dd>
</dl>

<p>The function `tclrand' is used in order to get a random number as long integer based on uniform distribution.</p>

<dl class="api">
<dt><code>unsigned long tclrand(void);</code></dt>
<dd>The return value is the random number between 0 and `ULONG_MAX'.</dd>
<dd>This function uses the random number source device and generates a real random number if possible.</dd>
</dl>

<p>The function `tcdrand' is used in order to get a random number as double decimal based on uniform distribution.</p>

<dl class="api">
<dt><code>double tcdrand(void);</code></dt>
<dd>The return value is the random number equal to or greater than 0, and less than 1.0.</dd>
<dd>This function uses the random number source device and generates a real random number if possible.</dd>
</dl>

<p>The function `tcdrandnd' is used in order to get a random number as double decimal based on normal distribution.</p>

<dl class="api">
<dt><code>double tcdrandnd(double <var>avg</var>, double <var>sd</var>);</code></dt>
<dd>`<var>avg</var>' specifies the average.</dd>
<dd>`<var>sd</var>' specifies the standard deviation.</dd>
<dd>The return value is the random number.</dd>
<dd>This function uses the random number source device and generates a real random number if possible.</dd>
</dl>

<p>The function `tcstricmp' is used in order to compare two strings with case insensitive evaluation.</p>

<dl class="api">
<dt><code>int tcstricmp(const char *<var>astr</var>, const char *<var>bstr</var>);</code></dt>
<dd>`<var>astr</var>' specifies a string.</dd>
<dd>`<var>bstr</var>' specifies of the other string.</dd>
<dd>The return value is positive if the former is big, negative if the latter is big, 0 if both are equivalent.</dd>
</dl>

<p>The function `tcstrfwm' is used in order to check whether a string begins with a key.</p>

<dl class="api">
<dt><code>bool tcstrfwm(const char *<var>str</var>, const char *<var>key</var>);</code></dt>
<dd>`<var>str</var>' specifies the target string.</dd>
<dd>`<var>key</var>' specifies the forward matching key string.</dd>
<dd>The return value is true if the target string begins with the key, else, it is false.</dd>
</dl>

<p>The function `tcstrifwm' is used in order to check whether a string begins with a key with case insensitive evaluation.</p>

<dl class="api">
<dt><code>bool tcstrifwm(const char *<var>str</var>, const char *<var>key</var>);</code></dt>
<dd>`<var>str</var>' specifies the target string.</dd>
<dd>`<var>key</var>' specifies the forward matching key string.</dd>
<dd>The return value is true if the target string begins with the key, else, it is false.</dd>
</dl>

<p>The function `tcstrbwm' is used in order to check whether a string ends with a key.</p>

<dl class="api">
<dt><code>bool tcstrbwm(const char *<var>str</var>, const char *<var>key</var>);</code></dt>
<dd>`<var>str</var>' specifies the target string.</dd>
<dd>`<var>key</var>' specifies the backward matching key string.</dd>
<dd>The return value is true if the target string ends with the key, else, it is false.</dd>
</dl>

<p>The function `tcstribwm' is used in order to check whether a string ends with a key with case insensitive evaluation.</p>

<dl class="api">
<dt><code>bool tcstribwm(const char *<var>str</var>, const char *<var>key</var>);</code></dt>
<dd>`<var>str</var>' specifies the target string.</dd>
<dd>`<var>key</var>' specifies the backward matching key string.</dd>
<dd>The return value is true if the target string ends with the key, else, it is false.</dd>
</dl>

<p>The function `tcstrdist' is used in order to calculate the edit distance of two strings.</p>

<dl class="api">
<dt><code>int tcstrdist(const char *<var>astr</var>, const char *<var>bstr</var>);</code></dt>
<dd>`<var>astr</var>' specifies a string.</dd>
<dd>`<var>bstr</var>' specifies of the other string.</dd>
<dd>The return value is the edit distance which is known as the Levenshtein distance.  The cost is calculated by byte.</dd>
</dl>

<p>The function `tcstrdistutf' is used in order to calculate the edit distance of two UTF-8 strings.</p>

<dl class="api">
<dt><code>int tcstrdistutf(const char *<var>astr</var>, const char *<var>bstr</var>);</code></dt>
<dd>`<var>astr</var>' specifies a string.</dd>
<dd>`<var>bstr</var>' specifies of the other string.</dd>
<dd>The return value is the edit distance which is known as the Levenshtein distance.  The cost is calculated by Unicode character.</dd>
</dl>

<p>The function `tcstrtoupper' is used in order to convert the letters of a string into upper case.</p>

<dl class="api">
<dt><code>char *tcstrtoupper(char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string to be converted.</dd>
<dd>The return value is the string itself.</dd>
</dl>

<p>The function `tcstrtolower' is used in order to convert the letters of a string into lower case.</p>

<dl class="api">
<dt><code>char *tcstrtolower(char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string to be converted.</dd>
<dd>The return value is the string itself.</dd>
</dl>

<p>The function `tcstrtrim' is used in order to cut space characters at head or tail of a string.</p>

<dl class="api">
<dt><code>char *tcstrtrim(char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string to be converted.</dd>
<dd>The return value is the string itself.</dd>
</dl>

<p>The function `tcstrsqzspc' is used in order to squeeze space characters in a string and trim it.</p>

<dl class="api">
<dt><code>char *tcstrsqzspc(char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string to be converted.</dd>
<dd>The return value is the string itself.</dd>
</dl>

<p>The function `tcstrsubchr' is used in order to substitute characters in a string.</p>

<dl class="api">
<dt><code>char *tcstrsubchr(char *<var>str</var>, const char *<var>rstr</var>, const char *<var>sstr</var>);</code></dt>
<dd>`<var>str</var>' specifies the string to be converted.</dd>
<dd>`<var>rstr</var>' specifies the string containing characters to be replaced.</dd>
<dd>`<var>sstr</var>' specifies the string containing characters to be substituted.</dd>
<dd>If the substitute string is shorter then the replacement string, corresponding characters are removed.</dd>
</dl>

<p>The function `tcstrcntutf' is used in order to count the number of characters in a string of UTF-8.</p>

<dl class="api">
<dt><code>int tcstrcntutf(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string of UTF-8.</dd>
<dd>The return value is the number of characters in the string.</dd>
</dl>

<p>The function `tcstrcututf' is used in order to cut a string of UTF-8 at the specified number of characters.</p>

<dl class="api">
<dt><code>char *tcstrcututf(char *<var>str</var>, int <var>num</var>);</code></dt>
<dd>`<var>str</var>' specifies the string of UTF-8.</dd>
<dd>`<var>num</var>' specifies the number of characters to be kept.</dd>
<dd>The return value is the string itself.</dd>
</dl>

<p>The function `tcstrutftoucs' is used in order to convert a UTF-8 string into a UCS-2 array.</p>

<dl class="api">
<dt><code>void tcstrutftoucs(const char *<var>str</var>, uint16_t *<var>ary</var>, int *<var>np</var>);</code></dt>
<dd>`<var>str</var>' specifies the UTF-8 string.</dd>
<dd>`<var>ary</var>' specifies the pointer to the region into which the result UCS-2 codes are written.  The size of the buffer should be sufficient.</dd>
<dd>`<var>np</var>' specifies the pointer to a variable into which the number of elements of the result array is assigned.</dd>
</dl>

<p>The function `tcstrucstoutf' is used in order to convert a UCS-2 array into a UTF-8 string.</p>

<dl class="api">
<dt><code>int tcstrucstoutf(const uint16_t *<var>ary</var>, int <var>num</var>, char *<var>str</var>);</code></dt>
<dd>`<var>ary</var>' specifies the array of UCS-2 codes.</dd>
<dd>`<var>num</var>' specifies the number of the array.</dd>
<dd>`<var>str</var>' specifies the pointer to the region into which the result UTF-8 string is written.  The size of the buffer should be sufficient.</dd>
<dd>The return value is the length of the result string.</dd>
</dl>

<p>The function `tcstrsplit' is used in order to create a list object by splitting a string.</p>

<dl class="api">
<dt><code>TCLIST *tcstrsplit(const char *<var>str</var>, const char *<var>delims</var>);</code></dt>
<dd>`<var>str</var>' specifies the source string.</dd>
<dd>`<var>delims</var>' specifies a string containing delimiting characters.</dd>
<dd>The return value is a list object of the split elements.</dd>
<dd>If two delimiters are successive, it is assumed that an empty element is between the two.  Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcstrjoin' is used in order to create a string by joining all elements of a list object.</p>

<dl class="api">
<dt><code>char *tcstrjoin(const TCLIST *<var>list</var>, char <var>delim</var>);</code></dt>
<dd>`<var>list</var>' specifies a list object.</dd>
<dd>`<var>delim</var>' specifies a delimiting character.</dd>
<dd>The return value is the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcatoi' is used in order to convert a string to an integer.</p>

<dl class="api">
<dt><code>int64_t tcatoi(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string.</dd>
<dd>The return value is the integer.  If the string does not contain numeric expression, 0 is returned.</dd>
<dd>This function is equivalent to `atoll' except that it does not depend on the locale.</dd>
</dl>

<p>The function `tcatoix' is used in order to convert a string with a metric prefix to an integer.</p>

<dl class="api">
<dt><code>int64_t tcatoix(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string, which can be trailed by a binary metric prefix.  "K", "M", "G", "T", "P", and "E" are supported.  They are case-insensitive.</dd>
<dd>The return value is the integer.  If the string does not contain numeric expression, 0 is returned.  If the integer overflows the domain, `INT64_MAX' or `INT64_MIN' is returned according to the sign.</dd>
</dl>

<p>The function `tcatof' is used in order to convert a string to a real number.</p>

<dl class="api">
<dt><code>double tcatof(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string.</dd>
<dd>The return value is the real number.  If the string does not contain numeric expression, 0.0 is returned.</dd>
<dd>This function is equivalent to `atof' except that it does not depend on the locale.</dd>
</dl>

<p>The function `tcregexmatch' is used in order to check whether a string matches a regular expression.</p>

<dl class="api">
<dt><code>bool tcregexmatch(const char *<var>str</var>, const char *<var>regex</var>);</code></dt>
<dd>`<var>str</var>' specifies the target string.</dd>
<dd>`<var>regex</var>' specifies the regular expression string.  If it begins with `*', the trailing substring is used as a case-insensitive regular expression.</dd>
<dd>The return value is true if matching is success, else, it is false.</dd>
</dl>

<p>The function `tcregexreplace' is used in order to replace each substring matching a regular expression string.</p>

<dl class="api">
<dt><code>char *tcregexreplace(const char *<var>str</var>, const char *<var>regex</var>, const char *<var>alt</var>);</code></dt>
<dd>`<var>str</var>' specifies the target string.</dd>
<dd>`<var>regex</var>' specifies the regular expression string for substrings.  If it begins with `*', the trailing substring is used as a case-insensitive regular expression.</dd>
<dd>`<var>alt</var>' specifies the alternative string with which each substrings is replaced.  Each `&amp;' in the string is replaced with the matched substring.  Each `\' in the string escapes the following character.  Special escapes "\1" through "\9" referring to the corresponding matching sub-expressions in the regular expression string are supported.</dd>
<dd>The return value is a new converted string.  Even if the regular expression is invalid, a copy of the original string is returned.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmd5hash' is used in order to get the MD5 hash value of a serial object.</p>

<dl class="api">
<dt><code>void tcmd5hash(const void *<var>ptr</var>, int <var>size</var>, char *<var>buf</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>buf</var>' specifies the pointer to the region into which the result string is written.  The size of the buffer should be equal to or more than 48 bytes.</dd>
</dl>

<p>The function `tcarccipher' is used in order to cipher or decipher a serial object with the Arcfour stream cipher.</p>

<dl class="api">
<dt><code>void tcarccipher(const void *<var>ptr</var>, int <var>size</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, void *<var>obuf</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the cipher key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the cipher key.</dd>
<dd>`<var>obuf</var>' specifies the pointer to the region into which the result data is written.  The size of the buffer should be equal to or more than the input region.</dd>
</dl>

<p>The function `tctime' is used in order to get the time of day in seconds.</p>

<dl class="api">
<dt><code>double tctime(void);</code></dt>
<dd>The return value is the time of day in seconds.  The accuracy is in microseconds.</dd>
</dl>

<p>The function `tccalendar' is used in order to get the Gregorian calendar of a time.</p>

<dl class="api">
<dt><code>void tccalendar(int64_t <var>t</var>, int <var>jl</var>, int *<var>yearp</var>, int *<var>monp</var>, int *<var>dayp</var>, int *<var>hourp</var>, int *<var>minp</var>, int *<var>secp</var>);</code></dt>
<dd>`<var>t</var>' specifies the source time in seconds from the epoch.  If it is `INT64_MAX', the current time is specified.</dd>
<dd>`<var>jl</var>' specifies the jet lag of a location in seconds.  If it is `INT_MAX', the local jet lag is specified.</dd>
<dd>`<var>yearp</var>' specifies the pointer to a variable to which the year is assigned.  If it is `NULL', it is not used.</dd>
<dd>`<var>monp</var>' specifies the pointer to a variable to which the month is assigned.  If it is `NULL', it is not used.  1 means January and 12 means December.</dd>
<dd>`<var>dayp</var>' specifies the pointer to a variable to which the day of the month is assigned.  If it is `NULL', it is not used.</dd>
<dd>`<var>hourp</var>' specifies the pointer to a variable to which the hours is assigned.  If it is `NULL', it is not used.</dd>
<dd>`<var>minp</var>' specifies the pointer to a variable to which the minutes is assigned.  If it is `NULL', it is not used.</dd>
<dd>`<var>secp</var>' specifies the pointer to a variable to which the seconds is assigned.  If it is `NULL', it is not used.</dd>
</dl>

<p>The function `tcdatestrwww' is used in order to format a date as a string in W3CDTF.</p>

<dl class="api">
<dt><code>void tcdatestrwww(int64_t <var>t</var>, int <var>jl</var>, char *<var>buf</var>);</code></dt>
<dd>`<var>t</var>' specifies the source time in seconds from the epoch.  If it is `INT64_MAX', the current time is specified.</dd>
<dd>`<var>jl</var>' specifies the jet lag of a location in seconds.  If it is `INT_MAX', the local jet lag is specified.</dd>
<dd>`<var>buf</var>' specifies the pointer to the region into which the result string is written.  The size of the buffer should be equal to or more than 48 bytes.</dd>
<dd>W3CDTF represents a date as "YYYY-MM-DDThh:mm:ddTZD".</dd>
</dl>

<p>The function `tcdatestrhttp' is used in order to format a date as a string in RFC 1123 format.</p>

<dl class="api">
<dt><code>void tcdatestrhttp(int64_t <var>t</var>, int <var>jl</var>, char *<var>buf</var>);</code></dt>
<dd>`<var>t</var>' specifies the source time in seconds from the epoch.  If it is `INT64_MAX', the current time is specified.</dd>
<dd>`<var>jl</var>' specifies the jet lag of a location in seconds.  If it is `INT_MAX', the local jet lag is specified.</dd>
<dd>`<var>buf</var>' specifies the pointer to the region into which the result string is written.  The size of the buffer should be equal to or more than 48 bytes.</dd>
<dd>RFC 1123 format represents a date as "Wdy, DD-Mon-YYYY hh:mm:dd TZD".</dd>
</dl>

<p>The function `tcstrmktime' is used in order to get the time value of a date string.</p>

<dl class="api">
<dt><code>int64_t tcstrmktime(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the date string in decimal, hexadecimal, W3CDTF, or RFC 822 (1123).  Decimal can be trailed by "s" for in seconds, "m" for in minutes, "h" for in hours, and "d" for in days.</dd>
<dd>The return value is the time value of the date or `INT64_MIN' if the format is invalid.</dd>
</dl>

<p>The function `tcjetlag' is used in order to get the jet lag of the local time.</p>

<dl class="api">
<dt><code>int tcjetlag(void);</code></dt>
<dd>The return value is the jet lag of the local time in seconds.</dd>
</dl>

<p>The function `tcdayofweek' is used in order to get the day of week of a date.</p>

<dl class="api">
<dt><code>int tcdayofweek(int <var>year</var>, int <var>mon</var>, int <var>day</var>);</code></dt>
<dd>`<var>year</var>' specifies the year of a date.</dd>
<dd>`<var>mon</var>' specifies the month of the date.</dd>
<dd>`<var>day</var>' specifies the day of the date.</dd>
<dd>The return value is the day of week of the date.  0 means Sunday and 6 means Saturday.</dd>
</dl>

<h3 id="tcutilapi_fsapi">ファイルシステム関連ユーティリティのAPI（英語御免）</h3>

<p>The function `tcrealpath' is used in order to get the canonicalized absolute path of a file.</p>

<dl class="api">
<dt><code>char *tcrealpath(const char *<var>path</var>);</code></dt>
<dd>`<var>path</var>' specifies the path of the file.</dd>
<dd>The return value is the canonicalized absolute path of a file, or `NULL' if the path is invalid.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcstatfile' is used in order to get the status information of a file.</p>

<dl class="api">
<dt><code>bool tcstatfile(const char *<var>path</var>, bool *<var>isdirp</var>, int64_t *<var>sizep</var>, int64_t *<var>mtimep</var>);</code></dt>
<dd>`<var>path</var>' specifies the path of the file.</dd>
<dd>`<var>isdirp</var>' specifies the pointer to a variable into which whether the file is a directory is assigned.  If it is `NULL', it is ignored.</dd>
<dd>`<var>sizep</var>' specifies the pointer to a variable into which the size of the file is assigned.  If it is `NULL', it is ignored.</dd>
<dd>`<var>ntimep</var>' specifies the pointer to a variable into which the size of the file is assigned.  If it is `NULL', it is ignored.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcreadfile' is used in order to read whole data of a file.</p>

<dl class="api">
<dt><code>void *tcreadfile(const char *<var>path</var>, int <var>limit</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>path</var>' specifies the path of the file.  If it is `NULL', the standard input is specified.</dd>
<dd>`<var>limit</var>' specifies the limiting size of reading data.  If it is not more than 0, the limitation is not specified.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.  If it is `NULL', it is not used.</dd>
<dd>The return value is the pointer to the allocated region of the read data, or `NULL' if the file could not be opened.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when when is no longer in use.</dd>
</dl>

<p>The function `tcreadfilelines' is used in order to read every line of a file.</p>

<dl class="api">
<dt><code>TCLIST *tcreadfilelines(const char *<var>path</var>);</code></dt>
<dd>`<var>path</var>' specifies the path of the file.  If it is `NULL', the standard input is specified.</dd>
<dd>The return value is a list object of every lines if successful, else it is `NULL'.</dd>
<dd>Line separators are cut out.  Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcwritefile' is used in order to write data into a file.</p>

<dl class="api">
<dt><code>bool tcwritefile(const char *<var>path</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>path</var>' specifies the path of the file.  If it is `NULL', the standard output is specified.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the data region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tccopyfile' is used in order to copy a file.</p>

<dl class="api">
<dt><code>bool tccopyfile(const char *<var>src</var>, const char *<var>dest</var>);</code></dt>
<dd>`<var>src</var>' specifies the path of the source file.</dd>
<dd>`<var>dest</var>' specifies the path of the destination file.</dd>
<dd>The return value is true if successful, else, it is false.</dd>
<dd>If the destination file exists, it is overwritten.</dd>
</dl>

<p>The function `tcreaddir' is used in order to read names of files in a directory.</p>

<dl class="api">
<dt><code>TCLIST *tcreaddir(const char *<var>path</var>);</code></dt>
<dd>`<var>path</var>' specifies the path of the directory.</dd>
<dd>The return value is a list object of names if successful, else it is `NULL'.</dd>
<dd>Links to the directory itself and to the parent directory are ignored.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcglobpat' is used in order to expand a pattern into a list of matched paths.</p>

<dl class="api">
<dt><code>TCLIST *tcglobpat(const char *<var>pattern</var>);</code></dt>
<dd>`<var>pattern</var>' specifies the matching pattern.</dd>
<dd>The return value is a list object of matched paths.  If no path is matched, an empty list is returned.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcremovelink' is used in order to remove a file or a directory and its sub ones recursively.</p>

<dl class="api">
<dt><code>bool tcremovelink(const char *<var>path</var>);</code></dt>
<dd>`<var>path</var>' specifies the path of the link.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned when the link does not exist or the permission is denied.</dd>
</dl>

<p>The function `tcwrite' is used in order to write data into a file.</p>

<dl class="api">
<dt><code>bool tcwrite(int <var>fd</var>, const void *<var>buf</var>, size_t <var>size</var>);</code></dt>
<dd>`<var>fd</var>' specifies the file descriptor.</dd>
<dd>`<var>buf</var>' specifies the buffer to be written.</dd>
<dd>`<var>size</var>' specifies the size of the buffer.</dd>
<dd>The return value is true if successful, else, it is false.</dd>
</dl>

<p>The function `tcread' is used in order to read data from a file.</p>

<dl class="api">
<dt><code>bool tcread(int <var>fd</var>, void *<var>buf</var>, size_t <var>size</var>);</code></dt>
<dd>`<var>fd</var>' specifies the file descriptor.</dd>
<dd>`<var>buf</var>' specifies the buffer to store into.</dd>
<dd>`<var>size</var>' specifies the size of the buffer.</dd>
<dd>The return value is true if successful, else, it is false.</dd>
</dl>

<p>The function `tclock' is used in order to lock a file.</p>

<dl class="api">
<dt><code>bool tclock(int <var>fd</var>, bool <var>ex</var>, bool <var>nb</var>);</code></dt>
<dd>`<var>fd</var>' specifies the file descriptor.</dd>
<dd>`<var>ex</var>' specifies whether an exclusive lock or a shared lock is performed.</dd>
<dd>`<var>nb</var>' specifies whether to request with non-blocking.</dd>
<dd>The return value is true if successful, else, it is false.</dd>
</dl>

<p>The function `tcunlock' is used in order to unlock a file.</p>

<dl class="api">
<dt><code>bool tcunlock(int <var>fd</var>);</code></dt>
<dd>`<var>fd</var>' specifies the file descriptor.</dd>
<dd>The return value is true if successful, else, it is false.</dd>
</dl>

<p>The function `tcsystem' is used in order to execute a shell command.</p>

<dl class="api">
<dt><code>int tcsystem(const char **<var>args</var>, int <var>anum</var>);</code></dt>
<dd>`<var>args</var>' specifies an array of the command name and its arguments.</dd>
<dd>`<var>anum</var>' specifies the number of elements of the array.</dd>
<dd>The return value is the exit code of the command or `INT_MAX' on failure.</dd>
<dd>The command name and the arguments are quoted and meta characters are escaped.</dd>
</dl>

<h3 id="tcutilapi_encapi">エンコーディング関連ユーティリティののAPI（英語御免）</h3>

<p>The function `tcurlencode' is used in order to encode a serial object with URL encoding.</p>

<dl class="api">
<dt><code>char *tcurlencode(const char *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</dd>
</dl>

<p>The function `tcurldecode' is used in order to decode a string encoded with URL encoding.</p>

<dl class="api">
<dt><code>char *tcurldecode(const char *<var>str</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>str</var>' specifies the encoded string.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the result.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcurlbreak' is used in order to break up a URL into elements.</p>

<dl class="api">
<dt><code>TCMAP *tcurlbreak(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the URL string.</dd>
<dd>The return value is the map object whose keys are the name of elements.  The key "self" indicates the URL itself.  The key "scheme" indicates the scheme.  The key "host" indicates the host of the server.  The key "port" indicates the port number of the server.  The key "authority" indicates the authority information.  The key "path" indicates the path of the resource.  The key "file" indicates the file name without the directory section.  The key "query" indicates the query string.  The key "fragment" indicates the fragment string.</dd>
<dd>Supported schema are HTTP, HTTPS, FTP, and FILE.  Absolute URL and relative URL are supported.  Because the object of the return value is created with the function `tcmapnew', it should be deleted with the function `tcmapdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcurlresolve' is used in order to resolve a relative URL with an absolute URL.</p>

<dl class="api">
<dt><code>char *tcurlresolve(const char *<var>base</var>, const char *<var>target</var>);</code></dt>
<dd>`<var>base</var>' specifies the absolute URL of the base location.</dd>
<dd>`<var>target</var>' specifies the URL to be resolved.</dd>
<dd>The return value is the resolved URL.  If the target URL is relative, a new URL of relative location from the base location is returned.  Else, a copy of the target URL is returned.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbaseencode' is used in order to encode a serial object with Base64 encoding.</p>

<dl class="api">
<dt><code>char *tcbaseencode(const char *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</dd>
</dl>

<p>The function `tcbasedecode' is used in order to decode a string encoded with Base64 encoding.</p>

<dl class="api">
<dt><code>char *tcbasedecode(const char *<var>str</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>str</var>' specifies the encoded string.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the result.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcquoteencode' is used in order to encode a serial object with Quoted-printable encoding.</p>

<dl class="api">
<dt><code>char *tcquoteencode(const char *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</dd>
</dl>

<p>The function `tcquotedecode' is used in order to decode a string encoded with Quoted-printable encoding.</p>

<dl class="api">
<dt><code>char *tcquotedecode(const char *<var>str</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>str</var>' specifies the encoded string.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the result.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmimeencode' is used in order to encode a string with MIME encoding.</p>

<dl class="api">
<dt><code>char *tcmimeencode(const char *<var>str</var>, const char *<var>encname</var>, bool <var>base</var>);</code></dt>
<dd>`<var>str</var>' specifies the string.</dd>
<dd>`<var>encname</var>' specifies the string of the name of the character encoding.</dd>
<dd>`<var>base</var>' specifies whether to use Base64 encoding.  If it is false, Quoted-printable is used.</dd>
<dd>The return value is the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmimedecode' is used in order to decode a string encoded with MIME encoding.</p>

<dl class="api">
<dt><code>char *tcmimedecode(const char *<var>str</var>, char *<var>enp</var>);</code></dt>
<dd>`<var>str</var>' specifies the encoded string.</dd>
<dd>`<var>enp</var>' specifies the pointer to the region into which the name of encoding is written.  If it is `NULL', it is not used.  The size of the buffer should be equal to or more than 32 bytes.</dd>
<dd>The return value is the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmimebreak' is used in order to split a string of MIME into headers and the body.</p>

<dl class="api">
<dt><code>char *tcmimebreak(const char *<var>ptr</var>, int <var>size</var>, TCMAP *<var>headers</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region of MIME data.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>headers</var>' specifies a map object to store headers.  If it is `NULL', it is not used.  Each key of the map is an uncapitalized header name.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the body data.</dd>
<dd>If the content type is defined, the header map has the key "TYPE" specifying the type.  If the character encoding is defined, the key "CHARSET" indicates the encoding name.  If the boundary string of multipart is defined, the key "BOUNDARY" indicates the string.  If the content disposition is defined, the key "DISPOSITION" indicates the direction.  If the file name is defined, the key "FILENAME" indicates the name.  If the attribute name is defined, the key "NAME" indicates the name.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmimeparts' is used in order to split multipart data of MIME into its parts.</p>

<dl class="api">
<dt><code>TCLIST *tcmimeparts(const char *<var>ptr</var>, int <var>size</var>, const char *<var>boundary</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region of multipart data of MIME.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>boundary</var>' specifies the boundary string.</dd>
<dd>The return value is a list object.  Each element of the list is the data of a part.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tchexencode' is used in order to encode a serial object with hexadecimal encoding.</p>

<dl class="api">
<dt><code>char *tchexencode(const char *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</dd>
</dl>

<p>The function `tchexdecode' is used in order to decode a string encoded with hexadecimal encoding.</p>

<dl class="api">
<dt><code>char *tchexdecode(const char *<var>str</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>str</var>' specifies the encoded string.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return</dd>
<dd>value is assigned.</dd>
<dd>The return value is the pointer to the region of the result.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcpackencode' is used in order to compress a serial object with Packbits encoding.</p>

<dl class="api">
<dt><code>char *tcpackencode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcpackdecode' is used in order to decompress a serial object compressed with Packbits encoding.</p>

<dl class="api">
<dt><code>char *tcpackdecode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbsencode' is used in order to compress a serial object with TCBS encoding.</p>

<dl class="api">
<dt><code>char *tcbsencode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbsdecode' is used in order to decompress a serial object compressed with TCBS encoding.</p>

<dl class="api">
<dt><code>char *tcbsdecode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcdeflate' is used in order to compress a serial object with Deflate encoding.</p>

<dl class="api">
<dt><code>char *tcdeflate(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcinflate' is used in order to decompress a serial object compressed with Deflate encoding.</p>

<dl class="api">
<dt><code>char *tcinflate(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcgzipencode' is used in order to compress a serial object with GZIP encoding.</p>

<dl class="api">
<dt><code>char *tcgzipencode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcgzipdecode' is used in order to decompress a serial object compressed with GZIP encoding.</p>

<dl class="api">
<dt><code>char *tcgzipdecode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcgetcrc' is used in order to get the CRC32 checksum of a serial object.</p>

<dl class="api">
<dt><code>unsigned int tcgetcrc(const char *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the CRC32 checksum of the object.</dd>
</dl>

<p>The function `tcbzipencode' is used in order to compress a serial object with BZIP2 encoding.</p>

<dl class="api">
<dt><code>char *tcbzipencode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbzipdecode' is used in order to decompress a serial object compressed with BZIP2 encoding.</p>

<dl class="api">
<dt><code>char *tcbzipdecode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcberencode' is used in order to encode an array of nonnegative integers with BER encoding.</p>

<dl class="api">
<dt><code>char *tcberencode(const unsigned int *<var>ary</var>, int <var>anum</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ary</var>' specifies the pointer to the array of nonnegative integers.</dd>
<dd>`<var>anum</var>' specifies the size of the array.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the result.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</dd>
</dl>

<p>The function `tcberdecode' is used in order to decode a serial object encoded with BER encoding.</p>

<dl class="api">
<dt><code>unsigned int *tcberdecode(const char *<var>ptr</var>, int <var>size</var>, int *<var>np</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>np</var>' specifies the pointer to a variable into which the number of elements of the return value is assigned.</dd>
<dd>The return value is the pointer to the array of the result.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</dd>
</dl>

<p>The function `tcxmlescape' is used in order to escape meta characters in a string with the entity references of XML.</p>

<dl class="api">
<dt><code>char *tcxmlescape(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string.</dd>
<dd>The return value is the pointer to the escaped string.</dd>
<dd>This function escapes only `&amp;', `&lt;', `&gt;', and `&quot;'.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcxmlunescape' is used in order to unescape entity references in a string of XML.</p>

<dl class="api">
<dt><code>char *tcxmlunescape(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string.</dd>
<dd>The return value is the unescaped string.</dd>
<dd>This function restores only `&amp;amp;', `&amp;lt;', `&amp;gt;', and `&amp;quot;'.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<h3 id="tcutilapi_example">コード例</h3>

<p>拡張可能文字列と配列リストとハッシュマップを使ったコード例を以下に示します。</p>

<pre>#include &lt;tcutil.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char **argv){

  { /* 拡張可能文字列オブジェクトの使用例 */
    TCXSTR *xstr;
    /* オブジェクトを作成する */
    xstr = tcxstrnew();
    /* 文字列を連結する */
    tcxstrcat2(xstr, "hop");
    tcxstrcat2(xstr, "step");
    tcxstrcat2(xstr, "jump");
    /* サイズと内容を印字する */
    printf("%d:%s\n", tcxstrsize(xstr), (char *)tcxstrptr(xstr));
    /* オブジェクトを破棄する */
    tcxstrdel(xstr);
  }

  { /* リストオブジェクトの使用例 */
    TCLIST *list;
    int i;
    /* オブジェクトを作成する */
    list = tclistnew();
    /* 末尾に文字列を追加する */
    tclistpush2(list, "hop");
    tclistpush2(list, "step");
    tclistpush2(list, "jump");
    /* 全ての要素を印字する */
    for(i = 0; i &lt; tclistnum(list); i++){
      printf("%d:%s\n", i, tclistval2(list, i));
    }
    /* オブジェクトを破棄する */
    tclistdel(list);
  }

  { /* マップオブジェクトの使用例 */
    TCMAP *map;
    const char *key;
    /* オブジェクトを作成する */
    map = tcmapnew();
    /* レコードを追加する */
    tcmapput2(map, "foo", "hop");
    tcmapput2(map, "bar", "step");
    tcmapput2(map, "baz", "jump");
    /* 全てのレコードを印字する */
    tcmapiterinit(map);
    while((key = tcmapiternext2(map)) != NULL){
      printf("%s:%s\n", key, tcmapget2(map, key));
    }
    /* オブジェクトを破棄する */
    tcmapdel(map);
  }

  { /* マップオブジェクトの使用例 */
    TCTREE *tree;
    const char *key;
    /* オブジェクトを作成する */
    tree = tctreenew();
    /* レコードを追加する */
    tctreeput2(tree, "foo", "hop");
    tctreeput2(tree, "bar", "step");
    tctreeput2(tree, "baz", "jump");
    /* 全てのレコードを印字する */
    tctreeiterinit(tree);
    while((key = tctreeiternext2(tree)) != NULL){
      printf("%s:%s\n", key, tctreeget2(tree, key));
    }
    /* オブジェクトを破棄する */
    tctreedel(tree);
  }

  return 0;
}
</pre>

<h3 id="tcutilapi_cli">CLI</h3>

<p>ユーティリティAPIを簡単に利用するために、コマンドラインインターフェイスとして `<code>tcutest</code>' と `<code>tcumttest</code>'  と `<code>tcucodec</code>' が提供されます。</p>

<p>コマンド `<code>tcutest</code>' は、ユーティリティAPIの機能テストや性能テストに用いるツールです。以下の書式で用います。`<var>rnum</var>' は試行回数を指定し、`<var>anum</var>' は配列の初期容量を指定し、`<var>bnum</var>' はバケット数を指定します。</p>

<dl class="api">
<dt><code>tcutest xstr <var>rnum</var></code></dt>
<dd>拡張可能文字列に文字列を連結するテストを行います。</dd>
<dt><code>tcutest list [-rd] <var>rnum</var> [<var>anum</var>]</code></dt>
<dd>配列リストに要素を追加するテストを行います。</dd>
<dt><code>tcutest map [-rd] [-tr] [-rnd] [-dk|-dc|-dai|-dad|-dpr] <var>rnum</var> [<var>bnum</var>]</code></dt>
<dd>ハッシュマップにレコードを追加するテストを行います。</dd>
<dt><code>tcutest tree [-rd] [-tr] [-rnd] [-dk|-dc|-dai|-dad|-dpr] <var>rnum</var></code></dt>
<dd>順序木にレコードを追加するテストを行います。</dd>
<dt><code>tcutest mdb [-rd] [-tr] [-rnd] [-dk|-dc|-dai|-dad|-dpr] <var>rnum</var> [<var>bnum</var>]</code></dt>
<dd>オンメモリハッシュデータベースにレコードを追加するテストを行います。</dd>
<dt><code>tcutest ndb [-rd] [-tr] [-rnd] [-dk|-dc|-dai|-dad|-dpr] <var>rnum</var></code></dt>
<dd>オンメモリツリーデータベースにレコードを追加するテストを行います。</dd>
<dt><code>tcutest misc <var>rnum</var></code></dt>
<dd>その他の雑多なテストを行います。</dd>
<dt><code>tcutest wicked <var>rnum</var></code></dt>
<dd>配列リストとハッシュマップの各種更新操作を無作為に選択して実行するテストを行います。</dd>
</dl>

<p>各オプションは以下の機能を持ちます。</p>

<ul class="options">
<li><code>-rd</code> : 取得のテストも行う。</li>
<li><code>-tr</code> : イテレータのテストも行う。</li>
<li><code>-rnd</code> : キーを無作為に選択する。</li>
<li><code>-dk</code> : 関数 `tcxxxput' の代わりに関数 `tcxxxputkeep' を用いる。</li>
<li><code>-dc</code> : 関数 `tcxxxput' の代わりに関数 `tcxxxputcat' を用いる。</li>
<li><code>-dai</code> : 関数 `tcxxxput' の代わりに関数 `tcxxxaddint' を用いる。</li>
<li><code>-dad</code> : 関数 `tcxxxput' の代わりに関数 `tcxxxadddouble' を用いる。</li>
<li><code>-dpr</code> : 関数 `tcxxxput' の代わりに関数 `tcxxxputproc' を用いる。</li>
</ul>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<p>コマンド `<code>tcumttest</code>' は、オンメモリハッシュデータベースAPIとオンメモリツリーデータベースAPIの機能テストをマルチスレッドで行うツールです。以下の書式で用います。`<var>tnum</var>' はスレッド数を指定し、`<var>rnum</var>' は試行回数を指定し、`<var>bnum</var>' はバケット数を指定します。</p>

<dl class="api">
<dt><code>tcumttest combo [-rnd] <var>tnum</var> <var>rnum</var> [<var>bnum</var>]</code></dt>
<dd>レコードの格納と検索と削除を順に実行する。</dd>
<dt><code>tcumttest typical [-nc] [-rr <var>num</var>] <var>tnum</var> <var>rnum</var> [<var>bnum</var>]</code></dt>
<dd>典型的な操作を無作為に選択して実行する。</dd>
</dl>

<p>各オプションは以下の機能を持ちます</p>

<ul class="options">
<li><code>-rnd</code> : キーを無作為に選択する。</li>
<li><code>-nc</code> : 比較テストを行わない。</li>
<li><code>-rr <var>num</var></code> : 読み込み操作の割合を百分率で指定する。</li>
</ul>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<p>コマンド `<code>tcucodec</code>' は、ユーティリティAPIが提供するエンコードおよびデコードの機能を利用するツールです。以下の書式で用います。`<var>file</var>' は入力ファイルを指定しますが、省略されれば標準入力を読み込みます。</p>

<dl class="api">
<dt><code>tcucodec url [-d] [-br] [-rs <var>base</var>] [<var>file</var>]</code></dt>
<dd>URLエンコードとそのデコードを行う。</dd>
<dt><code>tcucodec base [-d] [<var>file</var>]</code></dt>
<dd>Base64エンコードとそのデコードを行う。</dd>
<dt><code>tcucodec quote [-d] [<var>file</var>]</code></dt>
<dd>Quoted-printableエンコードとそのデコードを行う。</dd>
<dt><code>tcucodec mime [-d] [-en <var>name</var>] [-q] [-on] [-hd] [-bd] [-part <var>num</var>] [<var>file</var>]</code></dt>
<dd>MIMEエンコードとそのデコードを行う。</dd>
<dt><code>tcucodec hex [-d] [<var>file</var>]</code></dt>
<dd>16進数エンコードとそのデコードを行う。</dd>
<dt><code>tcucodec pack [-d] [-bwt] [<var>file</var>]</code></dt>
<dd>Packbitsの圧縮とその伸長を行う。</dd>
<dt><code>tcucodec tcbs [-d] [<var>file</var>]</code></dt>
<dd>TCBSの圧縮とその伸長を行う。</dd>
<dt><code>tcucodec zlib [-d] [-gz] [<var>file</var>]</code></dt>
<dd>ZLIBの圧縮とその伸長を行う。</dd>
<dt><code>tcucodec bzip [-d] [<var>file</var>]</code></dt>
<dd>BZIP2の圧縮とその伸長を行う。</dd>
<dt><code>tcucodec xml [-d] [-br] [<var>file</var>]</code></dt>
<dd>XMLの処理を行う。デフォルトではメタ文字のエスケープを行う。</dd>
<dt><code>tcucodec cstr [-d] [-js] [<var>file</var>]</code></dt>
<dd>C文字列のエスケープとそのアンエスケープを行う。</dd>
<dt><code>tcucodec ucs [-d] [-un] [-kw <var>str</var>] [<var>file</var>]</code></dt>
<dd>UTF-8の文字列をUCS-2の配列に変換する。</dd>
<dt><code>tcucodec hash [-crc] [-ch <var>num</var>] [<var>file</var>]</code></dt>
<dd>ハッシュ値を算出する。デフォルトではMD5関数を用いる。</dd>
<dt><code>tcucodec cipher [-key <var>str</var>] [<var>file</var>]</code></dt>
<dd>ストリーム暗号化とその復号を行う。</dd>
<dt><code>tcucodec date [-ds <var>str</var>] [-jl <var>num</var>] [-wf] [-rf]</code></dt>
<dd>時刻の書式変換を行う。デフォルトでは現在のUNIX時間を出力する。</dd>
<dt><code>tcucodec tmpl [-var <var>name</var> <var>val</var>] [<var>file</var>]</code></dt>
<dd>テンプレートの直列化を行う。</dd>
<dt><code>tcucodec conf [-v|-i|-l|-p]</code></dt>
<dd>各種の設定情報を出力する。</dd>
</dl>

<p>各オプションは以下の機能を持ちます。</p>

<ul class="options">
<li><code>-d</code> : エンコード（エスケープ）ではなく、デコード（アンエスケープ）を行う。</li>
<li><code>-br</code> : URLやXMLを構成要素に分解する。</li>
<li><code>-rs <var>base</var></code> : ベースURLを指定して、相対URLを解決する。</li>
<li><code>-en <var>name</var></code> : 入力の文字コードを指定する。デフォルトはUTF-8である。</li>
<li><code>-q</code> : Quoted-printableエンコードを用いる。デフォルトはBase64である。</li>
<li><code>-on</code> : デコード時に結果でなく文字コード名を出力する。</li>
<li><code>-bd</code> : MIME解析を行ってボディを出力する。</li>
<li><code>-hd</code> : MIME解析を行ってヘッダを出力する。</li>
<li><code>-part <var>num</var></code> : MIME解析を行ってマルチパートの指定されたパートを出力する。</li>
<li><code>-bwt</code> : 前処理としてBWTを用いる。</li>
<li><code>-gz</code> : GZIP形式を用いる。</li>
<li><code>-crc</code> : CRC32関数を用いる。</li>
<li><code>-js</code> : JSON互換形式を用いる。</li>
<li><code>-un</code> : UCSの正規化を行う。</li>
<li><code>-kw <var>str</var></code> : KWIC文字列を生成する。</li>
<li><code>-ch <var>num</var></code> : コンシステントハッシュ関数を用いる。</li>
<li><code>-key <var>str</var></code> : 暗号鍵を指定する。</li>
<li><code>-ds <var>str</var></code> : 時刻を指定する。</li>
<li><code>-jl <var>num</var></code> : 時差を指定する。</li>
<li><code>-wf</code> : 出力をW3CDTF形式にする。</li>
<li><code>-rf</code> : 出力をRFC 1123形式にする。</li>
<li><code>-var <var>name</var> <var>value</var></code> : テンプレート変数を指定する。</li>
<li><code>-v</code> : Tokyo Cabinetのバージョン番号を表示する。</li>
<li><code>-i</code> : Tokyo Cabinetのヘッダのインクルードオプションを表示する。</li>
<li><code>-l</code> : Tokyo Cabinetのライブラリのリンクオプションを表示する。</li>
<li><code>-p</code> : Tokyo Cabinetのコマンドのあるディレクトリを表示する。</li>
</ul>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<hr />

<h2 id="tchdbapi">ハッシュデータベースAPI</h2>

<p>ハッシュデータベースは、ハッシュ表を単一のファイルに記録したデータベースです。それを扱うのがハッシュデータベースAPIです。`<code>tchdb.h</code>' にAPIの仕様の完全な記述があります。</p>

<h3 id="tchdbapi_description">概要</h3>

<p>ハッシュデータベースAPIを使うためには、`<code>tcutil.h</code>'、`<code>tchdb.h</code>' および関連する標準ヘッダファイルをインクルードしてください。通常、ソースファイルの冒頭付近で以下の記述を行います。</p>

<dl>
<dt><code>#include &lt;tcutil.h&gt;</code></dt>
<dt><code>#include &lt;tchdb.h&gt;</code></dt>
<dt><code>#include &lt;stdlib.h&gt;</code></dt>
<dt><code>#include &lt;stdbool.h&gt;</code></dt>
<dt><code>#include &lt;stdint.h&gt;</code></dt>
</dl>

<p>ハッシュデータベースを扱う際には、`<code>TCHDB</code>' 型へのポインタをオブジェクトとして用います。ハッシュデータベースオブジェクトは、関数 `<code>tchdbnew</code>' で作成し、関数 `<code>tchdbdel</code>' で破棄します。作成したオブジェクトを使い終わったら必ず破棄してください。そうしないとメモリリークが発生します。</p>

<p>レコードの格納や探索を行う前提として、ハッシューデータベースオブジェクトをデータベースファイルと接続させる必要があります。データベースファイルを開いて接続するには関数 `<code>tchdbopen</code>' を用い、接続の解除してファイルを閉じるには関数 `<code>tchdbclose</code>' を用います。開いたデータベースファイルは必ず閉じてください。そうしないとデータベースファイルが壊れたり格納したデータが失われたりする可能性があります。単一のプロセス内で複数のデータベースオブジェクトが同じデータベースファイルを同時に開くことはできません。</p>

<h3 id="tchdbapi_api">API（英語ゴメン）</h3>

<p>The function `tchdberrmsg' is used in order to get the message string corresponding to an error code.</p>

<dl class="api">
<dt><code>const char *tchdberrmsg(int <var>ecode</var>);</code></dt>
<dd>`<var>ecode</var>' specifies the error code.</dd>
<dd>The return value is the message string of the error code.</dd>
</dl>

<p>The function `tchdbnew' is used in order to create a hash database object.</p>

<dl class="api">
<dt><code>TCHDB *tchdbnew(void);</code></dt>
<dd>The return value is the new hash database object.</dd>
</dl>

<p>The function `tchdbdel' is used in order to delete a hash database object.</p>

<dl class="api">
<dt><code>void tchdbdel(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>If the database is not closed, it is closed implicitly.  Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tchdbecode' is used in order to get the last happened error code of a hash database object.</p>

<dl class="api">
<dt><code>int tchdbecode(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>The return value is the last happened error code.</dd>
<dd>The following error codes are defined: `TCESUCCESS' for success, `TCETHREAD' for threading error, `TCEINVALID' for invalid operation, `TCENOFILE' for file not found, `TCENOPERM' for no permission, `TCEMETA' for invalid meta data, `TCERHEAD' for invalid record header, `TCEOPEN' for open error, `TCECLOSE' for close error, `TCETRUNC' for trunc error, `TCESYNC' for sync error, `TCESTAT' for stat error, `TCESEEK' for seek error, `TCEREAD' for read error, `TCEWRITE' for write error, `TCEMMAP' for mmap error, `TCELOCK' for lock error, `TCEUNLINK' for unlink error, `TCERENAME' for rename error, `TCEMKDIR' for mkdir error, `TCERMDIR' for rmdir error, `TCEKEEP' for existing record, `TCENOREC' for no record found, and `TCEMISC' for miscellaneous error.</dd>
</dl>

<p>The function `tchdbsetmutex' is used in order to set mutual exclusion control of a hash database object for threading.</p>

<dl class="api">
<dt><code>bool tchdbsetmutex(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object which is not opened.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the mutual exclusion control is needed if the object is shared by plural threads and this function should be called before the database is opened.</dd>
</dl>

<p>The function `tchdbtune' is used in order to set the tuning parameters of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbtune(TCHDB *<var>hdb</var>, int64_t <var>bnum</var>, int8_t <var>apow</var>, int8_t <var>fpow</var>, uint8_t <var>opts</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object which is not opened.</dd>
<dd>`<var>bnum</var>' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is 131071.  Suggested size of the bucket array is about from 0.5 to 4 times of the number of all records to be stored.</dd>
<dd>`<var>apow</var>' specifies the size of record alignment by power of 2.  If it is negative, the default value is specified.  The default value is 4 standing for 2^4=16.</dd>
<dd>`<var>fpow</var>' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the default value is specified.  The default value is 10 standing for 2^10=1024.</dd>
<dd>`<var>opts</var>' specifies options by bitwise-or: `HDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64-bit bucket array, `HDBTDEFLATE' specifies that each record is compressed with Deflate encoding, `HDBTBZIP' specifies that each record is compressed with BZIP2 encoding, `HDBTTCBS' specifies that each record is compressed with TCBS encoding.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the tuning parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tchdbsetcache' is used in order to set the caching parameters of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbsetcache(TCHDB *<var>hdb</var>, int32_t <var>rcnum</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object which is not opened.</dd>
<dd>`<var>rcnum</var>' specifies the maximum number of records to be cached.  If it is not more than 0, the record cache is disabled.  It is disabled by default.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the caching parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tchdbsetxmsiz' is used in order to set the size of the extra mapped memory of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbsetxmsiz(TCHDB *<var>hdb</var>, int64_t <var>xmsiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object which is not opened.</dd>
<dd>`<var>xmsiz</var>' specifies the size of the extra mapped memory.  If it is not more than 0, the extra mapped memory is disabled.  The default size is 67108864.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the mapping parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tchdbsetdfunit' is used in order to set the unit step number of auto defragmentation of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbsetdfunit(TCHDB *<var>hdb</var>, int32_t <var>dfunit</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object which is not opened.</dd>
<dd>`<var>dfunit</var>' specifie the unit step number.  If it is not more than 0, the auto defragmentation is disabled.  It is disabled by default.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the defragmentation parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tchdbopen' is used in order to open a database file and connect a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbopen(TCHDB *<var>hdb</var>, const char *<var>path</var>, int <var>omode</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object which is not opened.</dd>
<dd>`<var>path</var>' specifies the path of the database file.</dd>
<dd>`<var>omode</var>' specifies the connection mode: `HDBOWRITER' as a writer, `HDBOREADER' as a reader.  If the mode is `HDBOWRITER', the following may be added by bitwise-or: `HDBOCREAT', which means it creates a new database if not exist, `HDBOTRUNC', which means it creates a new database regardless if one exists, `HDBOTSYNC', which means every transaction synchronizes updated contents with the device.  Both of `HDBOREADER' and `HDBOWRITER' can be added to by bitwise-or: `HDBONOLCK', which means it opens the database file without file locking, or `HDBOLCKNB', which means locking is performed without blocking.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tchdbclose' is used in order to close a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbclose(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update of a database is assured to be written when the database is closed.  If a writer opens a database but does not close it appropriately, the database will be broken.</dd>
</dl>

<p>The function `tchdbput' is used in order to store a record into a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbput(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tchdbput2' is used in order to store a string record into a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbput2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tchdbputkeep' is used in order to store a new record into a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbputkeep(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tchdbputkeep2' is used in order to store a new string record into a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbputkeep2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tchdbputcat' is used in order to concatenate a value at the end of the existing record in a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbputcat(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tchdbputcat2' is used in order to concatenate a string value at the end of the existing record in a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbputcat2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tchdbputasync' is used in order to store a record into a hash database object in asynchronous fashion.</p>

<dl class="api">
<dt><code>bool tchdbputasync(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.  Records passed to this function are accumulated into the inner buffer and wrote into the file at a blast.</dd>
</dl>

<p>The function `tchdbputasync2' is used in order to store a string record into a hash database object in asynchronous fashion.</p>

<dl class="api">
<dt><code>bool tchdbputasync2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.  Records passed to this function are accumulated into the inner buffer and wrote into the file at a blast.</dd>
</dl>

<p>The function `tchdbout' is used in order to remove a record of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbout(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tchdbout2' is used in order to remove a string record of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbout2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tchdbget' is used in order to retrieve a record in a hash database object.</p>

<dl class="api">
<dt><code>void *tchdbget(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tchdbget2' is used in order to retrieve a string record in a hash database object.</p>

<dl class="api">
<dt><code>char *tchdbget2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tchdbget3' is used in order to retrieve a record in a hash database object and write the value into a buffer.</p>

<dl class="api">
<dt><code>int tchdbget3(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, void *<var>vbuf</var>, int <var>max</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the buffer into which the value of the corresponding record is written.</dd>
<dd>`<var>max</var>' specifies the size of the buffer.</dd>
<dd>If successful, the return value is the size of the written data, else, it is -1.  -1 is returned if no record corresponds to the specified key.</dd>
<dd>Note that an additional zero code is not appended at the end of the region of the writing buffer.</dd>
</dl>

<p>The function `tchdbvsiz' is used in order to get the size of the value of a record in a hash database object.</p>

<dl class="api">
<dt><code>int tchdbvsiz(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tchdbvsiz2' is used in order to get the size of the value of a string record in a hash database object.</p>

<dl class="api">
<dt><code>int tchdbvsiz2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tchdbiterinit' is used in order to initialize the iterator of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbiterinit(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The iterator is used in order to access the key of every record stored in a database.</dd>
</dl>

<p>The function `tchdbiternext' is used in order to get the next key of the iterator of a hash database object.</p>

<dl class="api">
<dt><code>void *tchdbiternext(TCHDB *<var>hdb</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  It is allowed to update or remove records whose keys are fetched while the iteration.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.</dd>
</dl>

<p>The function `tchdbiternext2' is used in order to get the next key string of the iterator of a hash database object.</p>

<dl class="api">
<dt><code>char *tchdbiternext2(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>If successful, the return value is the string of the next key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.</dd>
</dl>

<p>The function `tchdbiternext3' is used in order to get the next extensible objects of the iterator of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbiternext3(TCHDB *<var>hdb</var>, TCXSTR *<var>kxstr</var>, TCXSTR *<var>vxstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>kxstr</var>' specifies the object into which the next key is wrote down.</dd>
<dd>`<var>vxstr</var>' specifies the object into which the next value is wrote down.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned when no record is to be get out of the iterator.</dd>
</dl>

<p>The function `tchdbfwmkeys' is used in order to get forward matching keys in a hash database object.</p>

<dl class="api">
<dt><code>TCLIST *tchdbfwmkeys(TCHDB *<var>hdb</var>, const void *<var>pbuf</var>, int <var>psiz</var>, int <var>max</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>pbuf</var>' specifies the pointer to the region of the prefix.</dd>
<dd>`<var>psiz</var>' specifies the size of the region of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</dd>
</dl>

<p>The function `tchdbfwmkeys2' is used in order to get forward matching string keys in a hash database object.</p>

<dl class="api">
<dt><code>TCLIST *tchdbfwmkeys2(TCHDB *<var>hdb</var>, const char *<var>pstr</var>, int <var>max</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>pstr</var>' specifies the string of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</dd>
</dl>

<p>The function `tchdbaddint' is used in order to add an integer to a record in a hash database object.</p>

<dl class="api">
<dt><code>int tchdbaddint(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int <var>num</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>If successful, the return value is the summation value, else, it is `INT_MIN'.</dd>
<dd>If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tchdbdbadddouble' is used in order to add a real number to a record in a hash database object.</p>

<dl class="api">
<dt><code>double tchdbadddouble(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, double <var>num</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>If successful, the return value is the summation value, else, it is Not-a-Number.</dd>
<dd>If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tchdbsync' is used in order to synchronize updated contents of a hash database object with the file and the device.</p>

<dl class="api">
<dt><code>bool tchdbsync(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function is useful when another process connects to the same database file.</dd>
</dl>

<p>The function `tchdboptimize' is used in order to optimize the file of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdboptimize(TCHDB *<var>hdb</var>, int64_t <var>bnum</var>, int8_t <var>apow</var>, int8_t <var>fpow</var>, uint8_t <var>opts</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>bnum</var>' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is two times of the number of records.</dd>
<dd>`<var>apow</var>' specifies the size of record alignment by power of 2.  If it is negative, the current setting is not changed.</dd>
<dd>`<var>fpow</var>' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the current setting is not changed.</dd>
<dd>`<var>opts</var>' specifies options by bitwise-or: `HDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64-bit bucket array, `HDBTDEFLATE' specifies that each record is compressed with Deflate encoding, `HDBTTCBS' specifies that each record is compressed with TCBS encoding.  If it is `UINT8_MAX', the current setting is not changed.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function is useful to reduce the size of the database file with data fragmentation by successive updating.</dd>
</dl>

<p>The function `tchdbvanish' is used in order to remove all records of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbvanish(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tchdbcopy' is used in order to copy the database file of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbcopy(TCHDB *<var>hdb</var>, const char *<var>path</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>path</var>' specifies the path of the destination file.  If it begins with `@', the trailing substring is executed as a command line.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if the executed command returns non-zero code.</dd>
<dd>The database file is assured to be kept synchronized and not modified while the copying or executing operation is in progress.  So, this function is useful to create a backup file of the database file.</dd>
</dl>

<p>The function `tchdbtranbegin' is used in order to begin the transaction of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbtranbegin(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The database is locked by the thread while the transaction so that only one transaction can be activated with a database object at the same time.  Thus, the serializable isolation level is assumed if every database operation is performed in the transaction.  All updated regions are kept track of by write ahead logging while the transaction.  If the database is closed during transaction, the transaction is aborted implicitly.</dd>
</dl>

<p>The function `tchdbtrancommit' is used in order to commit the transaction of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbtrancommit(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update in the transaction is fixed when it is committed successfully.</dd>
</dl>

<p>The function `tchdbtranabort' is used in order to abort the transaction of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbtranabort(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update in the transaction is discarded when it is aborted.  The state of the database is rollbacked to before transaction.</dd>
</dl>

<p>The function `tchdbpath' is used in order to get the file path of a hash database object.</p>

<dl class="api">
<dt><code>const char *tchdbpath(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>The return value is the path of the database file or `NULL' if the object does not connect to any database file.</dd>
</dl>

<p>The function `tchdbrnum' is used in order to get the number of records of a hash database object.</p>

<dl class="api">
<dt><code>uint64_t tchdbrnum(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>The return value is the number of records or 0 if the object does not connect to any database file.</dd>
</dl>

<p>The function `tchdbfsiz' is used in order to get the size of the database file of a hash database object.</p>

<dl class="api">
<dt><code>uint64_t tchdbfsiz(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>The return value is the size of the database file or 0 if the object does not connect to any database file.</dd>
</dl>

<h3 id="tchdbapi_example">コード例</h3>

<p>ハッシュデータベースを使ったコード例を以下に示します。</p>

<pre>#include &lt;tcutil.h&gt;
#include &lt;tchdb.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;

int main(int argc, char **argv){
  TCHDB *hdb;
  int ecode;
  char *key, *value;

  /* オブジェクトを作成する */
  hdb = tchdbnew();

  /* データベースを開く */
  if(!tchdbopen(hdb, "casket.tch", HDBOWRITER | HDBOCREAT)){
    ecode = tchdbecode(hdb);
    fprintf(stderr, "open error: %s\n", tchdberrmsg(ecode));
  }

  /* レコードを格納する */
  if(!tchdbput2(hdb, "foo", "hop") ||
     !tchdbput2(hdb, "bar", "step") ||
     !tchdbput2(hdb, "baz", "jump")){
    ecode = tchdbecode(hdb);
    fprintf(stderr, "put error: %s\n", tchdberrmsg(ecode));
  }

  /* レコードを取得する */
  value = tchdbget2(hdb, "foo");
  if(value){
    printf("%s\n", value);
    free(value);
  } else {
    ecode = tchdbecode(hdb);
    fprintf(stderr, "get error: %s\n", tchdberrmsg(ecode));
  }

  /* 横断的にレコードを参照する */
  tchdbiterinit(hdb);
  while((key = tchdbiternext2(hdb)) != NULL){
    value = tchdbget2(hdb, key);
    if(value){
      printf("%s:%s\n", key, value);
      free(value);
    }
    free(key);
  }

  /* データベースを閉じる */
  if(!tchdbclose(hdb)){
    ecode = tchdbecode(hdb);
    fprintf(stderr, "close error: %s\n", tchdberrmsg(ecode));
  }

  /* オブジェクトを破棄する */
  tchdbdel(hdb);

  return 0;
}
</pre>

<h3 id="tchdbapi_cli">CLI</h3>

<p>ハッシュデータベースAPIを簡単に利用するために、コマンドラインインターフェイスとして `<code>tchtest</code>' と `<code>tchmttest</code>' と `<code>tchmgr</code>' が提供されます。</p>

<p>コマンド `<code>tchtest</code>' は、ハッシュデータベースAPIの機能テストや性能テストに用いるツールです。以下の書式で用います。`<var>path</var>' はデータベースファイルのパスを指定し、`<var>rnum</var>' は試行回数を指定し、`<var>bnum</var>' はバケット数を指定し、`<var>apow</var>' はアラインメント力を指定し、`<var>fpow</var>' はフリーブロックプール力を指定します。</p>

<dl class="api">
<dt><code>tchtest write [-mt] [-tl] [-td|-tb|-tt|-tx] [-rc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-as] [-rnd] <var>path</var> <var>rnum</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>`00000001'、`00000002' のように変化する8バイトのキーと値を連続してデータベースに追加する。</dd>
<dt><code>tchtest read [-mt] [-rc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-wb] [-rnd] <var>path</var></code></dt>
<dd>上記で生成したデータベースの全レコードを検索する。</dd>
<dt><code>tchtest remove [-mt] [-rc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-rnd] <var>path</var></code></dt>
<dd>上記で生成したデータベースの全レコードを削除する。</dd>
<dt><code>tchtest rcat [-mt] [-tl] [-td|-tb|-tt|-tx] [-rc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-pn <var>num</var>] [-dai|-dad|-rl|-ru] <var>path</var> <var>rnum</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>キーがある程度重複するようにレコードの追加を行い、連結モードで処理する。</dd>
<dt><code>tchtest misc [-mt] [-tl] [-td|-tb|-tt|-tx] [-nl|-nb] <var>path</var> <var>rnum</var></code></dt>
<dd>各種操作の組み合わせテストを行う。</dd>
<dt><code>tchtest wicked [-mt] [-tl] [-td|-tb|-tt|-tx] [-nl|-nb] <var>path</var> <var>rnum</var></code></dt>
<dd>各種更新操作を無作為に選択して実行する。</dd>
</dl>

<p>各オプションは以下の機能を持ちます</p>

<ul class="options">
<li><code>-mt</code> : 関数 `tchdbsetmutex' を呼び出す。</li>
<li><code>-tl</code> : オプション `HDBTLARGE' を有効にする。</li>
<li><code>-td</code> : オプション `HDBTDEFLATE' を有効にする。</li>
<li><code>-tb</code> : オプション `HDBTBZIP' を有効にする。</li>
<li><code>-tt</code> : オプション `HDBTTCBS' を有効にする。</li>
<li><code>-tx</code> : オプション `HDBTEXCODEC' を有効にする。</li>
<li><code>-rc <var>num</var></code> : レコード用キャッシュの最大数を指定する。</li>
<li><code>-xm <var>num</var></code> : 拡張マップメモリのサイズを指定する。</li>
<li><code>-df <var>num</var></code> : 自動デフラグの単位ステップ数を指定する。</li>
<li><code>-nl</code> : オプション `HDBNOLCK' を有効にする。</li>
<li><code>-nb</code> : オプション `HDBLCKNB' を有効にする。</li>
<li><code>-as</code> : 関数 `tchdbput' の代わりに関数 `tchdbputasync' を用いる。</li>
<li><code>-rnd</code> : キーを無作為に選択する。</li>
<li><code>-wb</code> : 関数 `tchdbget' の代わりに関数 `tchdbget3' を用いる。</li>
<li><code>-pn <var>num</var></code> : パターン数を指定する。</li>
<li><code>-dai</code> : 関数 `tchdbputcat' の代わりに関数 `tchdbaddint' を用いる。</li>
<li><code>-dad</code> : 関数 `tchdbputcat' の代わりに関数 `tchdbadddouble' を用いる。</li>
<li><code>-rl</code> : 値を無作為な長さにする。</li>
<li><code>-ru</code> : 更新操作を無作為に選択する。</li>
</ul>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<p>コマンド `<code>tchmttest</code>' は、ハッシュデータベースAPIの機能テストをマルチスレッドで行うツールです。以下の書式で用います。`<var>path</var>' はデータベースファイルのパスを指定し、`<var>tnum</var>' はスレッド数を指定し、`<var>rnum</var>' は試行回数を指定し、`<var>bnum</var>' はバケット数を指定し、`<var>apow</var>' はアラインメント力を指定し、`<var>fpow</var>' はフリーブロックプール力を指定します。</p>

<dl class="api">
<dt><code>tchmttest write [-tl] [-td|-tb|-tt|-tx] [-rc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-as] [-rnd] <var>path</var> <var>tnum</var> <var>rnum</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>`00000001'、`00000002' のように変化する8バイトのキーと値を連続してデータベースに追加する。</dd>
<dt><code>tchmttest read [-rc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-wb] [-rnd] <var>path</var> <var>tnum</var></code></dt>
<dd>上記で生成したデータベースの全レコードを検索する。</dd>
<dt><code>tchmttest remove [-rc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-rnd] <var>path</var> <var>tnum</var></code></dt>
<dd>上記で生成したデータベースの全レコードを削除する。</dd>
<dt><code>tchmttest wicked [-tl] [-td|-tb|-tt|-tx] [-nl|-nb] [-nc] <var>path</var> <var>tnum</var> <var>rnum</var></code></dt>
<dd>各種更新操作を無作為に選択して実行する。</dd>
<dt><code>tchmttest typical [-tl] [-td|-tb|-tt|-tx] [-rc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-nc] [-rr <var>num</var>] <var>path</var> <var>tnum</var> <var>rnum</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]</code></dt>
<dd>典型的な操作を無作為に選択して実行する。</dd>
<dt><code>tchmttest race [-tl] [-td|-tb|-tt|-tx] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] <var>path</var> <var>tnum</var> <var>rnum</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]</code></dt>
<dd>レースコンディション検出のテストを行う。</dd>
</dl>

<p>各オプションは以下の機能を持ちます</p>

<ul class="options">
<li><code>-tl</code> : オプション `HDBTLARGE' を有効にする。</li>
<li><code>-td</code> : オプション `HDBTDEFLATE' を有効にする。</li>
<li><code>-tb</code> : オプション `HDBTBZIP' を有効にする。</li>
<li><code>-tt</code> : オプション `HDBTTCBS' を有効にする。</li>
<li><code>-tx</code> : オプション `HDBTEXCODEC' を有効にする。</li>
<li><code>-rc <var>num</var></code> : レコード用キャッシュの最大数を指定する。</li>
<li><code>-xm <var>num</var></code> : 拡張マップメモリのサイズを指定する。</li>
<li><code>-df <var>num</var></code> : 自動デフラグの単位ステップ数を指定する。</li>
<li><code>-nl</code> : オプション `HDBNOLCK' を有効にする。</li>
<li><code>-nb</code> : オプション `HDBLCKNB' を有効にする。</li>
<li><code>-as</code> : 関数 `tchdbput' の代わりに関数 `tchdbputasync' を用いる。</li>
<li><code>-rnd</code> : キーを無作為に選択する。</li>
<li><code>-wb</code> : 関数 `tchdbget' の代わりに関数 `tchdbget3' を用いる。</li>
<li><code>-nc</code> : 比較テストを行わない。</li>
<li><code>-rr <var>num</var></code> : 読み込み操作の割合を百分率で指定する。</li>
</ul>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<p>コマンド `<code>tchmgr</code>' は、ハッシュデータベースAPIやそのアプリケーションのテストやデバッグに役立つツールです。以下の書式で用います。`<var>path</var>' はデータベースファイルのパスを指定し、`<var>bnum</var>' はバケット数を指定し、`<var>apow</var>' はアラインメント力を指定し、`<var>fpow</var>' はフリーブロックプール力を指定し、`<var>key</var>' はレコードのキーを指定し、`<var>value</var>' はレコードの値を指定し、`<var>file</var>' は入力ファイルを指定します。</p>

<dl class="api">
<dt><code>tchmgr create [-tl] [-td|-tb|-tt|-tx] <var>path</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>データベースファイルを作成する。</dd>
<dt><code>tchmgr inform [-nl|-nb] <var>path</var></code></dt>
<dd>データベースの雑多な情報を出力する。</dd>
<dt><code>tchmgr put [-nl|-nb] [-sx] [-dk|-dc|-dai|-dad] <var>path</var> <var>key</var> <var>value</var></code></dt>
<dd>レコードを追加する。</dd>
<dt><code>tchmgr out [-nl|-nb] [-sx] <var>path</var> <var>key</var></code></dt>
<dd>レコードを削除する。</dd>
<dt><code>tchmgr get [-nl|-nb] [-sx] [-px] [-pz] <var>path</var> <var>key</var></code></dt>
<dd>レコードの値を取得して標準出力する。</dd>
<dt><code>tchmgr list [-nl|-nb] [-m <var>num</var>] [-pv] [-px] [-fm <var>str</var>] <var>path</var></code></dt>
<dd>全てのレコードのキーを改行で区切って標準出力する。</dd>
<dt><code>tchmgr optimize [-tl] [-td|-tb|-tt|-tx] [-tz] [-nl|-nb] [-df] <var>path</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>データベースを最適化する。</dd>
<dt><code>tchmgr importtsv [-nl|-nb] [-sc] <var>path</var> [<var>file</var>]</code></dt>
<dd>TSVファイルの各行をキーと値とみなしてレコードを登録する。</dd>
<dt><code>tchmgr version</code></dt>
<dd>Tokyo Cabinetのバージョン情報を標準出力する。</dd>
</dl>

<p>各オプションは以下の機能を持ちます</p>

<ul class="options">
<li><code>-tl</code> : オプション `HDBTLARGE' を有効にする。</li>
<li><code>-td</code> : オプション `HDBTDEFLATE' を有効にする。</li>
<li><code>-tb</code> : オプション `HDBTBZIP' を有効にする。</li>
<li><code>-tt</code> : オプション `HDBTTCBS' を有効にする。</li>
<li><code>-tx</code> : オプション `HDBTEXCODEC' を有効にする。</li>
<li><code>-nl</code> : オプション `HDBNOLCK' を有効にする。</li>
<li><code>-nb</code> : オプション `HDBLCKNB' を有効にする。</li>
<li><code>-sx</code> : 入力を16進数の文字列で行う。</li>
<li><code>-dk</code> : 関数 `tchdbput' の代わりに関数 `tchdbputkeep' を用いる。</li>
<li><code>-dc</code> : 関数 `tchdbput' の代わりに関数 `tchdbputcat' を用いる。</li>
<li><code>-dai</code> : 関数 `tchdbput' の代わりに関数 `tchdbaddint' を用いる。</li>
<li><code>-dad</code> : 関数 `tchdbput' の代わりに関数 `tchdbadddouble' を用いる。</li>
<li><code>-px</code> : 出力を16進数の文字列で行う。</li>
<li><code>-pz</code> : 出力の末尾に改行を付加しない。</li>
<li><code>-m <var>num</var></code> : 出力の最大数を指定する。</li>
<li><code>-pv</code> : レコードの値も出力する。</li>
<li><code>-fm <var>str</var></code> : キーの接頭辞を指定する。</li>
<li><code>-tz</code> : オプション `UINT8_MAX' を有効にする。</li>
<li><code>-df</code> : デフラグのみを行う。</li>
<li><code>-sc</code> : キーを小文字に正規化する。</li>
</ul>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<hr />

<h2 id="tcbdbapi">B+木データベースAPI</h2>

<p>B+木データベースは、B+木を単一のファイルに記録したデータベースです。それを扱うのがB+木データベースAPIです。`<code>tcbdb.h</code>' にAPIの仕様の完全な記述があります。</p>

<h3 id="tcbdbapi_description">概要</h3>

<p>ハッシュデータベースAPIを使うためには、`<code>tcutil.h</code>'、`<code>tcbdb.h</code>' および関連する標準ヘッダファイルをインクルードしてください。通常、ソースファイルの冒頭付近で以下の記述を行います。</p>

<dl>
<dt><code>#include &lt;tcutil.h&gt;</code></dt>
<dt><code>#include &lt;tcbdb.h&gt;</code></dt>
<dt><code>#include &lt;stdlib.h&gt;</code></dt>
<dt><code>#include &lt;stdbool.h&gt;</code></dt>
<dt><code>#include &lt;stdint.h&gt;</code></dt>
</dl>

<p>B+木データベースを扱う際には、`<code>TCBDB</code>' 型へのポインタをオブジェクトとして用います。B+木データベースオブジェクトは、関数 `<code>tcbdbnew</code>' で作成し、関数 `<code>tcbdbdel</code>' で破棄します。作成したオブジェクトを使い終わったら必ず破棄してください。そうしないとメモリリークが発生します。</p>

<p>レコードの格納や探索を行う前提として、B+木ーデータベースオブジェクトをデータベースファイルと接続させる必要があります。データベースファイルを開いて接続するには関数 `<code>tcbdbopen</code>' を用い、接続の解除してファイルを閉じるには関数 `<code>tcbdbclose</code>' を用います。開いたデータベースファイルは必ず閉じてください。そうしないとデータベースファイルが壊れたり格納したデータが失われたりする可能性があります。単一のプロセス内で複数のデータベースオブジェクトが同じデータベースファイルを同時に開くことはできません。</p>

<h3 id="tcbdbapi_api">API（英語ゴメソ）</h3>

<p>The function `tcbdberrmsg' is used in order to get the message string corresponding to an error code.</p>

<dl class="api">
<dt><code>const char *tcbdberrmsg(int <var>ecode</var>);</code></dt>
<dd>`<var>ecode</var>' specifies the error code.</dd>
<dd>The return value is the message string of the error code.</dd>
</dl>

<p>The function `tcbdbnew' is used in order to create a B+ tree database object.</p>

<dl class="api">
<dt><code>TCBDB *tcbdbnew(void);</code></dt>
<dd>The return value is the new B+ tree database object.</dd>
</dl>

<p>The function `tcbdbdel' is used in order to delete a B+ tree database object.</p>

<dl class="api">
<dt><code>void tcbdbdel(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>If the database is not closed, it is closed implicitly.  Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tcbdbecode' is used in order to get the last happened error code of a B+ tree database object.</p>

<dl class="api">
<dt><code>int tcbdbecode(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>The return value is the last happened error code.</dd>
<dd>The following error codes are defined: `TCESUCCESS' for success, `TCETHREAD' for threading error, `TCEINVALID' for invalid operation, `TCENOFILE' for file not found, `TCENOPERM' for no permission, `TCEMETA' for invalid meta data, `TCERHEAD' for invalid record header, `TCEOPEN' for open error, `TCECLOSE' for close error, `TCETRUNC' for trunc error, `TCESYNC' for sync error, `TCESTAT' for stat error, `TCESEEK' for seek error, `TCEREAD' for read error, `TCEWRITE' for write error, `TCEMMAP' for mmap error, `TCELOCK' for lock error, `TCEUNLINK' for unlink error, `TCERENAME' for rename error, `TCEMKDIR' for mkdir error, `TCERMDIR' for rmdir error, `TCEKEEP' for existing record, `TCENOREC' for no record found, and `TCEMISC' for miscellaneous error.</dd>
</dl>

<p>The function `tcbdbsetmutex' is used in order to set mutual exclusion control of a B+ tree database object for threading.</p>

<dl class="api">
<dt><code>bool tcbdbsetmutex(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object which is not opened.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the mutual exclusion control is needed if the object is shared by plural threads and this function should be called before the database is opened.</dd>
</dl>

<p>The function `tcbdbsetcmpfunc' is used in order to set the custom comparison function of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbsetcmpfunc(TCBDB *<var>bdb</var>, TCCMP <var>cmp</var>, void *<var>cmpop</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object which is not opened.</dd>
<dd>`<var>cmp</var>' specifies the pointer to the custom comparison function.  It receives five parameters.  The first parameter is the pointer to the region of one key.  The second parameter is the size of the region of one key.  The third parameter is the pointer to the region of the other key.  The fourth parameter is the size of the region of the other key.  The fifth parameter is the pointer to the optional opaque object.  It returns positive if the former is big, negative if the latter is big, 0 if both are equivalent.</dd>
<dd>`<var>cmpop</var>' specifies an arbitrary pointer to be given as a parameter of the comparison function.  If it is not needed, `NULL' can be specified.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The default comparison function compares keys of two records by lexical order.  The functions `tccmplexical' (dafault), `tccmpdecimal', `tccmpint32', and `tccmpint64' are built-in.  Note that the comparison function should be set before the database is opened.  Moreover, user-defined comparison functions should be set every time the database is being opened.</dd>
</dl>

<p>The function `tcbdbtune' is used in order to set the tuning parameters of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbtune(TCBDB *<var>bdb</var>, int32_t <var>lmemb</var>, int32_t <var>nmemb</var>, int64_t <var>bnum</var>, int8_t <var>apow</var>, int8_t <var>fpow</var>, uint8_t <var>opts</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object which is not opened.</dd>
<dd>`<var>lmemb</var>' specifies the number of members in each leaf page.  If it is not more than 0, the default value is specified.  The default value is 128.</dd>
<dd>`<var>nmemb</var>' specifies the number of members in each non-leaf page.  If it is not more than 0, the default value is specified.  The default value is 256.</dd>
<dd>`<var>bnum</var>' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is 32749.  Suggested size of the bucket array is about from 1 to 4 times of the number of all pages to be stored.</dd>
<dd>`<var>apow</var>' specifies the size of record alignment by power of 2.  If it is negative, the default value is specified.  The default value is 8 standing for 2^8=256.</dd>
<dd>`<var>fpow</var>' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the default value is specified.  The default value is 10 standing for 2^10=1024.</dd>
<dd>`<var>opts</var>' specifies options by bitwise-or: `BDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64-bit bucket array, `BDBTDEFLATE' specifies that each page is compressed with Deflate encoding, `BDBTBZIP' specifies that each page is compressed with BZIP2 encoding, `BDBTTCBS' specifies that each page is compressed with TCBS encoding.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the tuning parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tcbdbsetcache' is used in order to set the caching parameters of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbsetcache(TCBDB *<var>bdb</var>, int32_t <var>lcnum</var>, int32_t <var>ncnum</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object which is not opened.</dd>
<dd>`<var>lcnum</var>' specifies the maximum number of leaf nodes to be cached.  If it is not more than 0, the default value is specified.  The default value is 4096.</dd>
<dd>`<var>ncnum</var>' specifies the maximum number of non-leaf nodes to be cached.  If it is not more than 0, the default value is specified.  The default value is 512.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the caching parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tcbdbsetxmsiz' is used in order to set the size of the extra mapped memory of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbsetxmsiz(TCBDB *<var>bdb</var>, int64_t <var>xmsiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object which is not opened.</dd>
<dd>`<var>xmsiz</var>' specifies the size of the extra mapped memory.  If it is not more than 0, the extra mapped memory is disabled.  It is disabled by default.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the mapping parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tcbdbsetdfunit' is used in order to set the unit step number of auto defragmentation of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbsetdfunit(TCBDB *<var>bdb</var>, int32_t <var>dfunit</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object which is not opened.</dd>
<dd>`<var>dfunit</var>' specifie the unit step number.  If it is not more than 0, the auto defragmentation is disabled.  It is disabled by default.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the defragmentation parameter should be set before the database is opened.</dd>
</dl>

<p>The function `tcbdbopen' is used in order to open a database file and connect a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbopen(TCBDB *<var>bdb</var>, const char *<var>path</var>, int <var>omode</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object which is not opened.</dd>
<dd>`<var>path</var>' specifies the path of the database file.</dd>
<dd>`<var>omode</var>' specifies the connection mode: `BDBOWRITER' as a writer, `BDBOREADER' as a reader.  If the mode is `BDBOWRITER', the following may be added by bitwise-or: `BDBOCREAT', which means it creates a new database if not exist, `BDBOTRUNC', which means it creates a new database regardless if one exists, `BDBOTSYNC', which means every transaction synchronizes updated contents with the device.  Both of `BDBOREADER' and `BDBOWRITER' can be added to by bitwise-or: `BDBONOLCK', which means it opens the database file without file locking, or `BDBOLCKNB', which means locking is performed without blocking.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcbdbclose' is used in order to close a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbclose(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update of a database is assured to be written when the database is closed.  If a writer opens a database but does not close it appropriately, the database will be broken.</dd>
</dl>

<p>The function `tcbdbput' is used in order to store a record into a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbput(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcbdbput2' is used in order to store a string record into a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbput2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcbdbputkeep' is used in order to store a new record into a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbputkeep(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcbdbputkeep2' is used in order to store a new string record into a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbputkeep2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcbdbputcat' is used in order to concatenate a value at the end of the existing record in a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbputcat(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcbdbputcat2' is used in order to concatenate a stirng value at the end of the existing record in a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbputcat2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcbdbputdup' is used in order to store a record into a B+ tree database object with allowing duplication of keys.</p>

<dl class="api">
<dt><code>bool tcbdbputdup(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, the new record is placed after the existing one.</dd>
</dl>

<p>The function `tcbdbputdup2' is used in order to store a string record into a B+ tree database object with allowing duplication of keys.</p>

<dl class="api">
<dt><code>bool tcbdbputdup2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, the new record is placed after the existing one.</dd>
</dl>

<p>The function `tcbdbputdup3' is used in order to store records into a B+ tree database object with allowing duplication of keys.</p>

<dl class="api">
<dt><code>bool tcbdbputdup3(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const TCLIST *<var>vals</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the common key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the common key.</dd>
<dd>`<var>vals</var>' specifies a list object containing values.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, the new records are placed after the existing one.</dd>
</dl>

<p>The function `tcbdbout' is used in order to remove a record of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbout(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If the key of duplicated records is specified, the first one is selected.</dd>
</dl>

<p>The function `tcbdbout2' is used in order to remove a string record of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbout2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If the key of duplicated records is specified, the first one is selected.</dd>
</dl>

<p>The function `tcbdbout3' is used in order to remove records of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbout3(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If the key of duplicated records is specified, all of them are removed.</dd>
</dl>

<p>The function `tcbdbget' is used in order to retrieve a record in a B+ tree database object.</p>

<dl class="api">
<dt><code>void *tcbdbget(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>If the key of duplicated records is specified, the first one is selected.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbget2' is used in order to retrieve a string record in a B+ tree database object.</p>

<dl class="api">
<dt><code>char *tcbdbget2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>If the key of duplicated records is specified, the first one is selected.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbget3' is used in order to retrieve a record in a B+ tree database object as a volatile buffer.</p>

<dl class="api">
<dt><code>const void *tcbdbget3(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>If the key of duplicated records is specified, the first one is selected.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is volatile and it may be spoiled by another operation of the database, the data should be copied into another involatile buffer immediately.</dd>
</dl>

<p>The function `tcbdbget4' is used in order to retrieve records in a B+ tree database object.</p>

<dl class="api">
<dt><code>TCLIST *tcbdbget4(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is a list object of the values of the corresponding records.  `NULL' is returned if no record corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbvnum' is used in order to get the number of records corresponding a key in a B+ tree database object.</p>

<dl class="api">
<dt><code>int tcbdbvnum(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is the number of the corresponding records, else, it is 0.</dd>
</dl>

<p>The function `tcbdbvnum2' is used in order to get the number of records corresponding a string key in a B+ tree database object.</p>

<dl class="api">
<dt><code>int tcbdbvnum2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the number of the corresponding records, else, it is 0.</dd>
</dl>

<p>The function `tcbdbvsiz' is used in order to get the size of the value of a record in a B+ tree database object.</p>

<dl class="api">
<dt><code>int tcbdbvsiz(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
<dd>If the key of duplicated records is specified, the first one is selected.</dd>
</dl>

<p>The function `tcbdbvsiz2' is used in order to get the size of the value of a string record in a B+ tree database object.</p>

<dl class="api">
<dt><code>int tcbdbvsiz2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
<dd>If the key of duplicated records is specified, the first one is selected.</dd>
</dl>

<p>The function `tcbdbrange' is used in order to get keys of ranged records in a B+ tree database object.</p>

<dl class="api">
<dt><code>TCLIST *tcbdbrange(TCBDB *<var>bdb</var>, const void *<var>bkbuf</var>, int <var>bksiz</var>, bool <var>binc</var>, const void *<var>ekbuf</var>, int <var>eksiz</var>, bool <var>einc</var>, int <var>max</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>bkbuf</var>' specifies the pointer to the region of the key of the beginning border.  If it is `NULL', the first record is specified.</dd>
<dd>`<var>bksiz</var>' specifies the size of the region of the beginning key.</dd>
<dd>`<var>binc</var>' specifies whether the beginning border is inclusive or not.</dd>
<dd>`<var>ekbuf</var>' specifies the pointer to the region of the key of the ending border.  If it is `NULL', the last record is specified.</dd>
<dd>`<var>eksiz</var>' specifies the size of the region of the ending key.</dd>
<dd>`<var>einc</var>' specifies whether the ending border is inclusive or not.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the keys of the corresponding records.  This function does never fail.  It returns an empty list even if no record corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbrange2' is used in order to get string keys of ranged records in a B+ tree database object.</p>

<dl class="api">
<dt><code>TCLIST *tcbdbrange2(TCBDB *<var>bdb</var>, const char *<var>bkstr</var>, bool <var>binc</var>, const char *<var>ekstr</var>, bool <var>einc</var>, int <var>max</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>bkstr</var>' specifies the string of the key of the beginning border.  If it is `NULL', the first record is specified.</dd>
<dd>`<var>binc</var>' specifies whether the beginning border is inclusive or not.</dd>
<dd>`<var>ekstr</var>' specifies the string of the key of the ending border.  If it is `NULL', the last record is specified.</dd>
<dd>`<var>einc</var>' specifies whether the ending border is inclusive or not.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the keys of the corresponding records.  This function does never fail.  It returns an empty list even if no record corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbfwmkeys' is used in order to get forward matching keys in a B+ tree database object.</p>

<dl class="api">
<dt><code>TCLIST *tcbdbfwmkeys(TCBDB *<var>bdb</var>, const void *<var>pbuf</var>, int <var>psiz</var>, int <var>max</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>pbuf</var>' specifies the pointer to the region of the prefix.</dd>
<dd>`<var>psiz</var>' specifies the size of the region of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbfwmkeys2' is used in order to get forward matching string keys in a B+ tree database object.</p>

<dl class="api">
<dt><code>TCLIST *tcbdbfwmkeys2(TCBDB *<var>bdb</var>, const char *<var>pstr</var>, int <var>max</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>pstr</var>' specifies the string of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbaddint' is used in order to add an integer to a record in a B+ tree database object.</p>

<dl class="api">
<dt><code>int tcbdbaddint(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int <var>num</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>If successful, the return value is the summation value, else, it is `INT_MIN'.</dd>
<dd>If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcbdbadddouble' is used in order to add a real number to a record in a B+ tree database object.</p>

<dl class="api">
<dt><code>double tcbdbadddouble(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, double <var>num</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>If successful, the return value is the summation value, else, it is Not-a-Number.</dd>
<dd>If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcbdbsync' is used in order to synchronize updated contents of a B+ tree database object with the file and the device.</p>

<dl class="api">
<dt><code>bool tcbdbsync(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function is useful when another process connects to the same database file.</dd>
</dl>

<p>The function `tcbdboptimize' is used in order to optimize the file of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdboptimize(TCBDB *<var>bdb</var>, int32_t <var>lmemb</var>, int32_t <var>nmemb</var>, int64_t <var>bnum</var>, int8_t <var>apow</var>, int8_t <var>fpow</var>, uint8_t <var>opts</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>lmemb</var>' specifies the number of members in each leaf page.  If it is not more than 0, the current setting is not changed.</dd>
<dd>`<var>nmemb</var>' specifies the number of members in each non-leaf page.  If it is not more than 0, the current setting is not changed.</dd>
<dd>`<var>bnum</var>' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is two times of the number of pages.</dd>
<dd>`<var>apow</var>' specifies the size of record alignment by power of 2.  If it is negative, the current setting is not changed.</dd>
<dd>`<var>fpow</var>' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the current setting is not changed.</dd>
<dd>`<var>opts</var>' specifies options by bitwise-or: `BDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64-bit bucket array, `BDBTDEFLATE' specifies that each record is compressed with Deflate encoding, `BDBTTCBS' specifies that each page is compressed with TCBS encoding.  If it is `UINT8_MAX', the current setting is not changed.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function is useful to reduce the size of the database file with data fragmentation by successive updating.</dd>
</dl>

<p>The function `tcbdbvanish' is used in order to remove all records of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbvanish(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcbdbcopy' is used in order to copy the database file of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbcopy(TCBDB *<var>bdb</var>, const char *<var>path</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>path</var>' specifies the path of the destination file.  If it begins with `@', the trailing substring is executed as a command line.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if the executed command returns non-zero code.</dd>
<dd>The database file is assured to be kept synchronized and not modified while the copying or executing operation is in progress.  So, this function is useful to create a backup file of the database file.</dd>
</dl>

<p>The function `tcbdbtranbegin' is used in order to begin the transaction of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbtranbegin(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The database is locked by the thread while the transaction so that only one transaction can be activated with a database object at the same time.  Thus, the serializable isolation level is assumed if every database operation is performed in the transaction.  Because all pages are cached on memory while the transaction, the amount of referred records is limited by the memory capacity.  If the database is closed during transaction, the transaction is aborted implicitly.</dd>
</dl>

<p>The function `tcbdbtrancommit' is used in order to commit the transaction of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbtrancommit(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update in the transaction is fixed when it is committed successfully.</dd>
</dl>

<p>The function `tcbdbtranabort' is used in order to abort the transaction of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbtranabort(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update in the transaction is discarded when it is aborted.  The state of the database is rollbacked to before transaction.</dd>
</dl>

<p>The function `tcbdbpath' is used in order to get the file path of a B+ tree database object.</p>

<dl class="api">
<dt><code>const char *tcbdbpath(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>The return value is the path of the database file or `NULL' if the object does not connect to any database file.</dd>
</dl>

<p>The function `tcbdbrnum' is used in order to get the number of records of a B+ tree database object.</p>

<dl class="api">
<dt><code>uint64_t tcbdbrnum(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>The return value is the number of records or 0 if the object does not connect to any database file.</dd>
</dl>

<p>The function `tcbdbfsiz' is used in order to get the size of the database file of a B+ tree database object.</p>

<dl class="api">
<dt><code>uint64_t tcbdbfsiz(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>The return value is the size of the database file or 0 if the object does not connect to any database file.</dd>
</dl>

<p>The function `tcbdbcurnew' is used in order to create a cursor object.</p>

<dl class="api">
<dt><code>BDBCUR *tcbdbcurnew(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>The return value is the new cursor object.</dd>
<dd>Note that the cursor is available only after initialization with the `tcbdbcurfirst' or the `tcbdbcurjump' functions and so on.  Moreover, the position of the cursor will be indefinite when the database is updated after the initialization of the cursor.</dd>
</dl>

<p>The function `tcbdbcurdel' is used in order to delete a cursor object.</p>

<dl class="api">
<dt><code>void tcbdbcurdel(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
</dl>

<p>The function `tcbdbcurfirst' is used in order to move a cursor object to the first record.</p>

<dl class="api">
<dt><code>bool tcbdbcurfirst(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if there is no record in the database.</dd>
</dl>

<p>The function `tcbdbcurlast' is used in order to move a cursor object to the last record.</p>

<dl class="api">
<dt><code>bool tcbdbcurlast(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if there is no record in the database.</dd>
</dl>

<p>The function `tcbdbcurjump' is used in order to move a cursor object to the front of records corresponding a key.</p>

<dl class="api">
<dt><code>bool tcbdbcurjump(BDBCUR *<var>cur</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if there is no record corresponding the condition.</dd>
<dd>The cursor is set to the first record corresponding the key or the next substitute if completely matching record does not exist.</dd>
</dl>

<p>The function `tcbdbcurjump2' is used in order to move a cursor object to the front of records corresponding a key string.</p>

<dl class="api">
<dt><code>bool tcbdbcurjump2(BDBCUR *<var>cur</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if there is no record corresponding the condition.</dd>
<dd>The cursor is set to the first record corresponding the key or the next substitute if completely matching record does not exist.</dd>
</dl>

<p>The function `tcbdbcurprev' is used in order to move a cursor object to the previous record.</p>

<dl class="api">
<dt><code>bool tcbdbcurprev(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if there is no previous record.</dd>
</dl>

<p>The function `tcbdbcurnext' is used in order to move a cursor object to the next record.</p>

<dl class="api">
<dt><code>bool tcbdbcurnext(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if there is no next record.</dd>
</dl>

<p>The function `tcbdbcurput' is used in order to insert a record around a cursor object.</p>

<dl class="api">
<dt><code>bool tcbdbcurput(BDBCUR *<var>cur</var>, const void *<var>vbuf</var>, int <var>vsiz</var>, int <var>cpmode</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object of writer connection.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>`<var>cpmode</var>' specifies detail adjustment: `BDBCPCURRENT', which means that the value of the current record is overwritten, `BDBCPBEFORE', which means that the new record is inserted before the current record, `BDBCPAFTER', which means that the new record is inserted after the current record.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned when the cursor is at invalid position.</dd>
<dd>After insertion, the cursor is moved to the inserted record.</dd>
</dl>

<p>The function `tcbdbcurput2' is used in order to insert a string record around a cursor object.</p>

<dl class="api">
<dt><code>bool tcbdbcurput2(BDBCUR *<var>cur</var>, const char *<var>vstr</var>, int <var>cpmode</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object of writer connection.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>`<var>cpmode</var>' specifies detail adjustment: `BDBCPCURRENT', which means that the value of the current record is overwritten, `BDBCPBEFORE', which means that the new record is inserted before the current record, `BDBCPAFTER', which means that the new record is inserted after the current record.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned when the cursor is at invalid position.</dd>
<dd>After insertion, the cursor is moved to the inserted record.</dd>
</dl>

<p>The function `tcbdbcurout' is used in order to remove the record where a cursor object is.</p>

<dl class="api">
<dt><code>bool tcbdbcurout(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object of writer connection.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned when the cursor is at invalid position.</dd>
<dd>After deletion, the cursor is moved to the next record if possible.</dd>
</dl>

<p>The function `tcbdbcurkey' is used in order to get the key of the record where the cursor object is.</p>

<dl class="api">
<dt><code>void *tcbdbcurkey(BDBCUR *<var>cur</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the key, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbcurkey2' is used in order to get the key string of the record where the cursor object is.</p>

<dl class="api">
<dt><code>char *tcbdbcurkey2(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>If successful, the return value is the string of the key, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbcurkey3' is used in order to get the key of the record where the cursor object is, as a volatile buffer.</p>

<dl class="api">
<dt><code>const void *tcbdbcurkey3(BDBCUR *<var>cur</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the key, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is volatile and it may be spoiled by another operation of the database, the data should be copied into another involatile buffer immediately.</dd>
</dl>

<p>The function `tcbdbcurval' is used in order to get the value of the record where the cursor object is.</p>

<dl class="api">
<dt><code>void *tcbdbcurval(BDBCUR *<var>cur</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbcurval2' is used in order to get the value string of the record where the cursor object is.</p>

<dl class="api">
<dt><code>char *tcbdbcurval2(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>If successful, the return value is the string of the value, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbcurval3' is used in order to get the value of the record where the cursor object is, as a volatile buffer.</p>

<dl class="api">
<dt><code>const void *tcbdbcurval3(BDBCUR *<var>cur</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is volatile and it may be spoiled by another operation of the database, the data should be copied into another involatile buffer immediately.</dd>
</dl>

<p>The function `tcbdbcurrec' is used in order to get the key and the value of the record where the cursor object is.</p>

<dl class="api">
<dt><code>bool tcbdbcurrec(BDBCUR *<var>cur</var>, TCXSTR *<var>kxstr</var>, TCXSTR *<var>vxstr</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>kxstr</var>' specifies the object into which the key is wrote down.</dd>
<dd>`<var>vxstr</var>' specifies the object into which the value is wrote down.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned when the cursor is at invalid position.</dd>
</dl>

<h3 id="tcbdbapi_example">コード例</h3>

<p>B+木データベースを使ったコード例を以下に示します。</p>

<pre>#include &lt;tcutil.h&gt;
#include &lt;tcbdb.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;

int main(int argc, char **argv){
  TCBDB *bdb;
  BDBCUR *cur;
  int ecode;
  char *key, *value;

  /* オブジェクトを作成する */
  bdb = tcbdbnew();

  /* データベースを開く */
  if(!tcbdbopen(bdb, "casket.tcb", BDBOWRITER | BDBOCREAT)){
    ecode = tcbdbecode(bdb);
    fprintf(stderr, "open error: %s\n", tcbdberrmsg(ecode));
  }

  /* レコードを格納する */
  if(!tcbdbput2(bdb, "foo", "hop") ||
     !tcbdbput2(bdb, "bar", "step") ||
     !tcbdbput2(bdb, "baz", "jump")){
    ecode = tcbdbecode(bdb);
    fprintf(stderr, "put error: %s\n", tcbdberrmsg(ecode));
  }

  /* レコードを取得する */
  value = tcbdbget2(bdb, "foo");
  if(value){
    printf("%s\n", value);
    free(value);
  } else {
    ecode = tcbdbecode(bdb);
    fprintf(stderr, "get error: %s\n", tcbdberrmsg(ecode));
  }

  /* 横断的にレコードを参照する */
  cur = tcbdbcurnew(bdb);
  tcbdbcurfirst(cur);
  while((key = tcbdbcurkey2(cur)) != NULL){
    value = tcbdbcurval2(cur);
    if(value){
      printf("%s:%s\n", key, value);
      free(value);
    }
    free(key);
    tcbdbcurnext(cur);
  }
  tcbdbcurdel(cur);

  /* データベースを閉じる */
  if(!tcbdbclose(bdb)){
    ecode = tcbdbecode(bdb);
    fprintf(stderr, "close error: %s\n", tcbdberrmsg(ecode));
  }

  /* オブジェクトを破棄する */
  tcbdbdel(bdb);

  return 0;
}
</pre>

<h3 id="tcbdbapi_cli">CLI</h3>

<p>B+木データベースAPIを簡単に利用するために、コマンドラインインターフェイスとして `<code>tcbtest</code>' と `<code>tcbmttest</code>' と `<code>tcbmgr</code>' が提供されます。</p>

<p>コマンド `<code>tcbtest</code>' は、B+木データベースAPIの機能テストや性能テストに用いるツールです。以下の書式で用います。`<var>path</var>' はデータベースファイルのパスを指定し、`<var>rnum</var>' は試行回数を指定し、`<var>lmemb</var>' はリーフ内メンバ数を指定し、`<var>nmemb</var>' は非リーフ内メンバ数を指定し、`<var>bnum</var>' はバケット数を指定し、`<var>apow</var>' はアラインメント力を指定し、`<var>fpow</var>' はフリーブロックプール力を指定します。</p>

<dl class="api">
<dt><code>tcbtest write [-mt] [-cd|-ci|-cj] [-tl] [-td|-tb|-tt|-tx] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-ls <var>num</var>] [-ca <var>num</var>] [-nl|-nb] [-rnd] <var>path</var> <var>rnum</var> [<var>lmemb</var> [<var>nmemb</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]]]</code></dt>
<dd>`00000001'、`00000002' のように変化する8バイトのキーと値を連続してデータベースに追加する。</dd>
<dt><code>tcbtest read [-mt] [-cd|-ci|-cj] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-wb] [-rnd] <var>path</var></code></dt>
<dd>上記で生成したデータベースの全レコードを検索する。</dd>
<dt><code>tcbtest remove [-mt] [-cd|-ci|-cj] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-rnd] <var>path</var></code></dt>
<dd>上記で生成したデータベースの全レコードを削除する。</dd>
<dt><code>tcbtest rcat [-mt] [-cd|-ci|-cj] [-tl] [-td|-tb|-tt|-tx] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-ls <var>num</var>] [-ca <var>num</var>] [-nl|-nb] [-pn <var>num</var>] [-dai|-dad|-rl|-ru] <var>path</var> <var>rnum</var> [<var>lmemb</var> [<var>nmemb</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]]]</code></dt>
<dd>キーがある程度重複するようにレコードの追加を行い、連結モードで処理する。</dd>
<dt><code>tcbtest queue [-mt] [-cd|-ci|-cj] [-tl] [-td|-tb|-tt|-tx] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-ls <var>num</var>] [-ca <var>num</var>] [-nl|-nb] <var>path</var> <var>rnum</var> [<var>lmemb</var> [<var>nmemb</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]]]</code></dt>
<dd>キューの出し入れを行う。</dd>
<dt><code>tcbtest misc [-mt] [-tl] [-td|-tb|-tt|-tx] [-nl|-nb] <var>path</var> <var>rnum</var></code></dt>
<dd>各種操作の組み合わせテストを行う。</dd>
<dt><code>tcbtest wicked [-mt] [-tl] [-td|-tb|-tt|-tx] [-nl|-nb] <var>path</var> <var>rnum</var></code></dt>
<dd>各種更新操作を無作為に選択して実行する。</dd>
</dl>

<p>各オプションは以下の機能を持ちます</p>

<ul class="options">
<li><code>-mt</code> : 関数 `tcbdbsetmutex' を呼び出す。</li>
<li><code>-cd</code> : 比較関数 `tccmpdecimal' を利用する。</li>
<li><code>-ci</code> : 比較関数 `tccmpint32' を利用する。</li>
<li><code>-cj</code> : 比較関数 `tccmpint64' を利用する。</li>
<li><code>-tl</code> : オプション `BDBTLARGE' を有効にする。</li>
<li><code>-td</code> : オプション `BDBTDEFLATE' を有効にする。</li>
<li><code>-tb</code> : オプション `BDBTBZIP' を有効にする。</li>
<li><code>-tt</code> : オプション `BDBTTCBS' を有効にする。</li>
<li><code>-tx</code> : オプション `BDBTEXCODEC' を有効にする。</li>
<li><code>-lc <var>num</var></code> : リーフノード用キャッシュの最大数を指定する。</li>
<li><code>-nc <var>num</var></code> : 非リーフノード用キャッシュの最大数を指定する。</li>
<li><code>-xm <var>num</var></code> : 拡張マップメモリのサイズを指定する。</li>
<li><code>-df <var>num</var></code> : 自動デフラグの単位ステップ数を指定する。</li>
<li><code>-ls <var>num</var></code> : リーフノードの最大サイズを指定する。</li>
<li><code>-ca <var>num</var></code> : レコードの最大収容数を指定する。</li>
<li><code>-nl</code> : オプション `BDBNOLCK' を有効にする。</li>
<li><code>-nb</code> : オプション `BDBLCKNB' を有効にする。</li>
<li><code>-rnd</code> : キーを無作為に選択する。</li>
<li><code>-wb</code> : 関数 `tcbdbget' の代わりに関数 `tcbdbget3' を用いる。</li>
<li><code>-pn <var>num</var></code> : パターン数を指定する。</li>
<li><code>-dai</code> : 関数 `tcbdbputcat' の代わりに関数 `tcbdbaddint' を用いる。</li>
<li><code>-dad</code> : 関数 `tcbdbputcat' の代わりに関数 `tcbdbadddouble' を用いる。</li>
<li><code>-rl</code> : 値を無作為な長さにする。</li>
<li><code>-ru</code> : 更新操作を無作為に選択する。</li>
</ul>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<p>コマンド `<code>tcbmttest</code>' は、B+木データベースAPIの機能テストをマルチスレッドで行うツールです。以下の書式で用います。`<var>path</var>' はデータベースファイルのパスを指定し、`<var>tnum</var>' はスレッド数を指定し、`<var>rnum</var>' は試行回数を指定し、`<var>lmemb</var>' はリーフ内メンバ数を指定し、`<var>nmemb</var>' は非リーフ内メンバ数を指定し、`<var>bnum</var>' はバケット数を指定し、`<var>apow</var>' はアラインメント力を指定し、`<var>fpow</var>' はフリーブロックプール力を指定します。</p>

<dl class="api">
<dt><code>tcbmttest write [-tl] [-td|-tb|-tt|-tx] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-rnd] <var>path</var> <var>tnum</var> <var>rnum</var> [<var>lmemb</var> [<var>nmemb</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]]]</code></dt>
<dd>`00000001'、`00000002' のように変化する8バイトのキーと値を連続してデータベースに追加する。</dd>
<dt><code>tcbmttest read [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-wb] [-rnd] <var>path</var> <var>tnum</var></code></dt>
<dd>上記で生成したデータベースの全レコードを検索する。</dd>
<dt><code>tcbmttest remove [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-rnd] <var>path</var> <var>tnum</var></code></dt>
<dd>上記で生成したデータベースの全レコードを削除する。</dd>
<dt><code>tcbmttest wicked [-tl] [-td|-tb|-tt|-tx] [-nl|-nb] [-nc] <var>path</var> <var>tnum</var> <var>rnum</var></code></dt>
<dd>各種更新操作を無作為に選択して実行する。</dd>
<dt><code>tcbmttest typical [-tl] [-td|-tb|-tt|-tx] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-nc] [-rr <var>num</var>] <var>path</var> <var>tnum</var> <var>rnum</var> [<var>lmemb</var> [<var>nmemb</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]]]</code></dt>
<dd>典型的な操作を無作為に選択して実行する。</dd>
<dt><code>tcbmttest race [-tl] [-td|-tb|-tt|-tx] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] <var>path</var> <var>tnum</var> <var>rnum</var> [<var>lmemb</var> [<var>nmemb</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]]]</code></dt>
<dd>レースコンディション検出のテストを行う。</dd>
</dl>

<p>各オプションは以下の機能を持ちます</p>

<ul class="options">
<li><code>-tl</code> : オプション `BDBTLARGE' を有効にする。</li>
<li><code>-td</code> : オプション `BDBTDEFLATE' を有効にする。</li>
<li><code>-tb</code> : オプション `BDBTBZIP' を有効にする。</li>
<li><code>-tt</code> : オプション `BDBTTCBS' を有効にする。</li>
<li><code>-tx</code> : オプション `BDBTEXCODEC' を有効にする。</li>
<li><code>-xm <var>num</var></code> : 拡張マップメモリのサイズを指定する。</li>
<li><code>-df <var>num</var></code> : 自動デフラグの単位ステップ数を指定する。</li>
<li><code>-nl</code> : オプション `BDBNOLCK' を有効にする。</li>
<li><code>-nb</code> : オプション `BDBLCKNB' を有効にする。</li>
<li><code>-rnd</code> : キーを無作為に選択する。</li>
<li><code>-wb</code> : 関数 `tcbdbget' の代わりに関数 `tcbdbget3' を用いる。</li>
<li><code>-nc</code> : 比較テストを行わない。</li>
<li><code>-rr <var>num</var></code> : 読み込み操作の割合を百分率で指定する。</li>
</ul>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<p>コマンド `<code>tcbmgr</code>' は、B+木データベースAPIやそのアプリケーションのテストやデバッグに役立つツールです。以下の書式で用います。`<var>path</var>' はデータベースファイルのパスを指定し、`<var>lmemb</var>' はリーフ内メンバ数を指定し、`<var>nmemb</var>' は非リーフ内メンバ数を指定し、`<var>bnum</var>' はバケット数を指定し、`<var>apow</var>' はアラインメント力を指定し、`<var>fpow</var>' はフリーブロックプール力を指定し、`<var>key</var>' はレコードのキーを指定し、`<var>value</var>' はレコードの値を指定し、`<var>file</var>' は入力ファイルを指定します。</p>

<dl class="api">
<dt><code>tcbmgr create [-cd|-ci|-cj] [-tl] [-td|-tb|-tt|-tx] <var>path</var> [<var>lmemb</var> [<var>nmemb</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]]]</code></dt>
<dd>データベースファイルを作成する。</dd>
<dt><code>tcbmgr inform [-nl|-nb] <var>path</var></code></dt>
<dd>データベースの雑多な情報を出力する。</dd>
<dt><code>tcbmgr put [-cd|-ci|-cj] [-nl|-nb] [-sx] [-dk|-dc|-dai|-dad] <var>path</var> <var>key</var> <var>value</var></code></dt>
<dd>レコードを追加する。</dd>
<dt><code>tcbmgr out [-cd|-ci|-cj] [-nl|-nb] [-sx] <var>path</var> <var>key</var></code></dt>
<dd>レコードを削除する。</dd>
<dt><code>tcbmgr get [-cd|-ci|-cj] [-nl|-nb] [-sx] [-px] [-pz] <var>path</var> <var>key</var></code></dt>
<dd>レコードの値を取得して標準出力する。</dd>
<dt><code>tcbmgr list [-cd|-ci|-cj] [-nl|-nb] [-m <var>num</var>] [-bk] [-pv] [-px] [-j <var>str</var>] [-rb <var>bkey</var> <var>ekey</var>] [-fm <var>str</var>] <var>path</var></code></dt>
<dd>全てのレコードのキーを改行で区切って標準出力する。</dd>
<dt><code>tcbmgr optimize [-cd|-ci|-cj] [-tl] [-td|-tb|-tt|-tx] [-tz] [-nl|-nb] [-df] <var>path</var> [<var>lmemb</var> [<var>nmemb</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]]]</code></dt>
<dd>データベースを最適化する。</dd>
<dt><code>tcbmgr importtsv [-nl|-nb] [-sc] <var>path</var> [<var>file</var>]</code></dt>
<dd>TSVファイルの各行をキーと値とみなしてレコードを登録する。</dd>
<dt><code>tcbmgr version</code></dt>
<dd>Tokyo Cabinetのバージョン情報を標準出力する。</dd>
</dl>

<p>各オプションは以下の機能を持ちます</p>

<ul class="options">
<li><code>-cd</code> : 比較関数 `tccmpdecimal' を利用する。</li>
<li><code>-ci</code> : 比較関数 `tccmpint32' を利用する。</li>
<li><code>-cj</code> : 比較関数 `tccmpint64' を利用する。</li>
<li><code>-tl</code> : オプション `BDBTLARGE' を有効にする。</li>
<li><code>-td</code> : オプション `BDBTDEFLATE' を有効にする。</li>
<li><code>-tb</code> : オプション `BDBTBZIP' を有効にする。</li>
<li><code>-tt</code> : オプション `BDBTTCBS' を有効にする。</li>
<li><code>-tx</code> : オプション `BDBTEXCODEC' を有効にする。</li>
<li><code>-nl</code> : オプション `BDBNOLCK' を有効にする。</li>
<li><code>-nb</code> : オプション `BDBLCKNB' を有効にする。</li>
<li><code>-sx</code> : 入力を16進数の文字列で行う。</li>
<li><code>-dk</code> : 関数 `tcbdbput' の代わりに関数 `tcbdbputkeep' を用いる。</li>
<li><code>-dc</code> : 関数 `tcbdbput' の代わりに関数 `tcbdbputcat' を用いる。</li>
<li><code>-dd</code> : 関数 `tcbdbput' の代わりに関数 `tcbdbputdup' を用いる。</li>
<li><code>-db</code> : 関数 `tcbdbput' の代わりに関数 `tcbdbputdupback' を用いる。</li>
<li><code>-dai</code> : 関数 `tcbdbput' の代わりに関数 `tcbdbaddint' を用いる。</li>
<li><code>-dad</code> : 関数 `tcbdbput' の代わりに関数 `tcbdbadddouble' を用いる。</li>
<li><code>-px</code> : 出力を16進数の文字列で行う。</li>
<li><code>-pz</code> : 出力の末尾に改行を付加しない。</li>
<li><code>-m <var>num</var></code> : 出力の最大数を指定する。</li>
<li><code>-bk</code> : 走査を逆方向で行う。</li>
<li><code>-pv</code> : レコードの値も出力する。</li>
<li><code>-j <var>str</var></code> : カーソルを指定位置にジャンプさせる。</li>
<li><code>-rb <var>bkey</var> <var>ekey</var></code> : 処理対象を範囲指定する。</li>
<li><code>-fm <var>str</var></code> : キーの接頭辞を指定する。</li>
<li><code>-tz</code> : オプション `UINT8_MAX' を有効にする。</li>
<li><code>-df</code> : デフラグのみを行う。</li>
<li><code>-sc</code> : キーを小文字に正規化する。</li>
</ul>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<hr />

<h2 id="tcfdbapi">固定長データベースAPI</h2>

<p>固定長データベースは、固定長の要素からなる配列を単一のファイルに記録したデータベースです。それを扱うのが固定長データベースAPIです。`<code>tcfdb.h</code>' にAPIの仕様の完全な記述があります。</p>

<h3 id="tcfdbapi_description">概要</h3>

<p>固定長データベースAPIを使うためには、`<code>tcutil.h</code>'、`<code>tcfdb.h</code>' および関連する標準ヘッダファイルをインクルードしてください。通常、ソースファイルの冒頭付近で以下の記述を行います。</p>

<dl>
<dt><code>#include &lt;tcutil.h&gt;</code></dt>
<dt><code>#include &lt;tcfdb.h&gt;</code></dt>
<dt><code>#include &lt;stdlib.h&gt;</code></dt>
<dt><code>#include &lt;stdbool.h&gt;</code></dt>
<dt><code>#include &lt;stdint.h&gt;</code></dt>
</dl>

<p>固定長データベースを扱う際には、`<code>TCFDB</code>' 型へのポインタをオブジェクトとして用います。固定長データベースオブジェクトは、関数 `<code>tcfdbnew</code>' で作成し、関数 `<code>tcfdbdel</code>' で破棄します。作成したオブジェクトを使い終わったら必ず破棄してください。そうしないとメモリリークが発生します。</p>

<p>レコードの格納や探索を行う前提として、固定長データベースオブジェクトをデータベースファイルと接続させる必要があります。データベースファイルを開いて接続するには関数 `<code>tcfdbopen</code>' を用い、接続の解除してファイルを閉じるには関数 `<code>tcfdbclose</code>' を用います。開いたデータベースファイルは必ず閉じてください。そうしないとデータベースファイルが壊れたり格納したデータが失われたりする可能性があります。単一のプロセス内で複数のデータベースオブジェクトが同じデータベースファイルを同時に開くことはできません。</p>

<h3 id="tcfdbapi_api">API（英語スマソ）</h3>

<p>The function `tcfdberrmsg' is used in order to get the message string corresponding to an error code.</p>

<dl class="api">
<dt><code>const char *tcfdberrmsg(int <var>ecode</var>);</code></dt>
<dd>`<var>ecode</var>' specifies the error code.</dd>
<dd>The return value is the message string of the error code.</dd>
</dl>

<p>The function `tcfdbnew' is used in order to create a fixed-length database object.</p>

<dl class="api">
<dt><code>TCFDB *tcfdbnew(void);</code></dt>
<dd>The return value is the new fixed-length database object.</dd>
</dl>

<p>The function `tcfdbdel' is used in order to delete a fixed-length database object.</p>

<dl class="api">
<dt><code>void tcfdbdel(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>If the database is not closed, it is closed implicitly.  Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tcfdbecode' is used in order to get the last happened error code of a fixed-length database object.</p>

<dl class="api">
<dt><code>int tcfdbecode(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>The return value is the last happened error code.</dd>
<dd>The following error codes are defined: `TCESUCCESS' for success, `TCETHREAD' for threading error, `TCEINVALID' for invalid operation, `TCENOFILE' for file not found, `TCENOPERM' for no permission, `TCEMETA' for invalid meta data, `TCERHEAD' for invalid record header, `TCEOPEN' for open error, `TCECLOSE' for close error, `TCETRUNC' for trunc error, `TCESYNC' for sync error, `TCESTAT' for stat error, `TCESEEK' for seek error, `TCEREAD' for read error, `TCEWRITE' for write error, `TCEMMAP' for mmap error, `TCELOCK' for lock error, `TCEUNLINK' for unlink error, `TCERENAME' for rename error, `TCEMKDIR' for mkdir error, `TCERMDIR' for rmdir error, `TCEKEEP' for existing record, `TCENOREC' for no record found, and `TCEMISC' for miscellaneous error.</dd>
</dl>

<p>The function `tcfdbsetmutex' is used in order to set mutual exclusion control of a fixed-length database object for threading.</p>

<dl class="api">
<dt><code>bool tcfdbsetmutex(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object which is not opened.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the mutual exclusion control is needed if the object is shared by plural threads and this function should be called before the database is opened.</dd>
</dl>

<p>The function `tcfdbtune' is used in order to set the tuning parameters of a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbtune(TCFDB *<var>fdb</var>, int32_t <var>width</var>, int64_t <var>limsiz</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object which is not opened.</dd>
<dd>`<var>width</var>' specifies the width of the value of each record.  If it is not more than 0, the default value is specified.  The default value is 255.</dd>
<dd>`<var>limsiz</var>' specifies the limit size of the database file.  If it is not more than 0, the default value is specified.  The default value is 268435456.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the tuning parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tcfdbopen' is used in order to open a database file and connect a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbopen(TCFDB *<var>fdb</var>, const char *<var>path</var>, int <var>omode</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object which is not opened.</dd>
<dd>`<var>path</var>' specifies the path of the database file.</dd>
<dd>`<var>omode</var>' specifies the connection mode: `FDBOWRITER' as a writer, `FDBOREADER' as a reader.  If the mode is `FDBOWRITER', the following may be added by bitwise-or: `FDBOCREAT', which means it creates a new database if not exist, `FDBOTRUNC', which means it creates a new database regardless if one exists, `FDBOTSYNC', which means every transaction synchronizes updated contents with the device.  Both of `FDBOREADER' and `FDBOWRITER' can be added to by bitwise-or: `FDBONOLCK', which means it opens the database file without file locking, or `FDBOLCKNB', which means locking is performed without blocking.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcfdbclose' is used in order to close a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbclose(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update of a database is assured to be written when the database is closed.  If a writer opens a database but does not close it appropriately, the database will be broken.</dd>
</dl>

<p>The function `tcfdbput' is used in order to store a record into a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbput(TCFDB *<var>fdb</var>, int64_t <var>id</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>id</var>' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDPREV', the number less by one than the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.  If it is `FDBIDNEXT', the number greater by one than the maximum ID number of existing records is specified.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.  If the size of the value is greater than the width tuning parameter of the database, the size is cut down to the width.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcfdbput2' is used in order to store a record with a decimal key into a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbput2(TCFDB *<var>fdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "prev", the number less by one than the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.  If it is "next", the number greater by one than the maximum ID number of existing records is specified.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.  If the size of the value is greater than the width tuning parameter of the database, the size is cut down to the width.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcfdbput3' is used in order to store a string record with a decimal key into a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbput3(TCFDB *<var>fdb</var>, const char *<var>kstr</var>, const void *<var>vstr</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "prev", the number less by one than the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.  If it is "next", the number greater by one than the maximum ID number of existing records is specified.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcfdbputkeep' is used in order to store a new record into a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbputkeep(TCFDB *<var>fdb</var>, int64_t <var>id</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>id</var>' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDPREV', the number less by one than the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.  If it is `FDBIDNEXT', the number greater by one than the maximum ID number of existing records is specified.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.  If the size of the value is greater than the width tuning parameter of the database, the size is cut down to the width.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcfdbputkeep2' is used in order to store a new record with a decimal key into a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbputkeep2(TCFDB *<var>fdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "prev", the number less by one than the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.  If it is "next", the number greater by one than the maximum ID number of existing records is specified.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.  If the size of the value is greater than the width tuning parameter of the database, the size is cut down to the width.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcfdbputkeep3' is used in order to store a new string record with a decimal key into a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbputkeep3(TCFDB *<var>fdb</var>, const char *<var>kstr</var>, const void *<var>vstr</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "prev", the number less by one than the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.  If it is "next", the number greater by one than the maximum ID number of existing records is specified.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcfdbputcat' is used in order to concatenate a value at the end of the existing record in a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbputcat(TCFDB *<var>fdb</var>, int64_t <var>id</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>id</var>' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDPREV', the number less by one than the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.  If it is `FDBIDNEXT', the number greater by one than the maximum ID number of existing records is specified.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.  If the size of the value is greater than the width tuning parameter of the database, the size is cut down to the width.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcfdbputcat2' is used in order to concatenate a value with a decimal key in a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbputcat2(TCFDB *<var>fdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "prev", the number less by one than the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.  If it is "next", the number greater by one than the maximum ID number of existing records is specified.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.  If the size of the value is greater than the width tuning parameter of the database, the size is cut down to the width.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcfdbputcat3' is used in order to concatenate a string value with a decimal key in a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbputcat3(TCFDB *<var>fdb</var>, const char *<var>kstr</var>, const void *<var>vstr</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "prev", the number less by one than the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.  If it is "next", the number greater by one than the maximum ID number of existing records is specified.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcfdbout' is used in order to remove a record of a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbout(TCFDB *<var>fdb</var>, int64_t <var>id</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>id</var>' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcfdbout2' is used in order to remove a record with a decimal key of a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbout2(TCFDB *<var>fdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcfdbout3' is used in order to remove a string record with a decimal key of a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbout3(TCFDB *<var>fdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcfdbget' is used in order to retrieve a record in a fixed-length database object.</p>

<dl class="api">
<dt><code>void *tcfdbget(TCFDB *<var>fdb</var>, int64_t <var>id</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>id</var>' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcfdbget2' is used in order to retrieve a record with a decimal key in a fixed-length database object.</p>

<dl class="api">
<dt><code>void *tcfdbget2(TCFDB *<var>fdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcfdbget3' is used in order to retrieve a string record with a decimal key in a fixed-length database object.</p>

<dl class="api">
<dt><code>char *tcfdbget3(TCFDB *<var>fdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.</dd>
<dd>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcfdbget4' is used in order to retrieve a record in a fixed-length database object and write the value into a buffer.</p>

<dl class="api">
<dt><code>int tcfdbget4(TCFDB *<var>fdb</var>, int64_t <var>id</var>, void *<var>vbuf</var>, int <var>max</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>id</var>' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the buffer into which the value of the corresponding record is written.</dd>
<dd>`<var>max</var>' specifies the size of the buffer.</dd>
<dd>If successful, the return value is the size of the written data, else, it is -1.  -1 is returned if no record corresponds to the specified key.</dd>
<dd>Note that an additional zero code is not appended at the end of the region of the writing buffer.</dd>
</dl>

<p>The function `tcfdbvsiz' is used in order to get the size of the value of a record in a fixed-length database object.</p>

<dl class="api">
<dt><code>int tcfdbvsiz(TCFDB *<var>fdb</var>, int64_t <var>id</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>id</var>' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tcfdbvsiz2' is used in order to get the size of the value with a decimal key in a fixed-length database object.</p>

<dl class="api">
<dt><code>int tcfdbvsiz2(TCFDB *<var>fdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tcfdbvsiz3' is used in order to get the size of the string value with a decimal key in a fixed-length database object.</p>

<dl class="api">
<dt><code>int tcfdbvsiz3(TCFDB *<var>fdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tcfdbiterinit' is used in order to initialize the iterator of a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbiterinit(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The iterator is used in order to access the key of every record stored in a database.</dd>
</dl>

<p>The function `tcfdbiternext' is used in order to get the next ID number of the iterator of a fixed-length database object.</p>

<dl class="api">
<dt><code>uint64_t tcfdbiternext(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>If successful, the return value is the next ID number of the iterator, else, it is 0.  0 is returned when no record is to be get out of the iterator.</dd>
<dd>It is possible to access every record by iteration of calling this function.  It is allowed to update or remove records whose keys are fetched while the iteration.  The order of this traversal access method is ascending of the ID number.</dd>
</dl>

<p>The function `tcfdbiternext2' is used in order to get the next decimay key of the iterator of a fixed-length database object.</p>

<dl class="api">
<dt><code>void *tcfdbiternext2(TCFDB *<var>fdb</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the next decimal key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  It is allowed to update or remove records whose keys are fetched while the iteration.  The order of this traversal access method is ascending of the ID number.</dd>
</dl>

<p>The function `tcfdbiternext3' is used in order to get the next decimay key string of the iterator of a fixed-length database object.</p>

<dl class="api">
<dt><code>char *tcfdbiternext3(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>If successful, the return value is the string of the next decimal key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  It is allowed to update or remove records whose keys are fetched while the iteration.  The order of this traversal access method is ascending of the ID number.</dd>
</dl>

<p>The function `tcfdbrange' is used in order to get range matching ID numbers in a fixed-length database object.</p>

<dl class="api">
<dt><code>uint64_t *tcfdbrange(TCFDB *<var>fdb</var>, int64_t <var>lower</var>, int64_t <var>upper</var>, int <var>max</var>, int *<var>np</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>lower</var>' specifies the lower limit of the range.  If it is `FDBIDMIN', the minimum ID is specified.</dd>
<dd>`<var>upper</var>' specifies the upper limit of the range.  If it is `FDBIDMAX', the maximum ID is specified.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>`<var>np</var>' specifies the pointer to the variable into which the number of elements of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to an array of ID numbers of the corresponding records.  `NULL' is returned on failure.  This function does never fail.  It returns an empty array even if no key corresponds.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcfdbrange2' is used in order to get range matching decimal keys in a fixed-length database object.</p>

<dl class="api">
<dt><code>TCLIST *tcfdbrange2(TCFDB *<var>fdb</var>, const void *<var>lbuf</var>, int <var>lsiz</var>, const void *<var>ubuf</var>, int <var>usiz</var>, int <var>max</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>lbuf</var>' specifies the pointer to the region of the lower key.  If it is "min", the minimum ID number of existing records is specified.</dd>
<dd>`<var>lsiz</var>' specifies the size of the region of the lower key.</dd>
<dd>`<var>ubuf</var>' specifies the pointer to the region of the upper key.  If it is "max", the maximum ID number of existing records is specified.</dd>
<dd>`<var>usiz</var>' specifies the size of the region of the upper key.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding decimal keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</dd>
</dl>

<p>The function `tcfdbrange3' is used in order to get range matching decimal keys with strings in a fixed-length database object.</p>

<dl class="api">
<dt><code>TCLIST *tcfdbrange3(TCFDB *<var>fdb</var>, const char *<var>lstr</var>, const char *<var>ustr</var>, int <var>max</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>lstr</var>' specifies the string of the lower key.  If it is "min", the minimum ID number of existing records is specified.</dd>
<dd>`<var>ustr</var>' specifies the string of the upper key.  If it is "max", the maximum ID number of existing records is specified.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding decimal keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</dd>
</dl>

<p>The function `tcfdbrange4' is used in order to get keys with an interval notation in a fixed-length database object.</p>

<dl class="api">
<dt><code>TCLIST *tcfdbrange4(TCFDB *<var>fdb</var>, const void *<var>ibuf</var>, int <var>isiz</var>, int <var>max</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>ibuf</var>' specifies the pointer to the region of the interval notation.</dd>
<dd>`<var>isiz</var>' specifies the size of the region of the interval notation.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding decimal keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</dd>
</dl>

<p>The function `tcfdbrange5' is used in order to get keys with an interval notation string in a fixed-length database object.</p>

<dl class="api">
<dt><code>TCLIST *tcfdbrange5(TCFDB *<var>fdb</var>, const void *<var>istr</var>, int <var>max</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>istr</var>' specifies the pointer to the region of the interval notation string.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding decimal keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</dd>
</dl>

<p>The function `tcfdbaddint' is used in order to add an integer to a record in a fixed-length database object.</p>

<dl class="api">
<dt><code>int tcfdbaddint(TCFDB *<var>fdb</var>, int64_t <var>id</var>, int <var>num</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>id</var>' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDPREV', the number less by one than the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.  If it is `FDBIDNEXT', the number greater by one than the maximum ID number of existing records is specified.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>If successful, the return value is the summation value, else, it is `INT_MIN'.</dd>
<dd>If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcfdbadddouble' is used in order to add a real number to a record in a fixed-length database object.</p>

<dl class="api">
<dt><code>double tcfdbadddouble(TCFDB *<var>fdb</var>, int64_t <var>id</var>, double <var>num</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>id</var>' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDPREV', the number less by one than the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.  If it is `FDBIDNEXT', the number greater by one than the maximum ID number of existing records is specified.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>If successful, the return value is the summation value, else, it is Not-a-Number.</dd>
<dd>If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcfdbsync' is used in order to synchronize updated contents of a fixed-length database object with the file and the device.</p>

<dl class="api">
<dt><code>bool tcfdbsync(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function is useful when another process connects to the same database file.</dd>
</dl>

<p>The function `tcfdboptimize' is used in order to optimize the file of a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdboptimize(TCFDB *<var>fdb</var>, int32_t <var>width</var>, int64_t <var>limsiz</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>`<var>width</var>' specifies the width of the value of each record.  If it is not more than 0, the current setting is not changed.</dd>
<dd>`<var>limsiz</var>' specifies the limit size of the database file.  If it is not more than 0, the current setting is not changed.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcfdbvanish' is used in order to remove all records of a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbvanish(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcfdbcopy' is used in order to copy the database file of a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbcopy(TCFDB *<var>fdb</var>, const char *<var>path</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>`<var>path</var>' specifies the path of the destination file.  If it begins with `@', the trailing substring is executed as a command line.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if the executed command returns non-zero code.</dd>
<dd>The database file is assured to be kept synchronized and not modified while the copying or executing operation is in progress.  So, this function is useful to create a backup file of the database file.</dd>
</dl>

<p>The function `tcfdbtranbegin' is used in order to begin the transaction of a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbtranbegin(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The database is locked by the thread while the transaction so that only one transaction can be activated with a database object at the same time.  Thus, the serializable isolation level is assumed if every database operation is performed in the transaction.  All updated regions are kept track of by write ahead logging while the transaction.  If the database is closed during transaction, the transaction is aborted implicitly.</dd>
</dl>

<p>The function `tcfdbtrancommit' is used in order to commit the transaction of a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbtrancommit(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update in the transaction is fixed when it is committed successfully.</dd>
</dl>

<p>The function `tcfdbtranabort' is used in order to abort the transaction of a fixed-length database object.</p>

<dl class="api">
<dt><code>bool tcfdbtranabort(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update in the transaction is discarded when it is aborted.  The state of the database is rollbacked to before transaction.</dd>
</dl>

<p>The function `tcfdbpath' is used in order to get the file path of a fixed-length database object.</p>

<dl class="api">
<dt><code>const char *tcfdbpath(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>The return value is the path of the database file or `NULL' if the object does not connect to any database file.</dd>
</dl>

<p>The function `tcfdbrnum' is used in order to get the number of records of a fixed-length database object.</p>

<dl class="api">
<dt><code>uint64_t tcfdbrnum(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>The return value is the number of records or 0 if the object does not connect to any database file.</dd>
</dl>

<p>The function `tcfdbfsiz' is used in order to get the size of the database file of a fixed-length database object.</p>

<dl class="api">
<dt><code>uint64_t tcfdbfsiz(TCFDB *<var>fdb</var>);</code></dt>
<dd>`<var>fdb</var>' specifies the fixed-length database object.</dd>
<dd>The return value is the size of the database file or 0 if the object does not connect to any database file.</dd>
</dl>

<h3 id="tcfdbapi_example">コード例</h3>

<p>固定長データベースを使ったコード例を以下に示します。</p>

<pre>#include &lt;tcutil.h&gt;
#include &lt;tcfdb.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;

int main(int argc, char **argv){
  TCFDB *fdb;
  int ecode;
  char *key, *value;

  /* オブジェクトを作成する */
  fdb = tcfdbnew();

  /* データベースを開く */
  if(!tcfdbopen(fdb, "casket.tcf", FDBOWRITER | FDBOCREAT)){
    ecode = tcfdbecode(fdb);
    fprintf(stderr, "open error: %s\n", tcfdberrmsg(ecode));
  }

  /* レコードを格納する */
  if(!tcfdbput3(fdb, "1", "one") ||
     !tcfdbput3(fdb, "12", "twelve") ||
     !tcfdbput3(fdb, "144", "one forty four")){
    ecode = tcfdbecode(fdb);
    fprintf(stderr, "put error: %s\n", tcfdberrmsg(ecode));
  }

  /* レコードを取得する */
  value = tcfdbget3(fdb, "1");
  if(value){
    printf("%s\n", value);
    free(value);
  } else {
    ecode = tcfdbecode(fdb);
    fprintf(stderr, "get error: %s\n", tcfdberrmsg(ecode));
  }

  /* 横断的にレコードを参照する */
  tcfdbiterinit(fdb);
  while((key = tcfdbiternext3(fdb)) != NULL){
    value = tcfdbget3(fdb, key);
    if(value){
      printf("%s:%s\n", key, value);
      free(value);
    }
    free(key);
  }

  /* データベースを閉じる */
  if(!tcfdbclose(fdb)){
    ecode = tcfdbecode(fdb);
    fprintf(stderr, "close error: %s\n", tcfdberrmsg(ecode));
  }

  /* オブジェクトを破棄する */
  tcfdbdel(fdb);

  return 0;
}
</pre>

<h3 id="tcfdbapi_cli">CLI</h3>

<p>固定長データベースAPIを簡単に利用するために、コマンドラインインターフェイスとして `<code>tcftest</code>' と `<code>tcfmttest</code>' と `<code>tcfmgr</code>' が提供されます。</p>

<p>コマンド `<code>tcftest</code>' は、ハッシュデータベースAPIの機能テストや性能テストに用いるツールです。以下の書式で用います。`<var>path</var>' はデータベースファイルのパスを指定し、`<var>rnum</var>' は試行回数を指定し、`<var>width</var>' は各レコードの値の幅を指定し、`<var>limsiz</var>' はデータベースファイルの制限サイズを指定します。</p>

<dl class="api">
<dt><code>tcftest write [-mt] [-nl|-nb] [-rnd] <var>path</var> <var>rnum</var> [<var>width</var> [<var>limsiz</var>]]</code></dt>
<dd>`00000001'、`00000002' のように変化する8バイトのキーと値を連続してデータベースに追加する。</dd>
<dt><code>tcftest read [-mt] [-nl|-nb] [-wb] [-rnd] <var>path</var></code></dt>
<dd>上記で生成したデータベースの全レコードを検索する。</dd>
<dt><code>tcftest remove [-mt] [-nl|-nb] [-rnd] <var>path</var></code></dt>
<dd>上記で生成したデータベースの全レコードを削除する。</dd>
<dt><code>tcftest rcat [-mt] [-nl|-nb] [-pn <var>num</var>] [-dai|-dad|-rl] <var>path</var> <var>rnum</var> [<var>width</var> [<var>limsiz</var>]]</code></dt>
<dd>キーがある程度重複するようにレコードの追加を行い、連結モードで処理する。</dd>
<dt><code>tcftest misc [-mt] [-nl|-nb] <var>path</var> <var>rnum</var></code></dt>
<dd>各種操作の組み合わせテストを行う。</dd>
<dt><code>tcftest wicked [-mt] [-nl|-nb] <var>path</var> <var>rnum</var></code></dt>
<dd>各種更新操作を無作為に選択して実行する。</dd>
</dl>

<p>各オプションは以下の機能を持ちます</p>

<ul class="options">
<li><code>-mt</code> : 関数 `tcfdbsetmutex' を呼び出す。</li>
<li><code>-nl</code> : オプション `FDBNOLCK' を有効にする。</li>
<li><code>-nb</code> : オプション `FDBLCKNB' を有効にする。</li>
<li><code>-rnd</code> : キーを無作為に選択する。</li>
<li><code>-wb</code> : 関数 `tcfdbget' の代わりに関数 `tcfdbget3' を用いる。</li>
<li><code>-pn <var>num</var></code> : パターン数を指定する。</li>
<li><code>-dai</code> : 関数 `tcfdbputcat' の代わりに関数 `tcfdbaddint' を用いる。</li>
<li><code>-dad</code> : 関数 `tcfdbputcat' の代わりに関数 `tcfdbadddouble' を用いる。</li>
<li><code>-rl</code> : 値を無作為な長さにする。</li>
</ul>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<p>コマンド `<code>tcfmttest</code>' は、ハッシュデータベースAPIの機能テストをマルチスレッドで行うツールです。以下の書式で用います。`<var>path</var>' はデータベースファイルのパスを指定し、`<var>tnum</var>' はスレッド数を指定し、`<var>rnum</var>' は試行回数を指定し、`<var>width</var>' は各レコードの値の幅を指定し、`<var>limsiz</var>' はデータベースファイルの制限サイズを指定します。</p>

<dl class="api">
<dt><code>tcfmttest write [-nl|-nb] [-rnd] <var>path</var> <var>tnum</var> <var>rnum</var> [<var>width</var> [<var>limsiz</var>]]</code></dt>
<dd>`00000001'、`00000002' のように変化する8バイトのキーと値を連続してデータベースに追加する。</dd>
<dt><code>tcfmttest read [-nl|-nb] [-wb] [-rnd] <var>path</var> <var>tnum</var></code></dt>
<dd>上記で生成したデータベースの全レコードを検索する。</dd>
<dt><code>tcfmttest remove [-nl|-nb] [-rnd] <var>path</var> <var>tnum</var></code></dt>
<dd>上記で生成したデータベースの全レコードを削除する。</dd>
<dt><code>tcfmttest wicked [-nl|-nb] [-nc] <var>path</var> <var>tnum</var> <var>rnum</var></code></dt>
<dd>各種更新操作を無作為に選択して実行する。</dd>
<dt><code>tcfmttest typical [-nl|-nb] [-nc] [-rr <var>num</var>] <var>path</var> <var>tnum</var> <var>rnum</var> [<var>width</var> [<var>limsiz</var>]]</code></dt>
<dd>典型的な操作を無作為に選択して実行する。</dd>
</dl>

<p>各オプションは以下の機能を持ちます</p>

<ul class="options">
<li><code>-nl</code> : オプション `FDBNOLCK' を有効にする。</li>
<li><code>-nb</code> : オプション `FDBLCKNB' を有効にする。</li>
<li><code>-rnd</code> : キーを無作為に選択する。</li>
<li><code>-wb</code> : 関数 `tcfdbget' の代わりに関数 `tcfdbget3' を用いる。</li>
<li><code>-nc</code> : 比較テストを行わない。</li>
<li><code>-rr <var>num</var></code> : 読み込み操作の割合を百分率で指定する。</li>
</ul>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<p>コマンド `<code>tcfmgr</code>' は、ハッシュデータベースAPIやそのアプリケーションのテストやデバッグに役立つツールです。以下の書式で用います。`<var>path</var>' はデータベースファイルのパスを指定し、`<var>width</var>' は各レコードの値の幅を指定し、`<var>limsiz</var>' はデータベースファイルの制限サイズを指定し、`<var>key</var>' はレコードのキーを指定し、`<var>value</var>' はレコードの値を指定し、`<var>file</var>' は入力ファイルを指定します。</p>

<dl class="api">
<dt><code>tcfmgr create <var>path</var> [<var>width</var> [<var>limsiz</var>]]</code></dt>
<dd>データベースファイルを作成する。</dd>
<dt><code>tcfmgr inform [-nl|-nb] <var>path</var></code></dt>
<dd>データベースの雑多な情報を出力する。</dd>
<dt><code>tcfmgr put [-nl|-nb] [-sx] [-dk|-dc|-dai|-dad] <var>path</var> <var>key</var> <var>value</var></code></dt>
<dd>レコードを追加する。</dd>
<dt><code>tcfmgr out [-nl|-nb] [-sx] <var>path</var> <var>key</var></code></dt>
<dd>レコードを削除する。</dd>
<dt><code>tcfmgr get [-nl|-nb] [-sx] [-px] [-pz] <var>path</var> <var>key</var></code></dt>
<dd>レコードの値を取得して標準出力する。</dd>
<dt><code>tcfmgr list [-nl|-nb] [-m <var>num</var>] [-pv] [-px] [-rb <var>lkey</var> <var>ukey</var>] [-ri <var>str</var>] <var>path</var></code></dt>
<dd>全てのレコードのキーを改行で区切って標準出力する。</dd>
<dt><code>tcfmgr optimize [-tz] [-nl|-nb] <var>path</var> [<var>width</var> [<var>limsiz</var>]]</code></dt>
<dd>データベースを最適化する。</dd>
<dt><code>tcfmgr importtsv [-nl|-nb] [-sc] <var>path</var> [<var>file</var>]</code></dt>
<dd>TSVファイルの各行をキーと値とみなしてレコードを登録する。</dd>
<dt><code>tcfmgr version</code></dt>
<dd>Tokyo Cabinetのバージョン情報を標準出力する。</dd>
</dl>

<p>各オプションは以下の機能を持ちます</p>

<ul class="options">
<li><code>-nl</code> : オプション `FDBNOLCK' を有効にする。</li>
<li><code>-nb</code> : オプション `FDBLCKNB' を有効にする。</li>
<li><code>-sx</code> : 入力を16進数の文字列で行う。</li>
<li><code>-dk</code> : 関数 `tcfdbput' の代わりに関数 `tcfdbputkeep' を用いる。</li>
<li><code>-dc</code> : 関数 `tcfdbput' の代わりに関数 `tcfdbputcat' を用いる。</li>
<li><code>-dai</code> : 関数 `tcfdbput' の代わりに関数 `tcfdbaddint' を用いる。</li>
<li><code>-dad</code> : 関数 `tcfdbput' の代わりに関数 `tcfdbadddouble' を用いる。</li>
<li><code>-px</code> : 出力を16進数の文字列で行う。</li>
<li><code>-pz</code> : 出力の末尾に改行を付加しない。</li>
<li><code>-m <var>num</var></code> : 出力の最大数を指定する。</li>
<li><code>-pv</code> : レコードの値も出力する。</li>
<li><code>-rb <var>lkey</var> <var>ukey</var></code> : 処理対象を範囲指定する。</li>
<li><code>-ri <var>str</var></code> : 処理対象の範囲を区間記法で指定する。</li>
<li><code>-sc</code> : キーを小文字に正規化する。</li>
</ul>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<hr />

<h2 id="tctdbapi">テーブルデータベースAPI</h2>

<p>テーブルデータベースは、プライマリキーと任意のコラムを持つレコード群を単一のファイルに記録したデータベースです。それを扱うのがテーブルデータベースAPIです。`<code>tctdb.h</code>' にAPIの仕様の完全な記述があります。</p>

<h3 id="tctdbapi_description">概要</h3>

<p>テーブルデータベースAPIを使うためには、`<code>tcutil.h</code>'、`<code>tctdb.h</code>' および関連する標準ヘッダファイルをインクルードしてください。通常、ソースファイルの冒頭付近で以下の記述を行います。</p>

<dl>
<dt><code>#include &lt;tcutil.h&gt;</code></dt>
<dt><code>#include &lt;tctdb.h&gt;</code></dt>
<dt><code>#include &lt;stdlib.h&gt;</code></dt>
<dt><code>#include &lt;stdbool.h&gt;</code></dt>
<dt><code>#include &lt;stdint.h&gt;</code></dt>
</dl>

<p>テーブルデータベースを扱う際には、`<code>TCTDB</code>' 型へのポインタをオブジェクトとして用います。テーブルデータベースオブジェクトは、関数 `<code>tctdbnew</code>' で作成し、関数 `<code>tctdbdel</code>' で破棄します。作成したオブジェクトを使い終わったら必ず破棄してください。そうしないとメモリリークが発生します。</p>

<p>レコードの格納や探索を行う前提として、テーブルデータベースオブジェクトをデータベースファイルと接続させる必要があります。データベースファイルを開いて接続するには関数 `<code>tctdbopen</code>' を用い、接続の解除してファイルを閉じるには関数 `<code>tctdbclose</code>' を用います。開いたデータベースファイルは必ず閉じてください。そうしないとデータベースファイルが壊れたり格納したデータが失われたりする可能性があります。単一のプロセス内で複数のデータベースオブジェクトが同じデータベースファイルを同時に開くことはできません。</p>

<h3 id="tctdbapi_api">API（英語スマメ）</h3>

<p>The function `tctdberrmsg' is used in order to get the message string corresponding to an error code.</p>

<dl class="api">
<dt><code>const char *tctdberrmsg(int <var>ecode</var>);</code></dt>
<dd>`<var>ecode</var>' specifies the error code.</dd>
<dd>The return value is the message string of the error code.</dd>
</dl>

<p>The function `tctdbnew' is used in order to create a table database object.</p>

<dl class="api">
<dt><code>TCTDB *tctdbnew(void);</code></dt>
<dd>The return value is the new table database object.</dd>
</dl>

<p>The function `tctdbdel' is used in order to delete a table database object.</p>

<dl class="api">
<dt><code>void tctdbdel(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>If the database is not closed, it is closed implicitly.  Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tctdbecode' is used in order to get the last happened error code of a table database object.</p>

<dl class="api">
<dt><code>int tctdbecode(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>The return value is the last happened error code.</dd>
<dd>The following error codes are defined: `TCESUCCESS' for success, `TCETHREAD' for threading error, `TCEINVALID' for invalid operation, `TCENOFILE' for file not found, `TCENOPERM' for no permission, `TCEMETA' for invalid meta data, `TCERHEAD' for invalid record header, `TCEOPEN' for open error, `TCECLOSE' for close error, `TCETRUNC' for trunc error, `TCESYNC' for sync error, `TCESTAT' for stat error, `TCESEEK' for seek error, `TCEREAD' for read error, `TCEWRITE' for write error, `TCEMMAP' for mmap error, `TCELOCK' for lock error, `TCEUNLINK' for unlink error, `TCERENAME' for rename error, `TCEMKDIR' for mkdir error, `TCERMDIR' for rmdir error, `TCEKEEP' for existing record, `TCENOREC' for no record found, and `TCEMISC' for miscellaneous error.</dd>
</dl>

<p>The function `tctdbsetmutex' is used in order to set mutual exclusion control of a table database object for threading.</p>

<dl class="api">
<dt><code>bool tctdbsetmutex(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object which is not opened.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the mutual exclusion control is needed if the object is shared by plural threads and this function should be called before the database is opened.</dd>
</dl>

<p>The function `tctdbtune' is used in order to set the tuning parameters of a table database object.</p>

<dl class="api">
<dt><code>bool tctdbtune(TCTDB *<var>tdb</var>, int64_t <var>bnum</var>, int8_t <var>apow</var>, int8_t <var>fpow</var>, uint8_t <var>opts</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object which is not opened.</dd>
<dd>`<var>bnum</var>' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is 131071.  Suggested size of the bucket array is about from 0.5 to 4 times of the number of all records to be stored.</dd>
<dd>`<var>apow</var>' specifies the size of record alignment by power of 2.  If it is negative, the default value is specified.  The default value is 4 standing for 2^4=16.</dd>
<dd>`<var>fpow</var>' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the default value is specified.  The default value is 10 standing for 2^10=1024.</dd>
<dd>`<var>opts</var>' specifies options by bitwise-or: `TDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64-bit bucket array, `TDBTDEFLATE' specifies that each record is compressed with Deflate encoding, `TDBTBZIP' specifies that each record is compressed with BZIP2 encoding, `TDBTTCBS' specifies that each record is compressed with TCBS encoding.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the tuning parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tctdbsetcache' is set the caching parameters of a table database object.</p>

<dl class="api">
<dt><code>bool tctdbsetcache(TCTDB *<var>tdb</var>, int32_t <var>rcnum</var>, int32_t <var>lcnum</var>, int32_t <var>ncnum</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object which is not opened.</dd>
<dd>`<var>rcnum</var>' specifies the maximum number of records to be cached.  If it is not more than 0, the record cache is disabled.  It is disabled by default.</dd>
<dd>`<var>lcnum</var>' specifies the maximum number of leaf nodes to be cached.  If it is not more than 0, the default value is specified.  The default value is 2048.</dd>
<dd>`<var>ncnum</var>' specifies the maximum number of non-leaf nodes to be cached.  If it is not more than 0, the default value is specified.  The default value is 512.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the caching parameters should be set before the database is opened.  Leaf nodes and non-leaf nodes are used in column indices.</dd>
</dl>

<p>The function `tctdbsetxmsiz' is used in order to set the size of the extra mapped memory of a table database object.</p>

<dl class="api">
<dt><code>bool tctdbsetxmsiz(TCTDB *<var>tdb</var>, int64_t <var>xmsiz</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object which is not opened.</dd>
<dd>`<var>xmsiz</var>' specifies the size of the extra mapped memory.  If it is not more than 0, the extra mapped memory is disabled.  The default size is 67108864.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the mapping parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tctdbsetdfunit' is used in order to set the unit step number of auto defragmentation of a table database object.</p>

<dl class="api">
<dt><code>bool tctdbsetdfunit(TCTDB *<var>tdb</var>, int32_t <var>dfunit</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object which is not opened.</dd>
<dd>`<var>dfunit</var>' specifie the unit step number.  If it is not more than 0, the auto defragmentation is disabled.  It is disabled by default.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the defragmentation parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tctdbopen' is used in order to open a database file and connect a table database object.</p>

<dl class="api">
<dt><code>bool tctdbopen(TCTDB *<var>tdb</var>, const char *<var>path</var>, int <var>omode</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object which is not opened.</dd>
<dd>`<var>path</var>' specifies the path of the database file.</dd>
<dd>`<var>omode</var>' specifies the connection mode: `TDBOWRITER' as a writer, `TDBOREADER' as a reader.  If the mode is `TDBOWRITER', the following may be added by bitwise-or: `TDBOCREAT', which means it creates a new database if not exist, `TDBOTRUNC', which means it creates a new database regardless if one exists, `TDBOTSYNC', which means every transaction synchronizes updated contents with the device.  Both of `TDBOREADER' and `TDBOWRITER' can be added to by bitwise-or: `TDBONOLCK', which means it opens the database file without file locking, or `TDBOLCKNB', which means locking is performed without blocking.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tctdbclose' is used in order to close a table database object.</p>

<dl class="api">
<dt><code>bool tctdbclose(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update of a database is assured to be written when the database is closed.  If a writer opens a database but does not close it appropriately, the database will be broken.</dd>
</dl>

<p>The function `tctdbput' is used in order to store a record into a table database object.</p>

<dl class="api">
<dt><code>bool tctdbput(TCTDB *<var>tdb</var>, const void *<var>pkbuf</var>, int <var>pksiz</var>, TCMAP *<var>cols</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>pkbuf</var>' specifies the pointer to the region of the primary key.</dd>
<dd>`<var>pksiz</var>' specifies the size of the region of the primary key.</dd>
<dd>`<var>cols</var>' specifies a map object containing columns.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tctdbput2' is used in order to store a string record into a table database object with a zero separated column string.</p>

<dl class="api">
<dt><code>bool tctdbput2(TCTDB *<var>tdb</var>, const void *<var>pkbuf</var>, int <var>pksiz</var>, const void *<var>cbuf</var>, int <var>csiz</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>pkbuf</var>' specifies the pointer to the region of the primary key.</dd>
<dd>`<var>pksiz</var>' specifies the size of the region of the primary key.</dd>
<dd>`<var>cbuf</var>' specifies the pointer to the region of the zero separated column string where the name and the value of each column are situated one after the other.</dd>
<dd>`<var>csiz</var>' specifies the size of the region of the column string.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tctdbput3' is used in order to store a string record into a table database object with a tab separated column string.</p>

<dl class="api">
<dt><code>bool tctdbput3(TCTDB *<var>tdb</var>, const char *<var>pkstr</var>, const char *<var>cstr</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>pkstr</var>' specifies the string of the primary key.</dd>
<dd>`<var>cstr</var>' specifies the string of the the tab separated column string where the name and the value of each column are situated one after the other.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tctdbputkeep' is used in order to store a new record into a table database object.</p>

<dl class="api">
<dt><code>bool tctdbputkeep(TCTDB *<var>tdb</var>, const void *<var>pkbuf</var>, int <var>pksiz</var>, TCMAP *<var>cols</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>pkbuf</var>' specifies the pointer to the region of the primary key.</dd>
<dd>`<var>pksiz</var>' specifies the size of the region of the primary key.</dd>
<dd>`<var>cols</var>' specifies a map object containing columns.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tctdbputkeep2' is used in order to store a new string record into a table database object with a zero separated column string.</p>

<dl class="api">
<dt><code>bool tctdbputkeep2(TCTDB *<var>tdb</var>, const void *<var>pkbuf</var>, int <var>pksiz</var>, const void *<var>cbuf</var>, int <var>csiz</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>pkbuf</var>' specifies the pointer to the region of the primary key.</dd>
<dd>`<var>pksiz</var>' specifies the size of the region of the primary key.</dd>
<dd>`<var>cbuf</var>' specifies the pointer to the region of the zero separated column string where the name and the value of each column are situated one after the other.</dd>
<dd>`<var>csiz</var>' specifies the size of the region of the column string.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tctdbputkeep3' is used in order to store a new string record into a table database object with a tab separated column string.</p>

<dl class="api">
<dt><code>bool tctdbputkeep3(TCTDB *<var>tdb</var>, const char *<var>pkstr</var>, const char *<var>cstr</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>pkstr</var>' specifies the string of the primary key.</dd>
<dd>`<var>cstr</var>' specifies the string of the the tab separated column string where the name and the value of each column are situated one after the other.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tctdbputcat' is used in order to concatenate columns of the existing record in a table database object.</p>

<dl class="api">
<dt><code>bool tctdbputcat(TCTDB *<var>tdb</var>, const void *<var>pkbuf</var>, int <var>pksiz</var>, TCMAP *<var>cols</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>pkbuf</var>' specifies the pointer to the region of the primary key.</dd>
<dd>`<var>pksiz</var>' specifies the size of the region of the primary key.</dd>
<dd>`<var>cols</var>' specifies a map object containing columns.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tctdbputcat2' is used in order to concatenate columns in a table database object with a zero separated column string.</p>

<dl class="api">
<dt><code>bool tctdbputcat2(TCTDB *<var>tdb</var>, const void *<var>pkbuf</var>, int <var>pksiz</var>, const void *<var>cbuf</var>, int <var>csiz</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>pkbuf</var>' specifies the pointer to the region of the primary key.</dd>
<dd>`<var>pksiz</var>' specifies the size of the region of the primary key.</dd>
<dd>`<var>cbuf</var>' specifies the pointer to the region of the zero separated column string where the name and the value of each column are situated one after the other.</dd>
<dd>`<var>csiz</var>' specifies the size of the region of the column string.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tctdbputcat3' is used in order to concatenate columns in a table database object with with a tab separated column string.</p>

<dl class="api">
<dt><code>bool tctdbputcat3(TCTDB *<var>tdb</var>, const char *<var>pkstr</var>, const char *<var>cstr</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>pkstr</var>' specifies the string of the primary key.</dd>
<dd>`<var>cstr</var>' specifies the string of the the tab separated column string where the name and the value of each column are situated one after the other.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tctdbout' is used in order to remove a record of a table database object.</p>

<dl class="api">
<dt><code>bool tctdbout(TCTDB *<var>tdb</var>, const void *<var>pkbuf</var>, int <var>pksiz</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>pkbuf</var>' specifies the pointer to the region of the primary key.</dd>
<dd>`<var>pksiz</var>' specifies the size of the region of the primary key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tctdbout2' is used in order to remove a string record of a table database object.</p>

<dl class="api">
<dt><code>bool tctdbout2(TCTDB *<var>tdb</var>, const char *<var>pkstr</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>pkstr</var>' specifies the string of the primary key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tctdbget' is used in order to retrieve a record in a table database object.</p>

<dl class="api">
<dt><code>TCMAP *tctdbget(TCTDB *<var>tdb</var>, const void *<var>pkbuf</var>, int <var>pksiz</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>`<var>pkbuf</var>' specifies the pointer to the region of the primary key.</dd>
<dd>`<var>pksiz</var>' specifies the size of the region of the primary key.</dd>
<dd>If successful, the return value is a map object of the columns of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because the object of the return value is created with the function `tcmapnew', it should be deleted with the function `tcmapdel' when it is no longer in use.</dd>
</dl>

<p>The function `tctdbget2' is used in order to retrieve a record in a table database object as a zero separated column string.</p>

<dl class="api">
<dt><code>char *tctdbget2(TCTDB *<var>tdb</var>, const void *<var>pkbuf</var>, int <var>pksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>`<var>pkbuf</var>' specifies the pointer to the region of the primary key.</dd>
<dd>`<var>pksiz</var>' specifies the size of the region of the primary key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the column string of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tctdbget3' is used in order to retrieve a string record in a table database object as a tab separated column string.</p>

<dl class="api">
<dt><code>char *tctdbget3(TCTDB *<var>tdb</var>, const char *<var>pkstr</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>`<var>pkstr</var>' specifies the string of the primary key.</dd>
<dd>If successful, the return value is the tab separated column string of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tctdbvsiz' is used in order to get the size of the value of a record in a table database object.</p>

<dl class="api">
<dt><code>int tctdbvsiz(TCTDB *<var>tdb</var>, const void *<var>pkbuf</var>, int <var>pksiz</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the primary key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the primary key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tctdbvsiz2' is used in order to get the size of the value of a string record in a table database object.</p>

<dl class="api">
<dt><code>int tctdbvsiz2(TCTDB *<var>tdb</var>, const char *<var>pkstr</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the primary key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tctdbiterinit' is used in order to initialize the iterator of a table database object.</p>

<dl class="api">
<dt><code>bool tctdbiterinit(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The iterator is used in order to access the primary key of every record stored in a database.</dd>
</dl>

<p>The function `tctdbiternext' is used in order to get the next primary key of the iterator of a table database object.</p>

<dl class="api">
<dt><code>void *tctdbiternext(TCTDB *<var>tdb</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the next primary key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  It is allowed to update or remove records whose keys are fetched while the iteration.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.</dd>
</dl>

<p>The function `tctdbiternext2' is used in order to get the next primary key string of the iterator of a table database object.</p>

<dl class="api">
<dt><code>char *tctdbiternext2(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>If successful, the return value is the string of the next primary key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.</dd>
</dl>

<p>The function `tctdbiternext3' is used in order to get the columns of the next record of the iterator of a table database object.</p>

<dl class="api">
<dt><code>TCMAP *tctdbiternext3(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>If successful, the return value is a map object of the columns of the next record, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.  The primary key is added into the map as a column of an empty string key.</dd>
<dd>Because the object of the return value is created with the function `tcmapnew', it should be deleted with the function `tcmapdel' when it is no longer in use.  It is possible to access every record by iteration of calling this function.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.</dd>
</dl>

<p>The function `tctdbfwmkeys' is used in order to get forward matching primary keys in a table database object.</p>

<dl class="api">
<dt><code>TCLIST *tctdbfwmkeys(TCTDB *<var>tdb</var>, const void *<var>pbuf</var>, int <var>psiz</var>, int <var>max</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>`<var>pbuf</var>' specifies the pointer to the region of the prefix.</dd>
<dd>`<var>psiz</var>' specifies the size of the region of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</dd>
</dl>

<p>The function `tctdbfwmkeys2' is used in order to get forward matching string primary keys in a table database object.</p>

<dl class="api">
<dt><code>TCLIST *tctdbfwmkeys2(TCTDB *<var>tdb</var>, const char *<var>pstr</var>, int <var>max</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>`<var>pstr</var>' specifies the string of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</dd>
</dl>

<p>The function `tctdbaddint' is used in order to add an integer to a column of a record in a table database object.</p>

<dl class="api">
<dt><code>int tctdbaddint(TCTDB *<var>tdb</var>, const void *<var>pkbuf</var>, int <var>pksiz</var>, int <var>num</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the primary key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the primary key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>If successful, the return value is the summation value, else, it is `INT_MIN'.</dd>
<dd>The additional value is stored as a decimal string value of a column whose name is "_num".  If no record corresponds, a new record with the additional value is stored.</dd>
</dl>

<p>The function `tctdbadddouble' is used in order to add a real number to a column of a record in a table database object.</p>

<dl class="api">
<dt><code>double tctdbadddouble(TCTDB *<var>tdb</var>, const void *<var>pkbuf</var>, int <var>pksiz</var>, double <var>num</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the primary key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the primary key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>If successful, the return value is the summation value, else, it is Not-a-Number.</dd>
<dd>The additional value is stored as a decimal string value of a column whose name is "_num".  If no record corresponds, a new record with the additional value is stored.</dd>
</dl>

<p>The function `tctdbsync' is used in order to synchronize updated contents of a table database object with the file and the device.</p>

<dl class="api">
<dt><code>bool tctdbsync(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function is useful when another process connects to the same database file.</dd>
</dl>

<p>The function `tctdboptimize' is used in order to optimize the file of a table database object.</p>

<dl class="api">
<dt><code>bool tctdboptimize(TCTDB *<var>tdb</var>, int64_t <var>bnum</var>, int8_t <var>apow</var>, int8_t <var>fpow</var>, uint8_t <var>opts</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>bnum</var>' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is two times of the number of records.</dd>
<dd>`<var>apow</var>' specifies the size of record alignment by power of 2.  If it is negative, the current setting is not changed.</dd>
<dd>`<var>fpow</var>' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the current setting is not changed.</dd>
<dd>`<var>opts</var>' specifies options by bitwise-or: `TDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64-bit bucket array, `TDBTDEFLATE' specifies that each record is compressed with Deflate encoding, `TDBTBZIP' specifies that each record is compressed with BZIP2 encoding, `TDBTTCBS' specifies that each record is compressed with TCBS encoding.  If it is `UINT8_MAX', the current setting is not changed.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function is useful to reduce the size of the database file with data fragmentation by successive updating.</dd>
</dl>

<p>The function `tctdbvanish' is used in order to remove all records of a table database object.</p>

<dl class="api">
<dt><code>bool tctdbvanish(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tctdbcopy' is used in order to copy the database file of a table database object.</p>

<dl class="api">
<dt><code>bool tctdbcopy(TCTDB *<var>tdb</var>, const char *<var>path</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>`<var>path</var>' specifies the path of the destination file.  If it begins with `@', the trailing substring is executed as a command line.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if the executed command returns non-zero code.</dd>
<dd>The database file is assured to be kept synchronized and not modified while the copying or executing operation is in progress.  So, this function is useful to create a backup file of the database file.</dd>
</dl>

<p>The function `tctdbtranbegin' is used in order to begin the transaction of a table database object.</p>

<dl class="api">
<dt><code>bool tctdbtranbegin(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The database is locked by the thread while the transaction so that only one transaction can be activated with a database object at the same time.  Thus, the serializable isolation level is assumed if every database operation is performed in the transaction.  Because all pages are cached on memory while the transaction, the amount of referred records is limited by the memory capacity.  If the database is closed during transaction, the transaction is aborted implicitly.</dd>
</dl>

<p>The function `tctdbtrancommit' is used in order to commit the transaction of a table database object.</p>

<dl class="api">
<dt><code>bool tctdbtrancommit(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update in the transaction is fixed when it is committed successfully.</dd>
</dl>

<p>The function `tctdbtranabort' is used in order to abort the transaction of a table database object.</p>

<dl class="api">
<dt><code>bool tctdbtranabort(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update in the transaction is discarded when it is aborted.  The state of the database is rollbacked to before transaction.</dd>
</dl>

<p>The function `tctdbpath' is used in order to get the file path of a table database object.</p>

<dl class="api">
<dt><code>const char *tctdbpath(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>The return value is the path of the database file or `NULL' if the object does not connect to any database file.</dd>
</dl>

<p>The function `tctdbrnum' is used in order to get the number of records ccccof a table database object.</p>

<dl class="api">
<dt><code>uint64_t tctdbrnum(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>The return value is the number of records or 0 if the object does not connect to any database file.</dd>
</dl>

<p>The function `tctdbfsiz' is used in order to get the size of the database file of a table database object.</p>

<dl class="api">
<dt><code>uint64_t tctdbfsiz(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>The return value is the size of the database file or 0 if the object does not connect to any database file.</dd>
</dl>

<p>The function `tctdbsetindex' is used in order to set a column index to a table database object.</p>

<dl class="api">
<dt><code>bool tctdbsetindex(TCTDB *<var>tdb</var>, const char *<var>name</var>, int <var>type</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>`<var>name</var>' specifies the name of a column.  If the name of an existing index is specified, the index is rebuilt.  An empty string means the primary key.</dd>
<dd>`<var>type</var>' specifies the index type: `TDBITLEXICAL' for lexical string, `TDBITDECIMAL' for decimal string, `TDBITTOKEN' for token inverted index, `TDBITQGRAM' for q-gram inverted index.  If it is `TDBITOPT', the index is optimized.  If it is `TDBITVOID', the index is removed.  If `TDBITKEEP' is added by bitwise-or and the index exists, this function merely returns failure.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the setting indices should be set after the database is opened.</dd>
</dl>

<p>The function `tctdbgenuid' is used in order to generate a unique ID number of a table database object.</p>

<dl class="api">
<dt><code>int64_t tctdbgenuid(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object connected as a writer.</dd>
<dd>The return value is the new unique ID number or -1 on failure.</dd>
</dl>

<p>The function `tctdbqrynew' is used in order to create a query object.</p>

<dl class="api">
<dt><code>TDBQRY *tctdbqrynew(TCTDB *<var>tdb</var>);</code></dt>
<dd>`<var>tdb</var>' specifies the table database object.</dd>
<dd>The return value is the new query object.</dd>
</dl>

<p>The function `tctdbqrydel' is used in order to delete a query object.</p>

<dl class="api">
<dt><code>void tctdbqrydel(TDBQRY *<var>qry</var>);</code></dt>
<dd>`<var>qry</var>' specifies the query object.</dd>
</dl>

<p>The function `tctdbqryaddcond' is used in order to add a narrowing condition to a query object.</p>

<dl class="api">
<dt><code>void tctdbqryaddcond(TDBQRY *<var>qry</var>, const char *<var>name</var>, int <var>op</var>, const char *<var>expr</var>);</code></dt>
<dd>`<var>qry</var>' specifies the query object.</dd>
<dd>`<var>name</var>' specifies the name of a column.  An empty string means the primary key.</dd>
<dd>`<var>op</var>' specifies an operation type: `TDBQCSTREQ' for string which is equal to the expression, `TDBQCSTRINC' for string which is included in the expression, `TDBQCSTRBW' for string which begins with the expression, `TDBQCSTREW' for string which ends with the expression, `TDBQCSTRAND' for string which includes all tokens in the expression, `TDBQCSTROR' for string which includes at least one token in the expression, `TDBQCSTROREQ' for string which is equal to at least one token in the expression, `TDBQCSTRRX' for string which matches regular expressions of the expression, `TDBQCNUMEQ' for number which is equal to the expression, `TDBQCNUMGT' for number which is greater than the expression, `TDBQCNUMGE' for number which is greater than or equal to the expression, `TDBQCNUMLT' for number which is less than the expression, `TDBQCNUMLE' for number which is less than or equal to the expression, `TDBQCNUMBT' for number which is between two tokens of the expression, `TDBQCNUMOREQ' for number which is equal to at least one token in the expression, `TDBQCFTSPH' for full-text search with the phrase of the expression, `TDBQCFTSAND' for full-text search with all tokens in the expression, `TDBQCFTSOR' for full-text search with at least one token in the expression, `TDBQCFTSEX' for full-text search with the compound expression.  All operations can be flagged by bitwise-or: `TDBQCNEGATE' for negation, `TDBQCNOIDX' for using no index.</dd>
<dd>`<var>expr</var>' specifies an operand exression.</dd>
</dl>

<p>The function `tctdbqrysetorder' is used in order to set the order of a query object.</p>

<dl class="api">
<dt><code>void tctdbqrysetorder(TDBQRY *<var>qry</var>, const char *<var>name</var>, int <var>type</var>);</code></dt>
<dd>`<var>qry</var>' specifies the query object.</dd>
<dd>`<var>name</var>' specifies the name of a column.  An empty string means the primary key.</dd>
<dd>`<var>type</var>' specifies the order type: `TDBQOSTRASC' for string ascending, `TDBQOSTRDESC' for string descending, `TDBQONUMASC' for number ascending, `TDBQONUMDESC' for number descending.</dd>
</dl>

<p>The function `tctdbqrysetlimit' is used in order to set the limit number of records of the result of a query object.</p>

<dl class="api">
<dt><code>void tctdbqrysetlimit(TDBQRY *<var>qry</var>, int <var>max</var>, int <var>skip</var>);</code></dt>
<dd>`<var>qry</var>' specifies the query object.</dd>
<dd>`<var>max</var>' specifies the maximum number of records of the result.  If it is negative, no limit is specified.</dd>
<dd>`<var>skip</var>' specifies the number of skipped records of the result.  If it is not more than 0, no record is skipped.</dd>
</dl>

<p>The function `tctdbqrysearch' is used in order to execute the search of a query object.</p>

<dl class="api">
<dt><code>TCLIST *tctdbqrysearch(TDBQRY *<var>qry</var>);</code></dt>
<dd>`<var>qry</var>' specifies the query object.</dd>
<dd>The return value is a list object of the primary keys of the corresponding records.  This function does never fail.  It returns an empty list even if no record corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tctdbqrysearchout' is used in order to remove each record corresponding to a query object.</p>

<dl class="api">
<dt><code>bool tctdbqrysearchout(TDBQRY *<var>qry</var>);</code></dt>
<dd>`<var>qry</var>' specifies the query object of the database connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tctdbqryproc' is used in order to process each record corresponding to a query object.</p>

<dl class="api">
<dt><code>bool tctdbqryproc(TDBQRY *<var>qry</var>, TDBQRYPROC <var>proc</var>, void *<var>op</var>);</code></dt>
<dd>`<var>qry</var>' specifies the query object of the database connected as a writer.</dd>
<dd>`<var>proc</var>' specifies the pointer to the iterator function called for each record.  It receives four parameters.  The first parameter is the pointer to the region of the primary key.  The second parameter is the size of the region of the primary key.  The third parameter is a map object containing columns.  The fourth parameter is the pointer to the optional opaque object.  It returns flags of the post treatment by bitwise-or: `TDBQPPUT' to modify the record, `TDBQPOUT' to remove the record, `TDBQPSTOP' to stop the iteration.</dd>
<dd>`<var>op</var>' specifies an arbitrary pointer to be given as a parameter of the iterator function.  If it is not needed, `NULL' can be specified.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tctdbqryhint' is used in order to get the hint string of a query object.</p>

<dl class="api">
<dt><code>const char *tctdbqryhint(TDBQRY *<var>qry</var>);</code></dt>
<dd>`<var>qry</var>' specifies the query object.</dd>
<dd>The return value is the hint string.</dd>
</dl>

<p>The function `tctdbmetasearch' is used in order to retrieve records with multiple query objects and get the set of the result.</p>

<dl class="api">
<dt><code>TCLIST *tctdbmetasearch(TDBQRY **<var>qrys</var>, int <var>num</var>, int <var>type</var>);</code></dt>
<dd>`<var>qrys</var>' specifies an array of the query objects.</dd>
<dd>`<var>num</var>' specifies the number of elements of the array.</dd>
<dd>`<var>type</var>' specifies a set operation type: `TDBMSUNION' for the union set, `TDBMSISECT' for the intersection set, `TDBMSDIFF' for the difference set.</dd>
<dd>The return value is a list object of the primary keys of the corresponding records.  This function does never fail.  It returns an empty list even if no record corresponds.</dd>
<dd>If the first query object has the order setting, the result array is sorted by the order.  Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<h3 id="tctdbapi_example">コード例</h3>

<p>テーブルデータベースを使ったコード例を以下に示します。</p>

<pre>#include &lt;tcutil.h&gt;
#include &lt;tctdb.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;

int main(int argc, char **argv){
  TCTDB *tdb;
  int ecode, pksiz, i, rsiz;
  char pkbuf[256];
  const char *rbuf, *name;
  TCMAP *cols;
  TDBQRY *qry;
  TCLIST *res;

  /* オブジェクトを作成する */
  tdb = tctdbnew();

  /* データベースを開く */
  if(!tctdbopen(tdb, "casket.tct", TDBOWRITER | TDBOCREAT)){
    ecode = tctdbecode(tdb);
    fprintf(stderr, "open error: %s\n", tctdberrmsg(ecode));
  }

  /* レコードを格納する */
  pksiz = sprintf(pkbuf, "%ld", (long)tctdbgenuid(tdb));
  cols = tcmapnew3("name", "mikio", "age", "30", "lang", "ja,en,c", NULL);
  if(!tctdbput(tdb, pkbuf, pksiz, cols)){
    ecode = tctdbecode(tdb);
    fprintf(stderr, "put error: %s\n", tctdberrmsg(ecode));
  }
  tcmapdel(cols);

  /* 素朴な方法でレコードを格納する */
  pksiz = sprintf(pkbuf, "12345");
  cols = tcmapnew();
  tcmapput2(cols, "name", "falcon");
  tcmapput2(cols, "age", "31");
  tcmapput2(cols, "lang", "ja");
  if(!tctdbput(tdb, pkbuf, pksiz, cols)){
    ecode = tctdbecode(tdb);
    fprintf(stderr, "put error: %s\n", tctdberrmsg(ecode));
  }
  tcmapdel(cols);

  /* TSV文字列を使ってレコードを格納する */
  if(!tctdbput3(tdb, "abcde", "name\tjoker\tage\t19\tlang\ten,es")){
    ecode = tctdbecode(tdb);
    fprintf(stderr, "put error: %s\n", tctdberrmsg(ecode));
  }

  /* レコードを検索する */
  qry = tctdbqrynew(tdb);
  tctdbqryaddcond(qry, "age", TDBQCNUMGE, "20");
  tctdbqryaddcond(qry, "lang", TDBQCSTROR, "ja,en");
  tctdbqrysetorder(qry, "name", TDBQOSTRASC);
  tctdbqrysetlimit(qry, 10, 0);
  res = tctdbqrysearch(qry);
  for(i = 0; i &lt; tclistnum(res); i++){
    rbuf = tclistval(res, i, &amp;rsiz);
    cols = tctdbget(tdb, rbuf, rsiz);
    if(cols){
      printf("%s", rbuf);
      tcmapiterinit(cols);
      while((name = tcmapiternext2(cols)) != NULL){
        printf("\t%s\t%s", name, tcmapget2(cols, name));
      }
      printf("\n");
      tcmapdel(cols);
    }
  }
  tclistdel(res);
  tctdbqrydel(qry);

  /* データベースを閉じる */
  if(!tctdbclose(tdb)){
    ecode = tctdbecode(tdb);
    fprintf(stderr, "close error: %s\n", tctdberrmsg(ecode));
  }

  /* オブジェクトを破棄する */
  tctdbdel(tdb);

  return 0;
}
</pre>

<h3 id="tctdbapi_cli">CLI</h3>

<p>テーブルデータベースAPIを簡単に利用するために、コマンドラインインターフェイスとして `<code>tcttest</code>' と `<code>tctmttest</code>' と `<code>tctmgr</code>' が提供されます。</p>

<p>コマンド `<code>tcttest</code>' は、テーブルデータベースAPIの機能テストや性能テストに用いるツールです。以下の書式で用います。`<var>path</var>' はデータベースファイルのパスを指定し、`<var>rnum</var>' は試行回数を指定し、`<var>bnum</var>' はバケット数を指定し、`<var>apow</var>' はアラインメント力を指定し、`<var>fpow</var>' はフリーブロックプール力を指定します。</p>

<dl class="api">
<dt><code>tcttest write [-mt] [-tl] [-td|-tb|-tt|-tx] [-rc <var>num</var>] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-ip] [-is] [-in] [-it] [-if] [-ix] [-nl|-nb] [-rnd] <var>path</var> <var>rnum</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>"str" と "num" と "type" と "flag" をコラムに持つレコード群を連続してデータベースに追加する。</dd>
<dt><code>tcttest read [-mt] [-rc <var>num</var>] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-rnd] <var>path</var></code></dt>
<dd>上記で生成したデータベースの全レコードを検索する。</dd>
<dt><code>tcttest remove [-mt] [-rc <var>num</var>] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-rnd] <var>path</var></code></dt>
<dd>上記で生成したデータベースの全レコードを削除する。</dd>
<dt><code>tcttest rcat [-mt] [-tl] [-td|-tb|-tt|-tx] [-rc <var>num</var>] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-ip] [-is] [-in] [-it] [-if] [-ix] [-nl|-nb] [-pn <var>num</var>] [-dai|-dad|-rl|-ru] <var>path</var> <var>rnum</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>キーがある程度重複するようにレコードの追加を行い、連結モードで処理する。</dd>
<dt><code>tcttest misc [-mt] [-tl] [-td|-tb|-tt|-tx] [-nl|-nb] <var>path</var> <var>rnum</var></code></dt>
<dd>各種操作の組み合わせテストを行う。</dd>
<dt><code>tcttest wicked [-mt] [-tl] [-td|-tb|-tt|-tx] [-nl|-nb] <var>path</var> <var>rnum</var></code></dt>
<dd>各種更新操作を無作為に選択して実行する。</dd>
</dl>

<p>各オプションは以下の機能を持ちます</p>

<ul class="options">
<li><code>-mt</code> : 関数 `tctdbsetmutex' を呼び出す。</li>
<li><code>-tl</code> : オプション `TDBTLARGE' を有効にする。</li>
<li><code>-td</code> : オプション `TDBTDEFLATE' を有効にする。</li>
<li><code>-tb</code> : オプション `TDBTBZIP' を有効にする。</li>
<li><code>-tt</code> : オプション `TDBTTCBS' を有効にする。</li>
<li><code>-tx</code> : オプション `TDBTEXCODEC' を有効にする。</li>
<li><code>-rc <var>num</var></code> : レコード用キャッシュの最大数を指定する。</li>
<li><code>-lc <var>num</var></code> : リーフノード用キャッシュの最大数を指定する。</li>
<li><code>-nc <var>num</var></code> : 非リーフノード用キャッシュの最大数を指定する。</li>
<li><code>-xm <var>num</var></code> : 拡張マップメモリのサイズを指定する。</li>
<li><code>-df <var>num</var></code> : 自動デフラグの単位ステップ数を指定する。</li>
<li><code>-ip</code> : 主キーに数値型のインデックスを張る。</li>
<li><code>-is</code> : "str" コラムに文字列型のインデックスを張る。</li>
<li><code>-in</code> : "num" コラムに数値型のインデックスを張る。</li>
<li><code>-it</code> : "type" コラムに文字列型のインデックスを張る。</li>
<li><code>-if</code> : "flag" コラムにトークン転置インデックスを張る。</li>
<li><code>-ix</code> : "text" コラムにq-gram転置インデックスを張る。</li>
<li><code>-nl</code> : オプション `TDBNOLCK' を有効にする。</li>
<li><code>-nb</code> : オプション `TDBLCKNB' を有効にする。</li>
<li><code>-rnd</code> : キーを無作為に選択する。</li>
<li><code>-pn <var>num</var></code> : パターン数を指定する。</li>
<li><code>-dai</code> : 関数 `tctdbputcat' の代わりに関数 `tctdbaddint' を用いる。</li>
<li><code>-dad</code> : 関数 `tctdbputcat' の代わりに関数 `tctdbadddouble' を用いる。</li>
<li><code>-rl</code> : 値を無作為な長さにする。</li>
<li><code>-ru</code> : 更新操作を無作為に選択する。</li>
</ul>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<p>コマンド `<code>tctmttest</code>' は、テーブルデータベースAPIの機能テストをマルチスレッドで行うツールです。以下の書式で用います。`<var>path</var>' はデータベースファイルのパスを指定し、`<var>tnum</var>' はスレッド数を指定し、`<var>rnum</var>' は試行回数を指定し、`<var>bnum</var>' はバケット数を指定し、`<var>apow</var>' はアラインメント力を指定し、`<var>fpow</var>' はフリーブロックプール力を指定します。</p>

<dl class="api">
<dt><code>tctmttest write [-tl] [-td|-tb|-tt|-tx] [-rc <var>num</var>] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-ip] [-is] [-in] [-it] [-if] [-ix] [-nl|-nb] [-rnd] <var>path</var> <var>tnum</var> <var>rnum</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>"str" と "num" と "type" と "flag" をコラムに持つレコード群を連続してデータベースに追加する。</dd>
<dt><code>tctmttest read [-rc <var>num</var>] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-rnd] <var>path</var> <var>tnum</var></code></dt>
<dd>上記で生成したデータベースの全レコードを検索する。</dd>
<dt><code>tctmttest remove [-rc <var>num</var>] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-rnd] <var>path</var> <var>tnum</var></code></dt>
<dd>上記で生成したデータベースの全レコードを削除する。</dd>
<dt><code>tctmttest wicked [-tl] [-td|-tb|-tt|-tx] [-nl|-nb] <var>path</var> <var>tnum</var> <var>rnum</var></code></dt>
<dd>各種更新操作を無作為に選択して実行する。</dd>
<dt><code>tctmttest typical [-tl] [-td|-tb|-tt|-tx] [-rc <var>num</var>] [-lc <var>num</var>] [-nc <var>num</var>] [-xm <var>num</var>] [-df <var>num</var>] [-nl|-nb] [-rr <var>num</var>] <var>path</var> <var>tnum</var> <var>rnum</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]</code></dt>
<dd>典型的な操作を無作為に選択して実行する。</dd>
</dl>

<p>各オプションは以下の機能を持ちます</p>

<ul class="options">
<li><code>-tl</code> : オプション `TDBTLARGE' を有効にする。</li>
<li><code>-td</code> : オプション `TDBTDEFLATE' を有効にする。</li>
<li><code>-tb</code> : オプション `TDBTBZIP' を有効にする。</li>
<li><code>-tt</code> : オプション `TDBTTCBS' を有効にする。</li>
<li><code>-tx</code> : オプション `TDBTEXCODEC' を有効にする。</li>
<li><code>-rc <var>num</var></code> : レコード用キャッシュの最大数を指定する。</li>
<li><code>-lc <var>num</var></code> : リーフノード用キャッシュの最大数を指定する。</li>
<li><code>-nc <var>num</var></code> : 非リーフノード用キャッシュの最大数を指定する。</li>
<li><code>-xm <var>num</var></code> : 拡張マップメモリのサイズを指定する。</li>
<li><code>-df <var>num</var></code> : 自動デフラグの単位ステップ数を指定する。</li>
<li><code>-ip</code> : 主キーに数値型のインデックスを張る。</li>
<li><code>-is</code> : "str" コラムに文字列型のインデックスを張る。</li>
<li><code>-in</code> : "num" コラムに数値型のインデックスを張る。</li>
<li><code>-it</code> : "type" コラムに文字列型のインデックスを張る。</li>
<li><code>-if</code> : "flag" コラムにトークン転置インデックスを張る。</li>
<li><code>-ix</code> : "text" コラムにq-gram転置インデックスを張る。</li>
<li><code>-nl</code> : オプション `TDBNOLCK' を有効にする。</li>
<li><code>-nb</code> : オプション `TDBLCKNB' を有効にする。</li>
<li><code>-rnd</code> : キーを無作為に選択する。</li>
<li><code>-rr <var>num</var></code> : 読み込み操作の割合を百分率で指定する。</li>
</ul>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<p>コマンド `<code>tctmgr</code>' は、テーブルデータベースAPIやそのアプリケーションのテストやデバッグに役立つツールです。以下の書式で用います。`<var>path</var>' はデータベースファイルのパスを指定し、`<var>bnum</var>' はバケット数を指定し、`<var>apow</var>' はアラインメント力を指定し、`<var>fpow</var>' はフリーブロックプール力を指定し、`<var>pkey</var>' はレコードの主キーを指定し、`<var>cols</var>' はコラムの名前と値を交互に指定し、`<var>name</var>' はコラムの名前を指定し、`<var>op</var>' は演算子を指定し、`<var>expr</var>' は条件式を指定し、`<var>file</var>' は入力ファイルを指定します。</p>

<dl class="api">
<dt><code>tctmgr create [-tl] [-td|-tb|-tt|-tx] <var>path</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>データベースファイルを作成する。</dd>
<dt><code>tctmgr inform [-nl|-nb] <var>path</var></code></dt>
<dd>データベースの雑多な情報を出力する。</dd>
<dt><code>tctmgr put [-nl|-nb] [-sx] [-dk|-dc|-dai|-dad] <var>path</var> <var>pkey</var> [<var>cols</var> ...]</code></dt>
<dd>レコードを追加する。</dd>
<dt><code>tctmgr out [-nl|-nb] [-sx] <var>path</var> <var>pkey</var></code></dt>
<dd>レコードを削除する。</dd>
<dt><code>tctmgr get [-nl|-nb] [-sx] [-px] [-pz] <var>path</var> <var>pkey</var></code></dt>
<dd>レコードの値を取得して標準出力する。</dd>
<dt><code>tctmgr list [-nl|-nb] [-m <var>num</var>] [-pv] [-px] [-fm <var>str</var>] <var>path</var></code></dt>
<dd>全てのレコードの主キーを改行で区切って標準出力する。</dd>
<dt><code>tctmgr search [-nl|-nb] [-ord <var>name</var> <var>type</var>] [-m <var>num</var>] [-sk <var>num</var>] [-kw] [-pv] [-px] [-ph] [-bt <var>num</var>] [-rm] [-ms <var>type</var>] <var>path</var> [<var>name</var> <var>op</var> <var>expr</var> ...]</code></dt>
<dd>検索条件に合致するレコードを改行で区切って標準出力する。</dd>
<dt><code>tctmgr optimize [-tl] [-td|-tb|-tt|-tx] [-tz] [-nl|-nb] [-df] <var>path</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>データベースを最適化する。</dd>
<dt><code>tctmgr setindex [-nl|-nb] [-it <var>type</var>] <var>path</var> <var>name</var></code></dt>
<dd>インデックスを設定する。</dd>
<dt><code>tctmgr importtsv [-nl|-nb] [-sc] <var>path</var> [<var>file</var>]</code></dt>
<dd>TSVファイルの各行をキーと値とみなしてレコードを登録する。</dd>
<dt><code>tctmgr version</code></dt>
<dd>Tokyo Cabinetのバージョン情報を標準出力する。</dd>
</dl>

<p>各オプションは以下の機能を持ちます</p>

<ul class="options">
<li><code>-tl</code> : オプション `TDBTLARGE' を有効にする。</li>
<li><code>-td</code> : オプション `TDBTDEFLATE' を有効にする。</li>
<li><code>-tb</code> : オプション `TDBTBZIP' を有効にする。</li>
<li><code>-tt</code> : オプション `TDBTTCBS' を有効にする。</li>
<li><code>-tx</code> : オプション `TDBTEXCODEC' を有効にする。</li>
<li><code>-nl</code> : オプション `TDBNOLCK' を有効にする。</li>
<li><code>-nb</code> : オプション `TDBLCKNB' を有効にする。</li>
<li><code>-sx</code> : 入力を16進数の文字列で行う。</li>
<li><code>-dk</code> : 関数 `tctdbput' の代わりに関数 `tctdbputkeep' を用いる。</li>
<li><code>-dc</code> : 関数 `tctdbput' の代わりに関数 `tctdbputcat' を用いる。</li>
<li><code>-dai</code> : 関数 `tctdbput' の代わりに関数 `tctdbaddint' を用いる。</li>
<li><code>-dad</code> : 関数 `tctdbput' の代わりに関数 `tctdbadddouble' を用いる。</li>
<li><code>-px</code> : 出力を16進数の文字列で行う。</li>
<li><code>-pz</code> : 出力の末尾に改行を付加しない。</li>
<li><code>-m <var>num</var></code> : 出力の最大数を指定する。</li>
<li><code>-pv</code> : レコードの値も出力する。</li>
<li><code>-fm <var>str</var></code> : キーの接頭辞を指定する。</li>
<li><code>-ord <var>name</var> <var>type</var></code> : 結果の並び順を指定する。</li>
<li><code>-sk <var>num</var></code> : 結果のスキップ件数を指定する。</li>
<li><code>-kw</code> : KWIC文字列を出力する。</li>
<li><code>-ph</code> : ヒント情報も出力する。</li>
<li><code>-bt</code> : ベンチマークテストの回数を指定する。</li>
<li><code>-rm</code> : 結果のレコードを全て削除する。</li>
<li><code>-ms <var>type</var></code> : メタ検索の集合演算を指定する。</li>
<li><code>-tz</code> : オプション `UINT8_MAX' を有効にする。</li>
<li><code>-df</code> : デフラグのみを行う。</li>
<li><code>-it</code> : インデックスの型を "lexical" か "decimal" か "token" か "qgram" か "void" で指定する。</li>
<li><code>-cv</code> : 既存のインデックスを削除する。</li>
<li><code>-sc</code> : キーを小文字に正規化する。</li>
</ul>

<p>`search' サブコマンドの演算子には、"STREQ", "STRINC", "STRBW", "STREW", "STRAND", "STROR", "STROREQ", "STRRX", "NUMEQ", "NUMGT", "NUMGE", "NUMLT", "NUMLE", "NUMBT", "NUMOREQ", "FTSPH", "FTSAND", "FTSOR", "FTSEX" のいずれかを用いることができます。各演算子に "~" を接頭させると論理的な意味が反転されます。"+" を接頭させるとその演算子にはインデックスが適用されません。`-ord' オプションの型指定には、"STRASC", "STRDESC", "NUMASC", "NUMDESC" のいずれかを用いることができます。`-ms' オプションの型指定には、"UNION", "ISECT", "DIFF" のいずれかを用いることができます。このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<hr />

<h2 id="tcadbapi">抽象データベースAPI</h2>

<p>抽象データベースは、オンメモリハッシュデータベースとオンメモリツリーデータベースとハッシュデータベースとB+木データベースと固定長データベースとテーブルデータベースを同一のAPIで抽象化したデータベースです。それを扱うのが抽象データベースAPIです。`<code>tcadb.h</code>' にAPIの仕様の完全な記述があります。</p>

<h3 id="tcadbapi_description">概要</h3>

<p>抽象データベースAPIを使うためには、`<code>tcutil.h</code>'、`<code>tcadb.h</code>' および関連する標準ヘッダファイルをインクルードしてください。通常、ソースファイルの冒頭付近で以下の記述を行います。</p>

<dl>
<dt><code>#include &lt;tcutil.h&gt;</code></dt>
<dt><code>#include &lt;tcadb.h&gt;</code></dt>
<dt><code>#include &lt;stdlib.h&gt;</code></dt>
<dt><code>#include &lt;stdbool.h&gt;</code></dt>
<dt><code>#include &lt;stdint.h&gt;</code></dt>
</dl>

<p>抽象データベースを扱う際には、`<code>TCADB</code>' 型へのポインタをオブジェクトとして用います。B+木データベースオブジェクトは、関数 `<code>tcadbnew</code>' で作成し、関数 `<code>tcadbdel</code>' で破棄します。作成したオブジェクトを使い終わったら必ず破棄してください。そうしないとメモリリークが発生します。</p>

<p>レコードの格納や探索を行う前提として、抽象データベースオブジェクトを具象データベースと接続させる必要があります。具象データベースを開いて接続するには関数 `<code>tcadbopen</code>' を用い、接続の解除してファイルを閉じるには関数 `<code>tcadbclose</code>' を用います。開いた具象データベースは必ず閉じてください。そうしないと具象データベースが壊れたり格納したデータが失われたりする可能性があります。単一のプロセス内で複数のデータベースオブジェクトが同じデータベースファイルを同時に開くことはできません。</p>

<h3 id="tcadbapi_api">API（英語ごめんね）</h3>

<p>The function `tcadbnew' is used in order to create an abstract database object.</p>

<dl class="api">
<dt><code>TCADB *tcadbnew(void);</code></dt>
<dd>The return value is the new abstract database object.</dd>
</dl>

<p>The function `tcadbdel' is used in order to delete an abstract database object.</p>

<dl class="api">
<dt><code>void tcadbdel(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
</dl>

<p>The function `tcadbopen' is used in order to open an abstract database.</p>

<dl class="api">
<dt><code>bool tcadbopen(TCADB *<var>adb</var>, const char *<var>name</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>name</var>' specifies the name of the database.  If it is "*", the database will be an on-memory hash database.  If it is "+", the database will be an on-memory tree database.  If its suffix is ".tch", the database will be a hash database.  If its suffix is ".tcb", the database will be a B+ tree database.  If its suffix is ".tcf", the database will be a fixed-length database.  If its suffix is ".tct", the database will be a table database.  Otherwise, this function fails.  Tuning parameters can trail the name, separated by "#".  Each parameter is composed of the name and the value, separated by "=".  On-memory hash database supports "bnum", "capnum", and "capsiz".  On-memory tree database supports "capnum" and "capsiz".  Hash database supports "mode", "bnum", "apow", "fpow", "opts", "rcnum", "xmsiz", and "dfunit".  B+ tree database supports "mode", "lmemb", "nmemb", "bnum", "apow", "fpow", "opts", "lcnum", "ncnum", "xmsiz", and "dfunit".  Fixed-length database supports "mode", "width", and "limsiz".  Table database supports "mode", "bnum", "apow", "fpow", "opts", "rcnum", "lcnum", "ncnum", "xmsiz", "dfunit", and "idx".</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The tuning parameter "capnum" specifies the capacity number of records.  "capsiz" specifies the capacity size of using memory.  Records spilled the capacity are removed by the storing order.  "mode" can contain "w" of writer, "r" of reader, "c" of creating, "t" of truncating, "e" of no locking, and "f" of non-blocking lock.  The default mode is relevant to "wc".  "opts" can contains "l" of large option, "d" of Deflate option, "b" of BZIP2 option, and "t" of TCBS option.  "idx" specifies the column name of an index and its type separated by ":".  For example, "casket.tch#bnum=1000000#opts=ld" means that the name of the database file is "casket.tch", and the bucket number is 1000000, and the options are large and Deflate.</dd>
</dl>

<p>The function `tcadbclose' is used in order to close an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbclose(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update of a database is assured to be written when the database is closed.  If a writer opens a database but does not close it appropriately, the database will be broken.</dd>
</dl>

<p>The function `tcadbput' is used in order to store a record into an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbput(TCADB *<var>adb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcadbput2' is used in order to store a string record into an abstract object.</p>

<dl class="api">
<dt><code>bool tcadbput2(TCADB *<var>adb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcadbputkeep' is used in order to store a new record into an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbputkeep(TCADB *<var>adb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcadbputkeep2' is used in order to store a new string record into an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbputkeep2(TCADB *<var>adb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcadbputcat' is used in order to concatenate a value at the end of the existing record in an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbputcat(TCADB *<var>adb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcadbputcat2' is used in order to concatenate a string value at the end of the existing record in an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbputcat2(TCADB *<var>adb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcadbout' is used in order to remove a record of an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbout(TCADB *<var>adb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcadbout2' is used in order to remove a string record of an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbout2(TCADB *<var>adb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcadbget' is used in order to retrieve a record in an abstract database object.</p>

<dl class="api">
<dt><code>void *tcadbget(TCADB *<var>adb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcadbget2' is used in order to retrieve a string record in an abstract database object.</p>

<dl class="api">
<dt><code>char *tcadbget2(TCADB *<var>adb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcadbvsiz' is used in order to get the size of the value of a record in an abstract database object.</p>

<dl class="api">
<dt><code>int tcadbvsiz(TCADB *<var>adb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tcadbvsiz2' is used in order to get the size of the value of a string record in an abstract database object.</p>

<dl class="api">
<dt><code>int tcadbvsiz2(TCADB *<var>adb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tcadbiterinit' is used in order to initialize the iterator of an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbiterinit(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The iterator is used in order to access the key of every record stored in a database.</dd>
</dl>

<p>The function `tcadbiternext' is used in order to get the next key of the iterator of an abstract database object.</p>

<dl class="api">
<dt><code>void *tcadbiternext(TCADB *<var>adb</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  It is allowed to update or remove records whose keys are fetched while the iteration.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.</dd>
</dl>

<p>The function `tcadbiternext2' is used in order to get the next key string of the iterator of an abstract database object.</p>

<dl class="api">
<dt><code>char *tcadbiternext2(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>If successful, the return value is the string of the next key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.</dd>
</dl>

<p>The function `tcadbfwmkeys' is used in order to get forward matching keys in an abstract database object.</p>

<dl class="api">
<dt><code>TCLIST *tcadbfwmkeys(TCADB *<var>adb</var>, const void *<var>pbuf</var>, int <var>psiz</var>, int <var>max</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>pbuf</var>' specifies the pointer to the region of the prefix.</dd>
<dd>`<var>psiz</var>' specifies the size of the region of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</dd>
</dl>

<p>The function `tcadbfwmkeys2' is used in order to get forward matching string keys in an abstract database object.</p>

<dl class="api">
<dt><code>TCLIST *tcadbfwmkeys2(TCADB *<var>adb</var>, const char *<var>pstr</var>, int <var>max</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>pstr</var>' specifies the string of the prefix.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</dd>
</dl>

<p>The function `tcadbaddint' is used in order to add an integer to a record in an abstract database object.</p>

<dl class="api">
<dt><code>int tcadbaddint(TCADB *<var>adb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int <var>num</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>If successful, the return value is the summation value, else, it is `INT_MIN'.</dd>
<dd>If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcadbadddouble' is used in order to add a real number to a record in an abstract database object.</p>

<dl class="api">
<dt><code>double tcadbadddouble(TCADB *<var>adb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, double <var>num</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>If successful, the return value is the summation value, else, it is Not-a-Number.</dd>
<dd>If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcadbsync' is used in order to synchronize updated contents of an abstract database object with the file and the device.</p>

<dl class="api">
<dt><code>bool tcadbsync(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcadboptimize' is used in order to optimize the storage of an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadboptimize(TCADB *<var>adb</var>, const char *<var>params</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>params</var>' specifies the string of the tuning parameters, which works as with the tuning of parameters the function `tcadbopen'.  If it is `NULL', it is not used.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function is useful to reduce the size of the database storage with data fragmentation by successive updating.</dd>
</dl>

<p>The function `tcadbvanish' is used in order to remove all records of an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbvanish(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcadbcopy' is used in order to copy the database file of an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbcopy(TCADB *<var>adb</var>, const char *<var>path</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>path</var>' specifies the path of the destination file.  If it begins with `@', the trailing substring is executed as a command line.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if the executed command returns non-zero code.</dd>
<dd>The database file is assured to be kept synchronized and not modified while the copying or executing operation is in progress.  So, this function is useful to create a backup file of the database file.</dd>
</dl>

<p>The function `tcadbtranbegin' is used in order to begin the transaction of an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbtranbegin(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The database is locked by the thread while the transaction so that only one transaction can be activated with a database object at the same time.  Thus, the serializable isolation level is assumed if every database operation is performed in the transaction.  All updated regions are kept track of by write ahead logging while the transaction.  If the database is closed during transaction, the transaction is aborted implicitly.</dd>
</dl>

<p>The function `tcadbtrancommit' is used in order to commit the transaction of an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbtrancommit(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update in the transaction is fixed when it is committed successfully.</dd>
</dl>

<p>The function `tcadbtranabort' is used in order to abort the transaction of an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbtranabort(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update in the transaction is discarded when it is aborted.  The state of the database is rollbacked to before transaction.</dd>
</dl>

<p>The function `tcadbpath' is used in order to get the file path of an abstract database object.</p>

<dl class="api">
<dt><code>const char *tcadbpath(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>The return value is the path of the database file or `NULL' if the object does not connect to any database.  "*" stands for on-memory hash database.  "+" stands for on-memory tree database.</dd>
</dl>

<p>The function `tcadbrnum' is used in order to get the number of records of an abstract database object.</p>

<dl class="api">
<dt><code>uint64_t tcadbrnum(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>The return value is the number of records or 0 if the object does not connect to any database instance.</dd>
</dl>

<p>The function `tcadbsize' is used in order to get the size of the database of an abstract database object.</p>

<dl class="api">
<dt><code>uint64_t tcadbsize(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>The return value is the size of the database or 0 if the object does not connect to any database instance.</dd>
</dl>

<p>The function `tcadbmisc' is used in order to call a versatile function for miscellaneous operations of an abstract database object.</p>

<dl class="api">
<dt><code>TCLIST *tcadbmisc(TCADB *<var>adb</var>, const char *<var>name</var>, const TCLIST *<var>args</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>name</var>' specifies the name of the function.  All databases support "put", "out", "get", "putlist", "outlist", "getlist", and "getpart".  "put" is to store a record.  It receives a key and a value, and returns an empty list.  "out" is to remove a record.  It receives a key, and returns an empty list.  "get" is to retrieve a record.  It receives a key, and returns a list of the values.  "putlist" is to store records.  It receives keys and values one after the other, and returns an empty list.  "outlist" is to remove records.  It receives keys, and returns an empty list.  "getlist" is to retrieve records.  It receives keys, and returns keys and values of corresponding records one after the other.  "getpart" is to retrieve the partial value of a record.  It receives a key, the offset of the region, and the length of the region.</dd>
<dd>`<var>args</var>' specifies a list object containing arguments.</dd>
<dd>If successful, the return value is a list object of the result.  `NULL' is returned on failure.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<h3 id="tcadbapi_example">コード例</h3>

<p>抽象データベースを使ったコード例を以下に示します。</p>

<pre>#include &lt;tcutil.h&gt;
#include &lt;tcadb.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;

int main(int argc, char **argv){
  TCADB *adb;
  char *key, *value;

  /* オブジェクトを作成する */
  adb = tcadbnew();

  /* データベースを開く */
  if(!tcadbopen(adb, "casket.tch")){
    fprintf(stderr, "open error\n");
  }

  /* レコードを格納する */
  if(!tcadbput2(adb, "foo", "hop") ||
     !tcadbput2(adb, "bar", "step") ||
     !tcadbput2(adb, "baz", "jump")){
    fprintf(stderr, "put error\n");
  }

  /* レコードを取得する */
  value = tcadbget2(adb, "foo");
  if(value){
    printf("%s\n", value);
    free(value);
  } else {
    fprintf(stderr, "get error\n");
  }

  /* 横断的にレコードを参照する */
  tcadbiterinit(adb);
  while((key = tcadbiternext2(adb)) != NULL){
    value = tcadbget2(adb, key);
    if(value){
      printf("%s:%s\n", key, value);
      free(value);
    }
    free(key);
  }

  /* データベースを閉じる */
  if(!tcadbclose(adb)){
    fprintf(stderr, "close error\n");
  }

  /* オブジェクトを破棄する */
  tcadbdel(adb);

  return 0;
}
</pre>

<h3 id="tcadbapi_cli">CLI</h3>

<p>抽象データベースAPIを簡単に利用するために、コマンドラインインターフェイスとして `<code>tcatest</code>' と `<code>tcamttest</code>' と `<code>tcamgr</code>' が提供されます。</p>

<p>コマンド `<code>tcatest</code>' は、抽象データベースAPIの機能テストや性能テストに用いるツールです。以下の書式で用います。`<var>name</var>' はデータベースの名前を指定し、`<var>rnum</var>' は試行回数を指定し、`<var>tnum</var>' はトランザクションの回数を指定します。</p>

<dl class="api">
<dt><code>tcatest write <var>name</var> <var>rnum</var></code></dt>
<dd>`00000001'、`00000002' のように変化する8バイトのキーと値を連続してデータベースに追加する。</dd>
<dt><code>tcatest read <var>name</var></code></dt>
<dd>上記で生成したデータベースの全レコードを検索する。</dd>
<dt><code>tcatest remove <var>name</var></code></dt>
<dd>上記で生成したデータベースの全レコードを削除する。</dd>
<dt><code>tcatest rcat <var>name</var> <var>rnum</var></code></dt>
<dd>キーがある程度重複するようにレコードの追加を行い、連結モードで処理する。</dd>
<dt><code>tcatest misc <var>name</var> <var>rnum</var></code></dt>
<dd>各種操作の組み合わせテストを行う。</dd>
<dt><code>tcatest wicked <var>name</var> <var>rnum</var></code></dt>
<dd>各種更新操作を無作為に選択して実行する。</dd>
<dt><code>tcatest compare <var>name</var> <var>tnum</var> <var>rnum</var></code></dt>
<dd>各種データベースの比較テストを行う。</dd>
</dl>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<p>コマンド `<code>tcamttest</code>' は、抽象データベースAPIの機能テストをマルチスレッドで行うツールです。以下の書式で用います。`<var>name</var>' はデータベースの名前を指定し、`<var>tnum</var>' はスレッド数を指定し、`<var>rnum</var>' は試行回数を指定します。</p>

<dl class="api">
<dt><code>tcamttest write <var>name</var> <var>tnum</var> <var>rnum</var></code></dt>
<dd>`00000001'、`00000002' のように変化する8バイトのキーと値を連続してデータベースに追加する。</dd>
<dt><code>tcamttest read <var>name</var> <var>tnum</var></code></dt>
<dd>上記で生成したデータベースの全レコードを検索する。</dd>
<dt><code>tcamttest remove <var>name</var> <var>tnum</var></code></dt>
<dd>上記で生成したデータベースの全レコードを削除する。</dd>
</dl>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<p>コマンド `<code>tcamgr</code>' は、抽象データベースAPIやそのアプリケーションのテストやデバッグに役立つツールです。以下の書式で用います。`<var>name</var>' はデータベースの名前を指定し、`<var>key</var>' はレコードのキーを指定し、`<var>value</var>' はレコードの値を指定し、`<var>params</var>' はチューニングパラメータを指定し、`<var>func</var>' は関数の名前を指定し、`<var>arg</var>' は関数の引数を指定し、`<var>dest</var>' は格納先のファイルを指定します。</p>

<dl class="api">
<dt><code>tcamgr create <var>name</var></code></dt>
<dd>データベースを作成する。</dd>
<dt><code>tcamgr inform <var>name</var></code></dt>
<dd>データベースの雑多な情報を出力する。</dd>
<dt><code>tcamgr put [-sx] [-sep <var>chr</var>] [-dk|-dc|-dai|-dad] <var>name</var> <var>key</var> <var>value</var></code></dt>
<dd>レコードを追加する。</dd>
<dt><code>tcamgr out [-sx] [-sep <var>chr</var>] <var>name</var> <var>key</var></code></dt>
<dd>レコードを削除する。</dd>
<dt><code>tcamgr get [-sx] [-sep <var>chr</var>] [-px] [-pz] <var>name</var> <var>key</var></code></dt>
<dd>レコードの値を取得して標準出力する。</dd>
<dt><code>tcamgr list [-sep <var>chr</var>] [-m <var>num</var>] [-pv] [-px] [-fm <var>str</var>] <var>name</var></code></dt>
<dd>全てのレコードのキーを改行で区切って標準出力する。</dd>
<dt><code>tcamgr optimize <var>name</var> <var>params</var></code></dt>
<dd>データベースを最適化する。</dd>
<dt><code>tcamgr misc [-sx] [-sep <var>chr</var>] [-px] <var>name</var> <var>func</var> [<var>arg</var>...]</code></dt>
<dd>雑多な操作の多目的関数を呼び出す。</dd>
<dt><code>tcamgr map [-fm <var>str</var>] <var>name</var> <var>dest</var></code></dt>
<dd>レコードを別のB+木データベース内に写像する。</dd>
<dt><code>tcamgr version</code></dt>
<dd>Tokyo Cabinetのバージョン情報を標準出力する。</dd>
</dl>

<p>各オプションは以下の機能を持ちます</p>

<ul class="options">
<li><code>-sx</code> : 入力を16進数の文字列で行う。</li>
<li><code>-sep <var>chr</var></code> : 入力文字列の区切り文字を指定する。</li>
<li><code>-dk</code> : 関数 `tcadbput' の代わりに関数 `tcadbputkeep' を用いる。</li>
<li><code>-dc</code> : 関数 `tcadbput' の代わりに関数 `tcadbputcat' を用いる。</li>
<li><code>-dai</code> : 関数 `tcadbput' の代わりに関数 `tcadbaddint' を用いる。</li>
<li><code>-dad</code> : 関数 `tcadbput' の代わりに関数 `tcadbadddouble' を用いる。</li>
<li><code>-px</code> : 出力を16進数の文字列で行う。</li>
<li><code>-pz</code> : 出力の末尾に改行を付加しない。</li>
<li><code>-m <var>num</var></code> : 出力の最大数を指定する。</li>
<li><code>-pv</code> : レコードの値も出力する。</li>
<li><code>-fm <var>str</var></code> : キーの接頭辞を指定する。</li>
</ul>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<h3 id="tcadbapi_cgi">CGI</h3>

<p>抽象データベースAPIを簡単に利用するために、コモンゲートウェイインタフェースとして `<code>tcawmgr.cgi</code>' が提供されます。</p>

<p>CGIスクリプト `<code>tcawmgr.cgi</code>' は、Webインターフェイスで抽象データベースの内容を閲覧したり編集したりするのに役立つツールです。操作対象のデータベースは、このCGIスクリプトのカレントディレクトリに "<code>casket.tch</code>" または "<code>casket.tcb</code>" または "<code>casket.tcf</code>" という名前で設置されている必要があります。また、そのパーミッションにおいてCGIスクリプトの実行ユーザに対する読み込みと書き込みが可能になっていることが必要です。このCGIスクリプトをWebサーバの公開ディレクトリに設置したら、割り当てられたURLにWebブラウザでアクセスすると利用を開始することができます。</p>

<hr />

<h2 id="tips">ちょっとしたコツ</h2>

<p>この節ではTokyo Cabinetの使い方のコツや知っておくと便利な小技を紹介します。</p>

<h3 id="tips_tcutil">ユーティリティAPI</h3>

<p>C++、Perl、Ruby、Javaといった高水準な言語では必ずといってリストやマップといったデータ構造を簡単に利用できる機能が標準ライブラリとしてついてきます。しかし、C言語にはそれに相当するものはありません。GNOME GlibやApache APRなどの非標準ライブラリを使うのも一興ですが、Tokyo Cabinetにも高機能・高性能なユーティリティが付属しています。STL（C++の標準テンプレートライブラリ）のstringにあたるものがTCXSTRで、listにあたるものがTCLISTで、mapやsetにあたるものがTCMAPとTCTREEです。他にも文字列処理や各種符号処理のユーティリティも提供されます。それらを使いこなすとC言語でもC++やその他の高水準言語並みの直感的なプログラミングができるでしょう。</p>

<p>TCXSTRの何が便利かと言えば、`<code>tcxstrcat</code>' です。特にバッファリングに有用で、後ろにデータをどんどんくっつけていけるのです。メモリ領域は内部で適宜拡張してくれるので、アプリケーション側でメモリ管理に悩む必要はありませんし、性能もかなり良いです。</p>

<p>TCLISTは配列で実装されたリストです。これはスタック（`<code>tclistpush</code>' で格納して `<code>tclistpop</code>' で取り出す）としてもキュー（`<code>tclistpush</code>' で格納して `<code>tclistshift</code>' で取り出す）としても使えます。もちろんメモリ管理は内部でよろしくやってくれますし、性能もかなり良いです。</p>

<p>TCMAPはハッシュ表によるマップ（連想配列）の実装です。任意のキーに対応づけて任意の値を格納できます。ハッシュデータベースのオンメモリ版と考えてもよいでしょう。TCMAPのイテレータはレコードを格納した順番に取り出すことができるというのが特徴で、かつ任意のレコードを先頭や末尾に移動させることもできるので、LRU消去方式のキャッシュとしても利用することができます。もちろんメモリ管理は内部でよろしくやってくれますし、性能もかなり良いです。</p>

<p>TCTREEは順序木によるマップ（連想配列）の実装です。任意のキーに対応づけて任意の値を格納できます。B+木データベースのオンメモリ版と考えてもよいでしょう。TCTREEのイテレータはレコードを比較関数の昇順に取り出すことができるというのが特徴で、かつイテレータを任意の場所に飛ばすことができるので、文字列の前方一致検索や数値の範囲を行うことができます。もちろんメモリ管理は内部でよろしくやってくれますし、性能もかなり良いです。</p>

<p>TCXSTRとTCLISTとTCMAPとTCTREEの各関数はリエントラントですが、該当のオブジェクトを複数のスレッドで共有する場合にはアプリケーション側で排他制御を行うことが求められます。ただし、ハッシュマップと順序木に関しては排他制御を内部で行う実装としてTCMDBとTCNDBが提供されます。</p>

<p>TCMPOOLというのもあります。これはいわゆるメモリプールの実装で、メモリ管理の単位を一括して楽をすることができる機能です。例えば `<code>malloc</code> で確保した領域は必ず `<code>free</code>' で解放しないとメモリリークになってしまいますが、`<code>tcmpoolmalloc</code>' で確保した領域は明示的に解放しないでよいのです。ではいつ解放されるのかと言えば、メモリプール自体を解放した時です。つまりアプリケーション側ではメモリプールの寿命にだけ気を付ければよく、個々のオブジェクトの寿命を気にしなくてもよくなるということです。メモリプールはTCXSTRやTCLISTやTCMAPやTCTREEのオブジェクトを発生させることもできますし、任意のオブジェクトをデストラクタとともに登録することもできます。典型的には以下のような使い方をします。</p>

<pre>TCMPOOL *mpool;
int i, j;
char *buf;
for(i = 0; i &lt; 100; i++){
  mpool = tcmpoolnew();
  for(j = 0; j &lt; 100; ++){
    buf = tcmpoolmalloc(10); // メモリプール内オブジェクトの生成
    ...                      // いちいち解放しなくてOK
  }
  tcmpooldel(mpool);         // ここで一気に解放
}
</pre>

<h3 id="tips_hashtune">ハッシュデータベースのチューニング</h3>

<p>チューニングをするかしないかでデータベース操作の性能は劇的に変わるので、まじめなユースケースでは、チューニングは必須となるでしょう。関数 `<code>tchdbtune</code>' でそれを行います。この関数では「バケット数」と「アラインメント力」と「フリーブロックプール力」と「オプション」が指定されます。</p>

<p>最も重要なのは、バケット数の設定です。これは、データベースに格納するレコードの最終的な数の数倍（2〜4倍程度がオススメ）を指定すべきです。デフォルトは131071なので、100000個以上のレコードを入れるならばまずこれを設定すべきです。例えば100万レコードくらいを入れる予定ならば、バケット数は200万〜400万くらいにしておくとよいでしょう。バケット配列の個々の要素のサイズは4バイト（32ビット）なので、バケット数を200万にした場合にはファイルサイズが8MB増えて、メモリも8MB必要となるわけですが、21世紀のコンピュータならそれくらい大したことないでしょう。とりあえずバケット数は大きめにとりましょう。</p>

<p>アラインメントは、レコードの開始位置を揃える機構です。指定したアラインメント力で1を高位にビットシフトした数に開始アドレスが揃えられます。デフォルトは4です。例えばアラインメント力を8にしたならば、1&lt;&lt;8で、256の倍数に開始位置が揃えられます。アラインメントの利点は三つあります。一つめは、開始アドレスを揃えることでレコード間にパディング（隙間）ができることです。レコードサイズの増減がパディングの範囲に収まれば、更新時にレコードの位置を変えなくてもよくなります。二つめは、レコードの読み書きをファイルシステムのブロック単位にあわせて行うことができるために、OSレベルでのI/Oの処理が効率化されることです。三つめは、開始アドレスをアラインメントの商として記録できるようになるため、4バイトのバケットで表せる変域が増加することです。アラインメントを用いない場合は2GB（1&lt;&lt;31）までのデータベースファイルしか扱えませんが、例えばアラインメントが256であれば、2GB*256で512GBまでのデータベースファイルを扱うことができます。</p>

<p>フリーブロックとは、更新によってできたファイル内の未使用領域のことです。フリーブロックプールはそれを管理して再利用する機構です。指定したフリーブロックプール力で1を高位にビットシフトした数がフリーブロックプールの容量になります。デフォルトは10です。この設定を変える必要はほとんどないでしょう。</p>

<p>オプションとは、レコードの格納方法を指定するフラグの集合のことです。`<code>HDBTLARGE</code>' と `<code>HDBTDEFLATE</code>' と `<code>HDBTBZIP</code>' と `<code>HDBTTCBS</code>' と `<code>HDBTEXCODEC</code>' の論理和で指定します。`<code>HDBTLARGE</code>' を指定すると、バケットの個々の要素を8バイト（64ビット）で扱います。バケット配列のサイズが2倍になるかわりに、データベースのサイズの上限を8EBに引き上げます。`<code>HDBTDEFLATE</code>' を指定すると、レコードをDeflateアルゴリズムで圧縮してから記録します。大きいサイズ（だいたい256バイト以上）のレコードを圧縮して格納する場合に有利です。`<code>HDBTBZIP</code>' を指定すると、レコードをBZIP2アルゴリズムで圧縮して格納します。Deflateよりは遅いですが、圧縮率は有利です。`<code>HDBTTCBS</code>' を指定すると、レコードをBWT、MTF、Elias Gamma符号で圧縮して格納します。小さいサイズ（256バイト未満）のレコードを圧縮して格納する場合に有利です。`<code>HDBTEXCODEC</code>' は外部の圧縮伸長アルゴリズムを使うためのオプションです。具体的なアルゴリズムは隠しAPIの関数 `<code>tchdbsetcodecfunc</code>' で指定します。</p>

<p>チューニングパラメータの設定はデータベースを作成する前に行う必要があります。チューニングパラメータはメタデータとしてデータベース内に記録されるので、作成した後は指定する必要はありません。なお、いったん作成したデータベースのチューニングを変更することはできません（最適化すればできますが）。バケット数を1000000、アラインメント数を12（4096）、フリーブロックをデフォルト、オプションを `<code>HDBTLARGE</code>' と `<code>HDBTDEFLATE</code>' に指定してデータベースを作成する場合、以下のようなコードになります。</p>

<pre>TCHDB *hdb;
hdb = tchdbnew();
tchdbtune(hdb, 1000000, 12, -1, HDBTLARGE | HDBTDEFLATE);
tchdbopen(hdb, "casket.tch", HDBOWRITER | HDBOCREAT);
...
</pre>

<p>ハッシュデータベースはキャッシュ機構を備えます。これは一旦検索されたレコードをメモリ上に保持しておくもので、同一のレコードが何度も検索される場合の性能を向上させてくれます。キャッシュ上にあるレコードが更新された場合、そのレコードはキャッシュから削除されますので、検索の頻度よりも更新の頻度が多い場合にはあまり効果はありません。また、キャッシュを有効にするとキャッシュを管理するためのオーバーヘッドがかかるので、キャッシュのヒット率がある程度以上でないと逆に処理が遅くなってしまいます。したがって、キャッシュのヒット率がかなり高い場合（つまり同じレコードを何度も参照するような場合）にのみキャッシュ機構を利用すべきです。ハッシュデータベースのキャッシュはデフォルトでは無効になっていますので、有効にする場合は関数 `<code>tchdbsetcache</code>' で設定してください。キャッシュパラメータの設定はデータベースに接続する前に行う必要があり、また接続する度に毎回行う必要があります。</p>

<p>ハッシュデータベースはmmapを介してファイル入出力を行うための拡張マップメモリという機構を備えます。これは、デフォルトでmmapによってマップされるバケット配列とは別に、レコード用の領域をmmapでメモリにマップしたものです。mmapを介したファイル入出力はpreadやpwriteを使った入出力よりも高速で、並列処理性能も高いという利点もあります。その反面、データベースを開いた瞬間に拡張マップメモリとして指定したサイズの領域が仮想メモリ空間に確保され、そのサイズが実メモリの利用可能量を上回った場合にはスワップが発生してしまいます。デフォルトでは64MBの拡張マップメモリが利用されますが、想定されるデータベースファイルがそれより大きくて実メモリ容量よりも小さいような場合は、データベースサイズよりも少し大きいくらいの拡張マップメモリを指定するとよいでしょう。拡張マップメモリのサイズは関数 `<code>tchdbsetxmsiz</code>' で指定してください。拡張マップメモリのパラメータの設定はデータベースに接続する前に行う必要があり、また接続する度に毎回行う必要があります。</p>

<p>レコードの削除を頻繁に行ったり、値の長さを変えるような更新を頻繁に行ったりする場合は、フリーブロックプールを使ったとしても少しずつ断片化が起こってしまいます。断片化が進むとデータベースファイルのサイズが肥大化してきますが、それを解消してファイルサイズを小さくするためにはデフラグと呼ばれる操作を行うことになります。デフラグの最も簡単な方法は、関数 `<code>tchdboptimize</code>' によってデータベースに最適化をかけることです。これはデータベース全体を一気に作り直すことで断片化を解消します。もう一つの方法は、関数 `<code>tchdbsetdfunit</code>' で自動デフラグ設定をしてから更新を行うことです。そうすると、断片化が発生する度に動的に少しずつ最適化処理を行うようになるので、性能が少し犠牲になりますが、見掛け上は肥大化がほとんど発生しないようになります。この関数のパラメータとして指定する単位ステップ数とは、何個の領域の断片化を検出したらデフラグ操作を行うかを指定するものです。この数を増やした方が処理効率は上がりますが、デフラグ操作を行っている間のロックの粒度が上がるので増やしすぎるのも考え物です。通常は8くらいにしておくとよいでしょう。自動デフラグのパラメータの設定はデータベースに接続する前に行う必要があり、また接続する度に毎回行う必要があります。</p>

<h3 id="tips_btreetune">B+木データベースのチューニング</h3>

<p>チューニングをするかしないかで性能が劇的に変わるのはB+木データベースについても同じです。まじめなユースケースではちゃんとチューニングしましょう。チューニングは関数 `<code>tcbdbtune</code>' で行います。この関数では「リーフ内メンバ数」「非リーフ内メンバ数」「バケット数」と「アラインメント力」と「フリーブロックプール力」と「オプション」が指定されます。</p>

<p>リーフまたはリーフページとは、B+木の末端のノードのことで、複数のレコードのキーと値のリストが格納される記憶単位のことです。リーフ内メンバ数とは、一つのリーフの中にいくつのレコードを格納するかの設定です。デフォルトは128です。比較関数の順序通りにレコードを格納または探索することが多い場合はこの値を大きくした方が性能がよくなり、逆に比較関数の順序とは無関係にレコードを格納または探索することが多い場合は小さくした方がよくなります。非リーフまたは非リーフページとはB+木の末端以外のノードのことで、複数のレコードのキーのみが格納される記憶単位のことです。非リーフの数はリーフに比べて少なく、性能に与える影響はあまり大きくありません。非リーフ内メンバ数をデフォルトから変える必要はほとんどないでしょう。</p>

<p>バケット数やその他のパラメータ、B+木データベースの下層にあるハッシュデータベースにそのまま渡されます。B+木の各ページはハッシュデータベースのレコードとして記録されるので、バケット数などのパラメータはその際に意味を持ちます。したがって、ここで指定するバケット数は、B+木データベースにおける最終的なレコード数をリーフ内メンバ数で割った値の数倍に設定するのが最善です。とはいえB+木データベースにおいてはバケット数などのパラメータを変更する必要はあまりないでしょう。</p>

<p>チューニングの例として、平均8バイトのキーと平均32バイトの値のレコードを100万件格納することを考えてみます。各コードのヘッダなどのオーバーヘッドは5バイト程度です。ファイルシステムのブロックサイズは4096バイトとします。すると、1ブロックに入れられるレコード数は4096/(8+32+5)で90個ほどということになります。さらに、Deflate圧縮オプションを有効にして、その圧縮率が50%ほどだとしましょう。となると180個ほどのレコードが1ブロックに収まることが期待されます。各リーフのサイズは2ブロックか3ブロックのサイズが望ましいので、180を2倍した360がリーフ内メンバ数の理想値になります。となると、バケット数は1000000/360で2777となり、デフォルトの32749から変える必要はないでしょう。アラインメント力はファイルシステムのブロックサイズにあわせるためにlog2(4096)で12にします。以上の設定をコードに反映すると以下のようになります。</p>

<pre>TCHDB *bdb;
bdb = tcbdbnew();
tcbdbtune(hdb, 360, -1, -1, 12, -1, BDBTDEFLATE);
tcbdbopen(hdb, "casket.tcb", BDBOWRITER | BDBOCREAT);
...
</pre>

<p>B+木データベースもキャッシュ機構を備えます。これは処理対象のページをメモリ上に保持しておくもので、同一のページが何度も読み書きされる場合の性能を向上させてくれます。キャッシュ上にあるページが更新された場合でも、そのページはメモリ上に保持されたままなので、検索も更新も高速化されます。B+木データベースのキャッシュはデフォルトでは小さめに設定されていますので、メモリを多く使っても高速化したい場合は関数 `<code>tcbdbsetcache</code>' で設定してください。キャッシュパラメータの設定はデータベースに接続する前に行う必要があり、また接続する度に毎回行う必要があります。</p>

<p>B+木データベースでも拡張マップメモリを利用することができます。しかし、B+木のキャッシュ機構がファイル入出力のバッファリングの役目を果たしているので、デフォルトでは無効になっています。メモリ利用効率は無視してとにかくスループットを追求したい場合のみ、関数 `<code>tcbdbsetxmsiz</code>' で拡張マップメモリを有効化してください。拡張マップメモリのパラメータの設定はデータベースに接続する前に行う必要があり、また接続する度に毎回行う必要があります。</p>

<p>B+木データベースでも断片化は起きうるので、デフラグをかけるのはよい考えです。静的な最適化は関数 `<code>tcbdboptimize</code>' で行い、自動デフラグの設定は関数 `<code>tcbdbsetdfunit</code>' で行います。B+木データベースではハッシュデータベースよりもI/Oの粒度が大きいので、自動デフラグを行う際の単位ステップ数は2くらいにしておくとよいでしょう。自動デフラグのパラメータの設定はデータベースに接続する前に行う必要があり、また接続する度に毎回行う必要があります。</p>

<h3 id="tips_hardware">システム設定</h3>

<p>ハードウェアやOSなどの「システム側」の設定も、データベースの操作を高速化するためには重要です。まず、できれば、データベースのサイズと同等以上のRAMをマシンに搭載してください。そして、I/Oバッファのサイズを大きくし、ダーティバッファをフラッシュする頻度が少なくするように設定してください。そうすることによって、デバイスアクセスの頻度を最小化し、I/Oの待ち時間による性能劣化を抑止できます。Linux上では、`<code>sysctl</code>' コマンドや `<code>/etc/sysctl.conf</code>' ファイルでそれらの設定を行うことになるでしょう。ファイルシステムの選択も重要です。Linux上では、通常はEXT2が最高速ですが、EXT3のwritebackモードの方が速いこともあります。ReiserFSもかなり高速です。EXT3のその他のモードはかなり遅いです。他のファイルシステムに関しては各自で実験してみてください。</p>

<p>補助記憶装置にHDD（ハードディスクドライブ）でなくSSD（ソリッドステートドライブ）を使うというのもよい考えです。HDDはシーケンシャルアクセスの速度に比べてランダムアクセスが桁違いに遅くなる傾向にあり、ランダムアクセスを頻繁に行うDBMのストレージとしては不向きなのです。それに対してSSDはランダムアクセスの速度があまり劣化しないので、DBMのストレージとしては最適です。HDDよりバイト毎の単価がかなり高いSSDですが、とっても速くて便利なのでぜひ導入を検討してください。また、購入する製品を選択する際には、カタログに書いてある転送スループットに惑わされてはいけません。それはシーケンシャルアクセスの性能を示しているだけだからです。そうでなく、ランダムアクセスの性能をWebなどで調べて、それが良いものを選んでください。</p>

<h3 id="tips_multithread">マルチスレッド対応</h3>

<p>Tokyo CabinetのAPIにおける各関数はリエントラントなので、引数として与えるデータが各スレッドで別々のものであれば完全に並列に操作を実行することができます。しかし、データベースオブジェクトは内部状態を持つので、一つのデータベースオブジェクトを複数のスレッドで共有する場合には、更新操作に関連して排他制御を行う必要があります。とはいえ、特に難しいことはありません。複数のスレッドで共有するデータベースオブジェクトに対して、作成した直後に関数 `<code>tchdbsetmutex</code>' や `<code>tcbdbsetmutex</code>' を呼び出すだけでOKです。そうすると以後の操作の内部で適切にロックを用いて排他制御が行われるようになります。複数のスレッドを使うが各々が別個のデータベースオブジェクトにアクセスする場合には排他制御は必要ありませんし、排他制御をしない方が高速に動作します。</p>

<p>スレッド間の排他制御はリードライトロックで行われます。`open'、`close'、`put'、`out' などの操作にはライトロック（排他ロック）がかけられ、`get'、`curkey'、`curval' などの操作にはリードロック（共有ロック）がかけられます。ロックの単位は、ハッシュデータベースではレコード単位で、B+木データベースではデータベース単位になります。同一のロックに対する読み込みは激しく同時に行えますが、書き込みをしている間は他のスレッドはブロックされます。排他制御の設定はデータベースに接続する前に行う必要があり、また接続する度に毎回行う必要があります。以下のようなコードになります。</p>

<pre>TCHDB *hdb;
hdb = tchdbnew();
tchdbsetmutex(hdb);
tchdbopen(hdb, "casket.tch", HDBOWRITER);
...
</pre>

<h3 id="tips_transaction">トランザクション</h3>

<p>ファイル上の（オンメモリでない）データベースにはトランザクション機構があります。トランザクションを開始してから行った一連の操作は、コミットすることで確定させたり、アボートすることでなかったことにしたりすることができます。トランザクション中にアプリケーションがクラッシュした場合にも、トランザクション中の操作がなかったことになるだけで、データベースの整合性は維持されます。トランザクションは以下のようなコードで用います。</p>

<pre>tchdbtranbegin(hdb);
do_something();
if(is_all_ok){
  tchdbtrancommit(hdb);
} else {
  tchdbtranabort(hdb);
}
</pre>

<p>トランザクションを実行できるのは同時1スレッドのみで、他のスレッドはその間にトランザクションを開始しようとするとブロックされます。したがって、データベースの参照をトランザクション内でのみ行うならば、トランザクションの分離レベルは直列化可能（serializable）になります。しかし、あるスレッドがトランザクションの最中でも他のスレッドはトランザクションを実行せずにデータベースを参照できます。その場合の分離レベルは非コミット読み取り（read uncommitted）になります。状況に応じて使い分けてください。</p>

<p>トランザクション機構は、ハッシュデータベースではファイル上のログ先行書き込み（write ahead logging）によって実現され、B+木データベースではメモリ上のシャドウページング（shadow paging）によって実現されます。これらの手法とロックによって、データベース単位のACID属性（atomicity、consistency、isolation、durability）が確保されます。</p>

<p>ファイルシステムのdurabilityすらも信用しない場合（突然の電源切断に耐える確率を上げたい場合）には、データベースを開く際に `<code>HDBOTSYNC</code>' または `<code>BDBOTSYNC</code>' オプションをつけてください。そうすると、すべてのトランザクションの前後にfsyncで更新内容とディスクの内容の同期がとられるようになります（めちゃくちゃ遅くなりますが）。とはいえ、いかにトランザクションを使ってもディスクが壊れたらオシマイなので、重要なデータベースに関してはバックアップや冗長化の手法を適用してください。</p>

<h3 id="tips_cursor">カーソル</h3>

<p>B+木データベースにはカーソル機構があります。カーソルは指定したキーの場所にジャンプさせることができ、そこから前後に一つずつずらしながらレコードを参照したり更新したりすることができます。例えば文字列の前方一致検索を行う場合、接頭辞をキーとして指定してカーソルをジャンプさせて、そこから前に進みながらキーを一つ一つ参照していって、前方一致しなかった時点で止めるという処理になります。例えば "tokyo" で始まるキーのレコードを取り出すには以下のようなコードになるでしょう。</p>

<pre>cur = tcbdbcurnew();
tcbdbcurjump2(cur, "tokyo");
while((key = tcbdbcurkey2(cur)) != NULL){
  if(!tcstrfwm(kbuf, "tokyo")){
    free(key);
    break;
  }
  if((val = tcbdbcurval2(cur)) != NULL){
    do_something(key, val);
    free(val);
  }
  free(key);
  tcbdbcurnext();
}
tcbdbcurdel(cur);
</pre>

<p>カーソルをジャンプさせてから、他のスレッドが同一のデータベースに対して更新を行った場合、そのカーソルの位置はずれる可能性があります。具体的には、カーソルのあるリーフ上でカーソルより前にレコード挿入された場合、カーソルは小さい方向に一つずれます。また、カーソルのあるリーフ上でカーソルより前にあるレコードが削除された場合、カーソルは大きい方向に一つずれます。したがって、検索などの非クリティカルな操作では特別な配慮は必要ありませんが、更新にカーソルを使う場合には、処理中にカーソルの位置がずれないようにトランザクションを使うか、アプリケーション側の責任で排他制御をすることになるでしょう。なお、典型的な検索操作である範囲検索をアトミックに行うために関数 `<code>tcbdbrange</code>' および関数 `<code>tcbdbfwmkeys</code>' が提供されています。</p>

<h3 id="tips_backup">バックアップ</h3>

<p>データベースファイルのバックアップは、通常のファイルと同様に<code>cp</code>や<code>tar</code>や<code>cpio</code>といったコマンドで行うことができます。ただし、ライタとして接続しているプロセスがデータベースを更新中である場合、コピー元のファイルの状態が中途半端になっている可能性があるため、コピー先のファイルに不整合が起きる場合があります。したがって、データベースが更新中でないこと確認してからバックアップ作業を行うことが必要となります。</p>

<p>デーモンプロセスなどの常駐プロセスがデータベースに接続し続けるユースケースでは上記の手順は現実的ではありません。そういった場合、その常駐プロセスの責任でバックアップ処理を駆動することができます。関数 `<code>tchdbcopy</code>' や `<code>tcbdbcopy</code>' を呼び出すと、更新内容をデータベースファイルと同期させた上で、その間にファイルの複製を行います。</p>

<p>バックアップ用関数は任意のコマンドを呼び出すこともできます。コピー先のファイル名の代わりに "@" で始まるコマンド名を指定するとそれが呼び出されます。そのコマンドの第1引数にはデータベース名が指定され、第2引数には現在のUNIX時間のマイクロ秒が指定されます。例えば、以下のようなシェルスクリプトを用意してそれを呼び出すようにするとよいでしょう。</p>

<pre>#! /bin/sh
srcpath="$1"
destpath="$1.$2"
rm -f "$destpath"
cp -f "$srcpath" "$destpath"
</pre>

<p>バックアップ用のコマンドを実行している間はそのデータベースの更新はブロックしますので、コピーに時間がかかる場合には留意が必要です。無停止のホットバックアップを望むならば、"cp" などによる単純なファイル複製の代わりにファイルシステム（LVM）のスナップショット機能を使うとよいでしょう。</p>

<h3 id="tips_cmphashbtree">ハッシュデータベースとB+木データベースの比較</h3>

<p>キーと値のペアを格納したいというのははっきりしているが、ハッシュデータベースとB+木データベースのどちらを使えばよいかわからないという場合もあるかもしれません。その場合、レコードの検索条件が完全一致だけで済むのなら、ハッシュデータベースを試してください。レコードを順序に基づいて参照したいなら、B+木データベースを試してください。メモリ上だけ保持してファイルに書き出す必要がないならば、ユーティリティAPIのハッシュマップを試してください。</p>

<p>検索条件が完全一致の場合にはハッシュデータベースを使うのが一般的ですが、B+木でも完全一致検索はできます。ファイルシステムのI/Oキャッシュに乗らない大規模のデータベースでは、ハッシュデータベースとB+木データベースの性能特性を考えて、使うデータベースの種類を選択することが重要です。</p>

<p>ハッシュデータベースのキャッシュ機構はレコード単位ですが、B+木データベースはキャッシュ機構はページ単位であるというのが性能上の最大の留意点です。B+木データベースにおいては、データベース内の全てのレコードはキーの昇順で並べられ、順番が近いレコードをページにまとめて管理します。キャッシュやI/Oはページを単位として行います。したがって、順番が近いレコードを参照する場合にはキャッシュがヒットしてI/Oを伴わずに操作が完結するので効率がよくなります。ということは、多数のレコードを格納する際に、対象のレコード群をキーの昇順でソートしてからデータベースに格納すると、I/Oの回数が最小化されて時間効率も空間効率も最高になります。これはアプリケーション層でもキャッシュ機構を持つことを要求するものですが、至高を求めるあなたには不可能ではないはずです。全文検索システムHyper Estraierのインデクシングが高速な秘訣はまさにここにあります。</p>

<p>逆に考えれば、データベースにアクセスする順序が制御できない場合は、B+木データベースよりもハッシュデータベースを使う方が有利ということになります。キャッシュに乗らない場合には、ハッシュデータベースの方がメモリ使用量も小さく、個々のレコードを取り出す際の計算量も小くて済みます。なお、ハッシュデータベースの構築時に一気にレコードを入れるような用途の場合には、非同期モードを使うとB+木データベース以上の更新性能を実現できます。新しいレコードはファイルの末尾に記録されることを利用して、ファイルの末尾部分に特化したキャッシュを作ることができるからです。</p>

<h3 id="tips_tctdb">テーブルデータベースの仕組み</h3>

<p>テーブルデータベースは、リレーショナルデータベースのテーブルのように、複数の列からなるレコードを格納できるデータベースです。ハッシュデータベースのように主キーでレコードを識別しながらも、リレーショナルデータベースのようにレコード内に名前をつけた複数のコラムを持たせることができます。ハッシュデータベースと違って、レコード内の個々のコラムの値を条件にしてレコードの集合を問い合わせることができます。リレーショナルデータベースとは違って、あらかじめスキーマを定義する必要がなく、レコード毎に異なる種類のコラムを持たせることができます。</p>

<p>レコードの検索は、合致条件や順序指定を組み合わせたクエリオブジェクトをデータベースに渡すことで実行されます。合致条件の演算子には以下のものがあります。コマンドラインでは、「TDBQC」の部分を省いた文字列を用います。合致条件の真偽を反転させるには、各演算子と `<code>TDBQCNEGATE</code>' のビット和を用います（コマンドラインでは "~" を接頭させます）。</p>

<ul>
<li>TDBQCSTREQ : 右辺の文字列が完全一致する</li>
<li>TDBQCSTRINC : 右辺の文字列を含む</li>
<li>TDBQCSTRBW : 右辺の文字列で始まる</li>
<li>TDBQCSTREW : 右辺の文字列で終わる</li>
<li>TDBQCSTRAND : 右辺の文字列内の空白またはコンマ区切りの文字列の全てを含む</li>
<li>TDBQCSTROR : 右辺の文字列内の空白またはコンマ区切りの文字列のいずれかを含む</li>
<li>TDBQCSTROREQ : 右辺の文字列内の空白またはコンマ区切りの文字列のいずれかと完全一致する</li>
<li>TDBQCSTRRX : 右辺の文字列の正規表現と一致する</li>
<li>TDBQCNUMEQ : 右辺の数値と一致する</li>
<li>TDBQCNUMGT : 右辺の数値より大きい</li>
<li>TDBQCNUMGE : 右辺の数値と同じかより大きい</li>
<li>TDBQCNUMLT : 右辺の数値より小さい</li>
<li>TDBQCNUMLE : 右辺の数値と同じかより小さい</li>
<li>TDBQCNUMBT : 右辺の空白またはコンマ区切りの2つの数値の間である</li>
<li>TDBQCNUMOREQ : 右辺の空白またはコンマ区切りの数値のいずれかと一致する</li>
<li>TDBQCFTSPH : 右辺の文字列を用いてフレーズ検索の全文検索を行う</li>
<li>TDBQCFTSAND : 右辺の空白またはコンマ区切りの文字列を用いてAND検索の全文検索を行う</li>
<li>TDBQCFTSOR : 右辺の空白またはコンマ区切りの文字列を用いてOR検索の全文検索を行う</li>
<li>TDBQCFTSEX : 右辺の文字列を用いて複合検索式の全文検索を行う</li>
</ul>

<p>順序指定の演算子には以下のものがあります。デフォルトは順序不定です。</p>

<ul>
<li>TDBQOSTRASC : 文字列の辞書順の昇順</li>
<li>TDBQOSTRDESC : 文字列の辞書順の降順</li>
<li>TDBQOSTRASC : 数値の昇順</li>
<li>TDBQOSTRDESC : 数値の降順</li>
</ul>

<p>`<code>TDBQCSTRAND</code>' と `<code>TDBQCSTROR</code>' は、いわゆるタグ検索のための演算子です。タグ検索とは、空白またはコンマで区切られたトークンをタグとみなして、そのタグが存在するか否かを判定してレコードを探す操作です。`<code>TDBQCSTRINC</code>' のように任意の部分文字列を探すのではなく、トークン単位の完全一致を判定します。タグ検索を高速化するには後述のトークン転置インデックスを張ることが推奨されます。`<code>TDBQCSTROREQ</code>' 演算子もタグ検索に使うことができますが、SQLのIN演算子と同じように、検索されるレコードのコラムには単一のトークンしか含まれてはならないという制約があります。その分、通常の文字列型のインデックスが効くという利点があります。</p>

<p>`<code>TDBQCFTSPH</code>' と `<code>TDBQCFTSAND</code>' と `<code>TDBQCFTSOR</code>' と `<code>TDBQCFTSEX</code>' は、いわゆる全文検索のための演算子です。全文検索は前述のタグ検索と違って、空白やコンマの区切りを単位としない任意の部分文字列の一致を判定できる点で `<code>TDBQCSTRINC</code>' に類似しています。ただし、大文字小文字やアクセントマークなどの違いを吸収するため、ユーザが入力した任意のテキストを検索するのに便利です。全文検索を実用的な速度で動作させるためには後述のq-gram転置インデックスを張っておくことが必要です。`<code>TDBQCFTSEX</code>' 演算子で用いる複合検索式においては、空白で区切って複数のトークンを指定すると、その全てのトークンを含むというAND条件で検索できます。空白および「&amp;&amp;」で区切っても同じ意味になります。空白および「||」で区切ると、両辺のトークンのどちらかを含むというOR条件で検索できます。トークンに空白を含めたい場合は「""」で括ります。演算子の結合優先順位は「""」「||」「&amp;&amp;」の順になります。同一順位の演算子は左結合で評価されます。</p>

<h3 id="tips_tctdbindex">テーブルデータベースのインデックス</h3>

<p>テーブルデータベースを検索する際に、合致条件の判定や順序指定によるソートを高速化するために、任意のコラムを対象としてインデックスを張ることができます。コラムには型がありませんが、インデックスには型があります。文字列型の演算を高速化させたい場合は文字列型のインデックスを、数値型の演算子を高速化させたい場合は数値型のインデックスを、トークン型の演算子を高速化させたい場合はトークン転置インデックスを張ることになります。ただし、型が異なる場合でもインデックスを張っておくと、メインのハッシュデータベースの全表スキャンの代わりに、それよりは小さいインデックスの全表スキャンを用いるので、計算量は同じですが処理時間は短くなります。</p>

<ul>
<li>文字列型インデックス（TDBITLEXICAL）:<ul>
<li>計算量が小さくなる演算子：TDBQCSTREQ、TDBQCSTRBW、TDBQCSTROREQ</li>
<li>計算量は同じだが高速化する演算子：TDBQCSTRINC、TDBQCSTREW、TDBQCSTRAND、TDBQCSTROR、TDBQCSTRRX、TDBQCNUMEQ、TDBQCNUMGT、TDBQCNUMGE、TDBQCNUMLT、TDBQCNUMLE、TDBQCNUMBT、TDBQCNUMOREQ</li>
<li>計算量が小さくなる順序指定：TDBQOSTRASC、TDBQOSTRDESC</li>
</ul></li>
<li>数値型インデックス（TDBITDECIMAL）:<ul>
<li>計算量が小さくなる演算子：TDBQCNUMEQ、TDBQCNUMGT、TDBQCNUMGE、TDBQCNUMLT、TDBQCNUMLE、TDBQCNUMBT、TDBQCNUMOREQ</li>
<li>計算量は同じだが高速化する演算子：TDBQCSTREQ、TDBQCSTRBW、TDBQCSTROREQ、TDBQCSTRINC、TDBQCSTREW、TDBQCSTRAND、TDBQCSTROR、TDBQCSTRRX</li>
<li>計算量が小さくなる順序指定：TDBQONUMASC、TDBQONUMDESC</li>
</ul></li>
<li>トークン転置インデックス（TDBITTOKEN）:<ul>
<li>計算量が小さくなる演算子：TDBQCSTRAND、TDBQCSTROR</li>
</ul></li>
<li>q-gram転置インデックス（TDBITQGRAM）:<ul>
<li>計算量が小さくなる演算子：TDBQCFTSPH、TDBQCFTSAND、TDBQCFTSOR、TDBQCFTSEX</li>
</ul></li>
</ul>

<p>合致条件に利用できるインデックスが複数ある場合、型が一致する最初に指定された演算子に対して適用されます。したがって、カーディナリティが高い条件を先に指定する方が効率的になります。合致条件の演算子を `<code>TDBQCNOIDX</code>' とのビット和にすると、その条件の判定にインデックスを適用しないようになります（コマンドラインでは "+" を接頭させます）。否定の合致条件にはインデックスは適用されません。インデックスのデータは、レコード本体を格納したデータベースファイルとは別個に、B+木データベースのファイルとして記録されます。</p>

<p>転置インデックスとは、検索対象の文字列がどのレコードに含まれているかを記録して効率的に探し出すためのインデックスです。トークン転置インデックスとq-gram転置インデックスの二種類の方式をサポートしています。トークン転置インデックスは、空白もしくはコンマで区切られた単語をキーにしてレコードを探すための構造で、`<code>TDBQCSTRAND</code>' などの演算子を高速化するので、いわゆるタグ検索などに重宝するでしょう。q-gram転置インデックスは、3文字毎の部分文字列（tri-gram）をキーにしてレコードを探すための構造で、`<code>TDBQCFTSPH</code>' などの演算子を高速化するので、いわゆる全文検索などに重宝するでしょう。全文検索系の演算子は大文字小文字の違いやアクセント記号の有無などを無視して検索してくれるので便利です。転置インデックス（特にq-gram転置インデックス）はサイズがかなり大きくなり、更新処理にかかるオーバーヘッドも大きくなってしまうので、ご利用は計画的にお願いします。</p>

<h3 id="tips_tcadb">抽象データベース</h3>

<p>ハッシュデーターベースかB+木データベースかを実行時に決定したい場合には、抽象データベースAPIを使うとよいでしょう。抽象データベースAPIはハッシュデータベースAPIとB+木データベースAPIの共通のインターフェイスで、関数 `<code>tcadbopen</code>' でデータベースを開く際のデータベース名で具体的にどの種類のデータベースを扱うかを指定することができます。ハッシュデータベースの名前には接尾辞として ".tch" をつけ、B+木データベースの名前には接尾辞として ".tcb" をつけることで区別されます。チューニングパラメータは、名前の後に "#" で区切って "name=value" の形式で指定します。例えば "casket.tch#bnum=1000000#apow=10" などとします。数値表現には "k"、"m"、"g" などの2進接頭辞を接尾させることもできます。また、データベース名の接尾辞に ".tcf" をつけると固定長データベースになります。連番のID番号をキーにして固定長のデータを管理する場合には最も効率が良くなります。</p>

<p>抽象データベースAPIはオンメモリハッシュデータベースやオンメモリツリーデータベースとしても利用することができます。データベース名を "*" とするとオンメモリハッシュデータベースになり、"+" とするとオンメモリツリーデータベースになります。また、それらをキャッシュとして利用したい場合は、"*#capsiz=100m" などとするとよいでしょう。キャッシュの容量を100MBに限定して、それを越えた際には格納した順序が古いレコードから自動的に消していくようになります。オンメモリハッシュデータベースとオンメモリツリーデータベースの使い分けですが、パフォーマンスを求める場合には前者を用い、メモリ効率を求めたり前方一致検索を行いたい場合には後者を用いるとよいでしょう。</p>

<p>DBMとして一般的でない機能は関数 `<code>tcadbmisc</code>' に隠蔽されています。この関数はサブ関数名を第1引数に指定し、それに応じて解釈の変わる引数リストを与えて実行します。サポートされるサブ関数は具象データベースの型によって異なります。複数のレコードを一度に扱える "putlist"、"outlist"、"getlist" は全ての具象データベースでサポートされています。その他にも様々な機能がありますが、作者の気まぐれで増えるのでここでは全てを説明できません。詳しくはソースコードをご覧ください。</p>

<h3 id="tips_tcadbtable">抽象データベースによるテーブル操作</h3>

<p>抽象データベースの接尾辞に ".tct" をつけるとテーブルデータベースになります。テーブルデータベースでは単一の文字列を値とする代わりにコラムの名前と値のマップが用いられます。抽象データベースでテーブルデータベースを扱う場合、単一の文字列とマップを同一のインターフェイスで扱うために、ゼロ文字（'\0'）を区切り文字としてコラムの名前と値を交互に並べて直列化した文字列を用います。レコードを格納する際（`<code>tcadbput</code>'）の引数やレコードを取得する際（`<code>tcadbget</code>'）の戻り値にはそのゼロ区切り文字列が使われます。</p>

<p>レコードの検索は関数 `<code>tcadbmisc</code>' のサブ関数 "search" で行います。引数に "addcond" か "setorder" か "setlimit" か "get" か "out" を接頭させてゼロ文字区切りで演算式を記述した文字列を与えることでクエリを組み立てます。例えば "addcond\0name\0STRBW\0john" と "setorder\0age\0NUMASC" を指定すると、「コラム "name" の値が "john" で始まるレコードをコラム "age" の数値の昇順で取り出す」というクエリになります。戻り値は該当するレコードの主キーのリストです。ただし、"get" が指定されると、コラム名と値のマップをゼロ区切り文字列で返します。"get\0name\0age" などとして特定のコラムに絞り込むこともできます。"out" が指定されると、該当のコラムを削除します。"get" と "out" を組み合わせるとキューとして利用することができます。サブ関数 "genuid" は、ユニークなID番号を採番して返します。</p>

<h3 id="tips_hiddenapi">隠しAPI</h3>

<p>この文書に書いてあるAPIは、全体の70%くらいです。つまり、この文書に書いていない隠しAPIが30%くらいあります。興味のある人はヘッダファイル（`<code>tcutil.h</code>'、`<code>tchdb.h</code>'、`<code>tcbdb.h</code>'、`<code>tcfdb.h</code>'、`<code>tctdb.h</code>'、`<code>tcadb.h</code>'）の中身を覗いてみてください。上級者用でちょっと癖が強いけれども、使いこなすと機能や性能の面でにかなり有利になるAPIが揃っています。その中でも特に便利なのは、"putproc" 系の関数です。これはputと同様にレコードの挿入を試みるのですが、既存のレコードがあった場合にそれを引数にしてコールバック関数を呼ぶので、任意の更新操作をアトミックに行うことができます。また、"foreach" 系の関数も便利です。これはデータベース内の全てのレコードをアトミックに走査しながら、各々のレコードを引数にしてコールバック関数を呼び出します。</p>

<p>抽象データベースAPIの隠しAPI関数 `<code>tcadbsetskel</code>' は激アツです。拡張データベーススケルトンと呼ばれる構造体によって関数ポインタの集合を指定することで、抽象データベースの全てのメソッドの振る舞いをオーバーライドすることができるようになります。そうすると、DBM風のインターフェイスを持つ全てのライブラリをTokyo Cabinetと同じインターフェイスで使えるようになります。典型的には以下のような実装になります。</p>

<pre>ADBSKEL skel;
memset(0, &amp;skel, sizeof(skel));
skel.opq = mydbnew();    // レシーバオブジェクトを生成して設定
skel.del = mydbdel;      // デストラクタをオーバーライド
skel.open = mydbopen;    // openメソッドをオーバーライド
skel.close = mydbclose;  // closeメソッドをオーバーライド
...                      // その他、好きなメソッドをオーバーライド
TCADB *adb = tcadbnew();
tcadbsetskel(adb, &amp;skel);
tcadbopen(adb, "foobarbaz");
...
</pre>

<p>拡張データベーススケルトンの一実装である「複式抽象データベース」を設定するユーティリティとして、隠しAPI関数 `<code>tcadbsetskelmulti</code>' が提供されます。これを適用した抽象データベースは、パラメータで指定した数にデータベースが分割されるようになりますが、具象データベースの種類に関わらず、レコードの挿入や削除などの操作を透過的に行うことができます。データベース名はファイル名ではなくディレクトリ名として扱われ、そのディレクトリの中に複数のデータベースファイルが作られます。レコードはキーのハッシュ値により分散されてどれかひとつのデータベースに格納されます。データベースを分割すると何が嬉しいかというと、データベース操作に要する排他制御の粒度がその分割数に応じて細分化することです。したがって、たとえ下層のデータベースが最適化などのグローバルなロックを要する操作を行っていたとしても、複式抽象データベースを用いていれば、スレッドがブロックする時間を分割数の逆数にまで下げることができます。ただしその代償として、CPUにオーバヘッドがかかることと、`<code>tcadbfwmkeys</code>' などの集合演算の結果の順序が不定になることは覚悟してください。複式抽象データベースに対して `<code>tcadbmisc</code>' を実行する際には、サブ関数名に "@" か "%" を接頭させて引数毎の操作対象を指定できます。"@" は全ての引数をキーとみなして、引数毎に別々の内部データベースを対象としてサブ関数を実行します。"%" は引数をキーと値のペアのリストとみなして、そのペア毎に別々の内部データベースを対象としてサブ関数を実行します。すなわち、"getlist" は "@getlist" として実行すべきで、"putlist" は "%putlist" として実行すべきです。"@" も "%" もつかない場合には各々の内部データベースに対して全ての引数を渡して該当の操作を実行します。</p>

<pre>TCADB *adb = tcadbnew();
tcadbsetskelmulti(adb, 8);     // 8分割の複式抽象データベースとしてマーク
tcadbopen(adb, "casket.tch");  // ハッシュデータベースとして開く
...
</pre>

<h3 id="tips_tcrdb">リモートインターフェイス</h3>

<p>多種のアプリケーションでデータベースを共有したい場合やWebアプリケーション等でマルチプロセスの並列処理を行う場合は、Tokyo Cabinetのファイルロック機構が鬱陶しく感じるかもしれません。また、複数のマシンからデータベースを参照したい場合にはTokyo Cabinetだと困ってしまうかもしれません。</p>

<p>データベースの管理のみを行うサーバを別プロセスとして立ちあげて、アプリケーションのプロセスがネットワークソケットを介してそのサーバに接続すれば上記の問題は解決します。そのようなデータベースサーバとそれに接続するためのライブラリが別パッケージ「Tokyo Tyrant」として提供されています。Tokyo Tyrantのサーバは抽象データベースを扱うので、Tokyo Cabinetの全種類のデータベースをリモートインターフェイスで操作することができます。</p>

<h3 id="tips_binding">C言語以外の言語のバインディング</h3>

<p>PerlとRubyとJavaとLuaの言語バインディングに関しては、Tokyo Cabinetの作者が開発およびメンテナンスを行います。それ以外の言語に関しては、第三者が提供してくれることを望みます。現状では、少なくともPythonとPHPとSchemeとCommon LispとErlangとHaskellの処理系でもTokyo Cabinetを利用できるようです。</p>

<p>ユーザの利便性を考えると、C言語以外の言語においても、APIのシンボル名や使い方はできるだけ似通ったものにすることが望ましいでしょう。そのために、`<code>tokyocabinet.idl</code>' が提供されます。これはIDLで言語共通の（最大公約数的な）インターフェイスを定義したものですので、新たな言語バインディングを設計する際には、できるだけそれに準拠するようにしてください。IDLで定義されていない機能は各言語の流儀にできるだけ合わせてください。インストールの手順やドキュメントなどのパッケージの構造についても、各言語の流儀にできるだけ合わせるとよいでしょう。</p>

<hr />

<h2 id="fileformat">ファイルフォーマット</h2>

<p>この節ではデータベースファイルのフォーマットに関する仕様を示します。</p>

<h3 id="fileformat_tchdb">ハッシュデータベースのファイルフォーマット</h3>

<p>ハッシュデータベースが管理するデータベースファイルの内容は、ヘッダ部、バケット部、フリーブロックプール部、レコード部の4つに大別されます。ファイルに記録される数値は固定長数値もしくは可変長数値として記録されます。前者は数値を特定の領域にリトルエンディアンで直列化したものです。後者は数値を可変長の領域に128進法のデルタ符号で直列化したものです。</p>

<p>ヘッダ部はファイルの先頭から256バイトの固定長でとられ、以下の情報が記録されます。</p>

<table summary="database header format">
<tr>
<td class="label">名前</td>
<td class="label">オフセット</td>
<td class="label">データ長</td>
<td class="label">機能</td>
</tr>
<tr>
<td>マジックナンバ</td>
<td class="number">0</td>
<td class="number">32</td>
<td>データベースファイルであることの判別。「ToKyO CaBiNeT」で始まる</td>
</tr>
<tr>
<td>データベースタイプ</td>
<td class="number">32</td>
<td class="number">1</td>
<td>ハッシュ表（0x01）かB+木（0x02）か固定長（0x03）かテーブル（0x04）</td>
</tr>
<tr>
<td>追加フラグ</td>
<td class="number">33</td>
<td class="number">1</td>
<td>開きっぱなし（1&lt;&lt;0）、致命的エラー（1&lt;&lt;1）の論理和</td>
</tr>
<tr>
<td>アラインメント力</td>
<td class="number">34</td>
<td class="number">1</td>
<td>アラインメントに対する2の冪乗</td>
</tr>
<tr>
<td>フリーブロックプール力</td>
<td class="number">35</td>
<td class="number">1</td>
<td>フリーブロックプールの要素数に対する2の冪乗</td>
</tr>
<tr>
<td>オプション</td>
<td class="number">36</td>
<td class="number">1</td>
<td>ラージモード（1&lt;&lt;0）、Deflate圧縮モード（1&lt;&lt;1）、BZIP2圧縮モード（1&lt;&lt;2）、TCBS圧縮モード（1&lt;&lt;3）、外部圧縮モード（1&lt;&lt;4）の論理和</td>
</tr>
<tr>
<td>バケット数</td>
<td class="number">40</td>
<td class="number">8</td>
<td>バケット配列の要素数</td>
</tr>
<tr>
<td>レコード数</td>
<td class="number">48</td>
<td class="number">8</td>
<td>格納しているレコードの数</td>
</tr>
<tr>
<td>ファイルサイズ</td>
<td class="number">56</td>
<td class="number">8</td>
<td>データベースファイルのサイズ</td>
</tr>
<tr>
<td>先頭レコード</td>
<td class="number">64</td>
<td class="number">8</td>
<td>最初のレコードのオフセット</td>
</tr>
<tr>
<td>不透明領域</td>
<td class="number">128</td>
<td class="number">128</td>
<td>ユーザが自由に使える領域</td>
</tr>
</table>

<p>バケット部はヘッダ部の直後にバケット配列の要素数に応じた大きさでとられ、ハッシュチェーンの先頭要素のオフセットが各要素に記録されます。各要素は固定長数値で、そのサイズはノーマルモードでは4バイト、ラージモードでは8バイトです。また、オフセットはアラインメントで割った商として記録されます。</p>

<p>フリーブロックプール部はバケット部の直後にフリーブロックプールの要素数に応じた大きさでとられ、未使用領域のオフセットと長さが各要素に記録されます。オフセットはアラインメントで割った商に変換した上で、直前の要素の値との差分として記録されます。オフセットとサイズは可変長数値として扱われます。</p>

<p>レコード部はバケット部の直後からファイルの末尾までを占め、各レコードの以下の情報を持つ要素が記録されます。各レコードの領域は常にアラインメントされた位置から始まります。</p>

<table summary="record format">
<tr>
<td class="label">名前</td>
<td class="label">オフセット</td>
<td class="label">データ長</td>
<td class="label">機能</td>
</tr>
<tr>
<td>マジックナンバ</td>
<td class="number">0</td>
<td class="number">1</td>
<td>データの識別と整合性確認に用いる。0xC8固定</td>
</tr>
<tr>
<td>ハッシュ値</td>
<td class="number">1</td>
<td class="number">1</td>
<td>チェーンの進路決定に用いるハッシュ値</td>
</tr>
<tr>
<td>左チェーン</td>
<td class="number">2</td>
<td class="number">4</td>
<td>左チェーン接続先のオフセットのアラインメント商</td>
</tr>
<tr>
<td>右チェーン</td>
<td class="number">6</td>
<td class="number">4</td>
<td>右チェーン接続先のオフセットのアラインメント商</td>
</tr>
<tr>
<td>パディングサイズ</td>
<td class="number">10</td>
<td class="number">2</td>
<td>パディングのサイズ</td>
</tr>
<tr>
<td>キーサイズ</td>
<td class="number">12</td>
<td class="number">可変</td>
<td>キーのサイズ</td>
</tr>
<tr>
<td>値サイズ</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>値のサイズ</td>
</tr>
<tr>
<td>キー</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>キーのデータ</td>
</tr>
<tr>
<td>値</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>値のデータ</td>
</tr>
<tr>
<td>パディング</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>意味を持たないデータ</td>
</tr>
</table>

<p>ただし、フリーブロックとなった領域には、各レコードの以下の情報を持つ要素が記録されます。</p>

<table summary="free block format">
<tr>
<td class="label">名前</td>
<td class="label">オフセット</td>
<td class="label">データ長</td>
<td class="label">機能</td>
</tr>
<tr>
<td>マジックナンバ</td>
<td class="number">0</td>
<td class="number">1</td>
<td>データの識別と整合性確認に用いる。0xB0固定</td>
</tr>
<tr>
<td>ブロックサイズ</td>
<td class="number">1</td>
<td class="number">4</td>
<td>ブロックのサイズ</td>
</tr>
</table>

<p>トランザクションログはデータベース名に ".wal" を後置した名前のファイルとして記録されます。ファイルの先頭8バイトにトランザクション開始時のデータベースファイルのサイズを記録し、その後に更新操作による差分情報を持つ以下の要素を連結します。</p>

<table summary="transaction log format">
<tr>
<td class="label">名前</td>
<td class="label">オフセット</td>
<td class="label">データ長</td>
<td class="label">機能</td>
</tr>
<tr>
<td>オフセット</td>
<td class="number">0</td>
<td class="number">8</td>
<td>更新された領域の先頭のオフセット</td>
</tr>
<tr>
<td>サイズ</td>
<td class="number">8</td>
<td class="number">4</td>
<td>更新された領域のサイズ</td>
</tr>
<tr>
<td>データ</td>
<td class="number">12</td>
<td class="number">可変</td>
<td>更新される領域の更新前のデータ</td>
</tr>
</table>

<h3 id="fileformat_tcbdb">B+木データベースのファイルフォーマット</h3>

<p>B+木データベースが扱う全てのデータはハッシュデータベースに記録されます。記録されるデータは、メタデータと論理ページに分類されます。論理ページはリーフノードと非リーフノードに分類されます。固定長数値と可変長数値の形式はハッシューデータベースと同じです。</p>

<p>メタデータはハッシュデータベースのヘッダにおける不透明領域にとられ、以下の情報が記録されます。</p>

<table summary="database header format">
<tr>
<td class="label">名前</td>
<td class="label">オフセット</td>
<td class="label">データ長</td>
<td class="label">機能</td>
</tr>

<tr>
<td>比較関数</td>
<td class="number">0</td>
<td class="number">1</td>
<td>比較関数がtccmplexical（デフォルト）なら0x00、tccmpdecimalなら0x01、tccmpint32なら0x02、tccmpint64なら0x03、それ以外なら0xff</td>
</tr>
<tr>
<td>予約領域</td>
<td class="number">1</td>
<td class="number">7</td>
<td>現状では利用していない。</td>
</tr>
<tr>
<td>リーフ内レコード数</td>
<td class="number">8</td>
<td class="number">4</td>
<td>個々のリーフノードに入れるレコードの最大数</td>
</tr>
<tr>
<td>非リーフ内インデックス数</td>
<td class="number">12</td>
<td class="number">4</td>
<td>個々の非リーフノードに入れるインデックスの最大数</td>
</tr>
<tr>
<td>ルートノードID</td>
<td class="number">16</td>
<td class="number">8</td>
<td>B+木のルートノードのページID</td>
</tr>
<tr>
<td>先頭リーフID</td>
<td class="number">24</td>
<td class="number">8</td>
<td>先頭のリーフノードのID</td>
</tr>
<tr>
<td>末尾リーフID</td>
<td class="number">32</td>
<td class="number">8</td>
<td>末尾のリーフノードのID</td>
</tr>
<tr>
<td>リーフ数</td>
<td class="number">40</td>
<td class="number">8</td>
<td>リーフノードの数</td>
</tr>
<tr>
<td>非リーフ数</td>
<td class="number">48</td>
<td class="number">8</td>
<td>非リーフノードの数</td>
</tr>
<tr>
<td>レコード数</td>
<td class="number">56</td>
<td class="number">8</td>
<td>格納しているレコードの数</td>
</tr>
</table>

<p>リーフノードはレコードのリストを保持し、非リーフノードはページを参照する疎インデックスを保持します。レコードはユーザデータの論理的な単位です。キーが重複する論理レコードは物理的には単一のレコードにまとめられます。物理レコードは以下の形式で直列化されます。</p>

<table summary="record format">
<tr>
<td class="label">名前</td>
<td class="label">オフセット</td>
<td class="label">データ長</td>
<td class="label">機能</td>
</tr>
<tr>
<td>キーサイズ</td>
<td class="number">0</td>
<td class="number">可変</td>
<td>キーのサイズ</td>
</tr>
<tr>
<td>値サイズ</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>最初の値のサイズ</td>
</tr>
<tr>
<td>重複数</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>キーが重複した値の数</td>
</tr>
<tr>
<td>キー</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>キーのデータ</td>
</tr>
<tr>
<td>値</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>最初の値のデータ</td>
</tr>
<tr>
<td>重複レコード</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>値のサイズと値のデータのリスト</td>
</tr>
</table>

<p>リーフノードはレコードの集合を格納するための物理的な単位です。リーフノードは1からインクリメントして振られるID番号で識別されます。リーフノードはID番号を16進数の文字列として表現したデータをキーとし、以下の値を持つレコードとしてハッシュデータベースに格納されます。レコードは常にキーの昇順に整列した状態で保持されます。</p>

<table summary="leaf node format">
<tr>
<td class="label">名前</td>
<td class="label">オフセット</td>
<td class="label">データ長</td>
<td class="label">機能</td>
</tr>
<tr>
<td>前リーフ</td>
<td class="number">0</td>
<td class="number">可変</td>
<td>直前のリーフノードのID</td>
</tr>
<tr>
<td>後リーフ</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>直後のリーフノードのID</td>
</tr>
<tr>
<td>レコードリスト</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>ページのレコードを直列化して連結したデータ</td>
</tr>
</table>

<p>インデックスは子ページを探索するためのポインタの論理的な単位です。インデックスは以下の形式で直列化されます。</p>

<table summary="index format">
<tr>
<td class="label">名前</td>
<td class="label">オフセット</td>
<td class="label">データ長</td>
<td class="label">機能</td>
</tr>
<tr>
<td>ページID</td>
<td class="number">0</td>
<td class="number">可変</td>
<td>参照先のページのID</td>
</tr>
<tr>
<td>キーサイズ</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>キーのサイズ</td>
</tr>
<tr>
<td>キー</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>キーのデータ</td>
</tr>
</table>

<p>非リーフノードはインデックスの集合を格納するための物理的な単位です。非リーフノードは281474976710657からインクリメントして振られるID番号で識別されます。非リーフノードはID番号から281474976710657を引いた値を16進数の文字列とにした上で「#」を接頭させた文字列をキーとし、以下の値を持つレコードとしてハッシュデータベースに格納されます。インデックスは常に昇順に整列した状態で保持されます。</p>

<table summary="non-leaf format">
<tr>
<td class="label">名前</td>
<td class="label">オフセット</td>
<td class="label">データ長</td>
<td class="label">機能</td>
</tr>
<tr>
<td>継承ID</td>
<td class="number">0</td>
<td class="number">可変</td>
<td>最初の子ノードのID</td>
</tr>
<tr>
<td>インデックスリスト</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>ページ内のインデックスを直列化して連結したデータ</td>
</tr>
</table>

<h3 id="fileformat_tcfdb">固定長データベースのファイルフォーマット</h3>

<p>固定長データベースが管理するデータベースファイルの内容は、ヘッダ部とレコード部の2つに大別されます。ファイルに記録される数値はリトルエンディアンの固定長数値として記録されます。</p>

<p>ヘッダ部はファイルの先頭から256バイトの固定長でとられ、以下の情報が記録されます。</p>

<table summary="database header format">
<tr>
<td class="label">名前</td>
<td class="label">オフセット</td>
<td class="label">データ長</td>
<td class="label">機能</td>
</tr>
<tr>
<td>マジックナンバ</td>
<td class="number">0</td>
<td class="number">32</td>
<td>データベースファイルであることの判別。「ToKyO CaBiNeT」で始まる</td>
</tr>
<tr>
<td>データベースタイプ</td>
<td class="number">32</td>
<td class="number">1</td>
<td>0x03固定</td>
</tr>
<tr>
<td>追加フラグ</td>
<td class="number">33</td>
<td class="number">1</td>
<td>開きっぱなし（1&lt;&lt;0）、致命的エラー（1&lt;&lt;1）の論理和</td>
</tr>
<tr>
<td>レコード数</td>
<td class="number">48</td>
<td class="number">8</td>
<td>格納しているレコードの数</td>
</tr>
<tr>
<td>ファイルサイズ</td>
<td class="number">56</td>
<td class="number">8</td>
<td>データベースファイルのサイズ</td>
</tr>
<tr>
<td>レコード幅</td>
<td class="number">64</td>
<td class="number">8</td>
<td>各レコードの値の幅</td>
</tr>
<tr>
<td>制限サイズ</td>
<td class="number">72</td>
<td class="number">8</td>
<td>データベースファイルの制限サイズ</td>
</tr>
<tr>
<td>最小ID</td>
<td class="number">80</td>
<td class="number">8</td>
<td>現在のレコードIDの最小値</td>
</tr>
<tr>
<td>最大ID</td>
<td class="number">88</td>
<td class="number">8</td>
<td>現在のレコードIDの最大値</td>
</tr>
<tr>
<td>不透明領域</td>
<td class="number">128</td>
<td class="number">128</td>
<td>ユーザが自由に使える領域</td>
</tr>
</table>

<p>レコード部はヘッダ部の直後からファイルの末尾までを占め、各レコードの以下の情報を持つ要素が記録されます。値サイズに必要な領域は、レコード幅が255以下なら1バイト、65535以下なら2バイト、それを越えれば4バイトです。レコード長は値サイズに必要な領域とレコード幅を足したものです。各レコードの領域は、レコードIDから1を引いた値にレコード長を掛け、それに256を足した位置から始まります。</p>

<table summary="record format">
<tr>
<td class="label">名前</td>
<td class="label">オフセット</td>
<td class="label">データ長</td>
<td class="label">機能</td>
</tr>
<tr>
<td>値のサイズ</td>
<td class="number">0</td>
<td class="number">可変</td>
<td>値のサイズ</td>
</tr>
<tr>
<td>値</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>値のデータ</td>
</tr>
<tr>
<td>パディング</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>値サイズが0の時は、先頭バイトの真偽値でレコードの有無を示す</td>
</tr>
</table>

<p>トランザクションログの命名規則やフォーマットはハッシュデータベースのものと同じです。</p>

<h3 id="fileformat_note">注記</h3>

<p>データベースファイルはスパースではないので、通常のファイルと同様に複製等の操作を行うことができます。またフォーマットも実行環境のバイトオーダに依存しないので、バイトオーダの異なる環境にデータベースファイルを移設してもそのままで利用できます。</p>

<p>なるべくなら、ハッシュデータベースのファイルをネットワークで配布する際には、MIMEタイプを `<code>application/x-tokyocabinet-hash</code>' にしてください。ファイル名の接尾辞は `<code>.tch</code>' にしてください。B+木データベースのファイルをネットワークで配布する際には、MIMEタイプを `<code>application/x-tokyocabinet-btree</code>' にしてください。ファイル名の接尾辞は `<code>.tcb</code>' にしてください。固定長データベースのファイルをネットワークで配布する際には、MIMEタイプを `<code>application/x-tokyocabinet-fixed</code>' にしてください。ファイル名の接尾辞は `<code>.tcf</code>' にしてください。テーブルデータベースのファイルをネットワークで配布する際には、MIMEタイプを `<code>application/x-tokyocabinet-table</code>' にしてください。ファイル名の接尾辞は `<code>.tct</code>' にしてください。</p>

<p>データベースファイルのマジックデータを `<code>file</code>' コマンドに識別させたい場合は、`<code>magic</code>' ファイルに以下の行を追記してください。</p>

<pre># Tokyo Cabinet magic data
0       string    ToKyO\ CaBiNeT\n   Tokyo Cabinet
&gt;14     string    x                  \b (%s)
&gt;32     byte      0                  \b, Hash
!:mime  application/x-tokyocabinet-hash
&gt;32     byte      1                  \b, B+ tree
!:mime  application/x-tokyocabinet-btree
&gt;32     byte      2                  \b, Fixed-length
!:mime  application/x-tokyocabinet-fixed
&gt;32     byte      3                  \b, Table
!:mime  application/x-tokyocabinet-table
&gt;33     byte      &amp;1                 \b, [open]
&gt;33     byte      &amp;2                 \b, [fatal]
&gt;34     byte      x                  \b, apow=%d
&gt;35     byte      x                  \b, fpow=%d
&gt;36     byte      &amp;1                 \b, [large]
&gt;36     byte      &amp;2                 \b, [deflate]
&gt;36     byte      &amp;4                 \b, [bzip]
&gt;36     byte      &amp;8                 \b, [tcbs]
&gt;36     byte      &amp;16                \b, [excodec]
&gt;40     lequad    x                  \b, bnum=%lld
&gt;48     lequad    x                  \b, rnum=%lld
&gt;56     lequad    x                  \b, fsiz=%lld
</pre>

<hr />

<h2 id="faq">よく聞かれる質問</h2>

<dl>
<dt>Q. : Tokyo CabinetはSQLをサポートしますか？</dt>
<dd>A. : Tokyo CabinetはSQLをサポートしません。Tokyo CabinetはRDBMS（関係データベース管理システム）ではありません。組み込みのRDBMSを求めるなら、SQLiteなどを利用するとよいでしょう。</dd>
<dt>Q. : Berkeley DBとどう違うのですか？</dt>
<dd>A. : 時間効率と空間効率の双方でTokyo Cabinetが優っています。</dd>
<dt>Q. : アプリケーションの良いサンプルコードはありますか？</dt>
<dd>A. : 各APIのコマンドのソースコードを参考にしてください。`<code>tchmgr.c</code>' と `<code>tcbmgr.c</code>' と `<code>tcfmgr.c</code>' が最も簡潔でしょう。</dd>
<dt>Q. : tchdbputkeep2とか、APIのシグネチャがわかりにくいんですけど、アンダースコア区切りとかCamelCaseとか使わないんですか？</dt>
<dd>A. : 使いません。UNIX（POSIX）にも、creatとかsbrkとかdup2とかwait3とかwait4とかsigprocmaskとかstrncasecmpとかgethostbyname2とか、あなた好みでないものが多くあります。逆に私はUNIXのようにハードボイルドでユーザに媚びない名前が好きなのです。</dd>
<dt>Q. : データベースが壊れたのですが、どうしてでしょうか？</dt>
<dd>A. : 大抵の場合、あなたのアプリケーションがきちんとデータベースを閉じていないのが原因です。デーモンプロセスであろうが、CGIスクリプトであろうが、アプリケーションが終了する際には必ずデータベースを閉じなければなりません。なお、CGIのプロセスはSIGPIPEやSIGTERMによって殺されることがあることにも留意しましょう。</dd>
<dt>Q. : データベースを壊れにくくするにはどうすればよいですか？</dt>
<dd>A. : トランザクションを使ってください。ディスクやファイルシステムが壊れなければデータベースが壊れないようにすることができます。</dd>
<dt>Q. : 壊れたデータベースを修復するにはどうすればよいですか？</dt>
<dd>A. : データベースファイルをロックなしオプション（<code>HDBONOLCK</code>か<code>BDBONOLCK</code>）をつけて開いて、最適化機能（<code>tchdboptimize</code>か<code>tcbdboptimize</code>）を実行してください。コマンドラインで修復処理を行いたい場合、「<code>tchmgr optimize -nl casket</code>」もしくは「<code>tcbmgr optimize -nl casket</code>」を実行してください。</dd>
<dt>Q. : 2GBを越えるサイズのファイルを扱おうとするとエラーになるのですが、どうしてですか？</dt>
<dd>A. : 32ビットのファイルシステムでは、LFSなどの明示的な指定をしないと2GBを越えるサイズのファイルを作ることができません。32ビットOS上でXFSやFeiserFSなどの64ビットファイルシステムを利用する場合は2GBを越えるサイズのファイルを扱うことができますが、その際にはTokyo Cabinetを `<code>--enable-off64</code>' をつけた設定でビルドしておく必要があります。純粋な64ビット環境で利用する場合は特別な設定は必要ありません。なお、ulimitやquotaでファイルサイズの制限がかかっていないことも確認しておいてください。</dd>
<dt>Q. : RubyやJavaの言語バインディングで、なぜエラーを例外で処理しないのですか？</dt>
<dd>A. : 例外機構のない言語と共通のインターフェイスにするためです。例外処理を好む人は、独自のラッパーを書いてそれを使ってください。</dd>
<dt>Q. : データベースファイルの名前の拡張子として「.hdb」「.bdb」などを推奨しないのはなぜですか？</dt>
<dd>A. : 世の中にはTokyo Cabinet以外にもデータベースライブラリがたくさんあり、それらのハッシュデータベースやB+木データベースと区別がつかなくなるからです。代わりに「.tch」「.tcb」などを使ってください。</dd>
<dt>Q. : QDBMはもうメンテナンスしないのですか？</dt>
<dd>A. : メンテナンスは続けます。積極的な機能追加の予定はありませんが、もしバグが見つかれば対処します。</dd>
<dt>Q. : Windowsで利用できませんか？</dt>
<dd>A. : 残念ながらできません。今のところ対応予定もありません。</dd>
<dt>Q. : ライセンスをBSDLかMITLに変えてくれませんか？</dt>
<dd>A. : 嫌です。そうすることに特に利点を感じません。</dd>
<dt>Q. : 「Tokyo Cabinet」の名前の由来はなんですか？</dt>
<dd>A. : 作者が住んでいる街なので「tokyo」で、モノをしまうから「cabinet」です。略して「TC」と呼ぶのもよい考えです。「東京キャビネット」とか「とうきょうきゃびねっと」とかいう表記でも構いません。東京ディズニーランドや東京ラブストーリーや東京パフォーマンスドールとは一切関係ありません。識別子以外で「TokyoCabinet」とつなげて表記するのは推奨しません。</dd>
<dt>Q. : あなたは千葉県とどういう関係なのですか？</dt>
<dd>A. : 特に関係はありません。出身地は埼玉県です。落花生は好きです。</dd>
</dl>

<hr />

<h2 id="license">ライセンス</h2>

<p>Tokyo Cabinetはフリーソフトウェアです。あなたは、Free Software Foundationが公表したGNU Lesser General Public Licenseのバージョン2.1あるいはそれ以降の各バージョンの中からいずれかを選択し、そのバージョンが定める条項に従ってTokyo Cabinetを再頒布または変更することができます。</p>

<p>Tokyo Cabinetは有用であると思われますが、頒布にあたっては、市場性及び特定目的適合性についての暗黙の保証を含めて、いかなる保証も行ないません。詳細についてはGNU Lesser General Public Licenseを読んでください。</p>

<p>あなたは、Tokyo Cabinetと一緒にGNU Lesser General Public Licenseの写しを受け取っているはずです（`<code>COPYING</code>' ファイルを参照してください）。そうでない場合は、Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA へ連絡してください。</p>

<p>Tokyo CabinetはFAL Labsが作成しました。作者と連絡をとるには、`<code>info@fallabs.com</code>' 宛に電子メールを送ってください。</p>

<hr />

</body>

</html>

<!-- END OF FILE -->
