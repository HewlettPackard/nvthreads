o Atlas is a high-level programming environment for non-volatile
memory. In-memory objects can be persisted or made durable with
relatively minor changes to code. There are 2 classes of APIs:
persistent region APIs and consistency APIs. The first class is used
to create/find/delete containers that store persistent data and can
be found in include/atlas_alloc.h. The second class is used to convey
data-consistency information to the system. Currently, this includes a
durable section (demarcated by begin_durable and end_durable) and
classical lock-based critical sections. Support for atomic sections
(aka transactions) is planned but currently does not exist in the
implementation. See include/atlas_api.h for these interfaces. 

o In the absence of compiler support, the programmer must call into
Atlas explicitly to provide data consistency. For a sequential
program, this usually involves adding durable sections and replacing
stores with NVM_STR. For a lock-based multithreaded (MT) program, this
usually involves adding NVM_LOCK/NVM_UNLOCK along with NVM_STR
operations. See the examples directory for illustration. If an
Atlas-aware compiler is available, dealing with non-trivial code is
much easier since, for consistency, all you need are durable sections
in sequential programs and absolutely nothing for lock-based MT
programs.

o For more on the design, see HP Labs internal technical report, "An
API for non-volatile memory",
http://library.hp.com/techpubs/2013/HPL-2013-60.html

For details on MT-durability semantics, see the external HotPar2013
paper, "Durability semantics for lock-based multithreaded programs",
https://www.usenix.org/conference/hotpar13/durability-semantics-lock-based-multithreaded-programs

o Atlas has been currently tested only on Linux x86-64.

o The Atlas top level directory has a number of subdirectories:
  include: contains the headers with exported interfaces. These are
  the only headers that should be included in applications.
  lib: this is where the built Atlas library goes.
  src: the source files
  tools: The recovery tool goes here. The ruby test driver is here as well.
  examples: example programs
  tests: directory used for testing. Contains binaries, inputs,
  outputs, reference files, etc.  

o The Atlas library and tools require the atomic_ops package. See
http://www.hpl.hp.com/research/linux/atomic_ops/index.php4
on how to install this package.

o Edit makefile to make appropriate changes to ATLAS_ROOTDIR and
ATOMIC_OPS_ROOTDIR. At this point, the Atlas installation assumes that
the atomic_ops package has the headers and the library in the
subdirectories "include" and "lib" respectively.

o Do a "make all" in the Atlas root directory. This will make the
default Atlas library, the recovery tool, and the examples. There are
other modes that you can build as well, using "make clean <mode>",
where mode can be:
  * all: This is the default where stores to persistent data
immediately flushed out but log elision is done using dynamic
analysis. Immediate flushing still appears superior to modes "flc" and
"fgc" (see below) in general.
  * always-log: Though it may be correct to elide logging some updates
outside critical sections, this mode does not perform any such
elision.
  * always-log-stats: Same as always-log, but the tests may be
configured to print out statistics.
  * force-fail: Tests are configured to exit in the middle of
execution. Designed to simulate a crash.
  * force-fail-trace: Same as above but with traces enabled.
  * flc: (flush at local commit points) Stores to persistent memory
are not immediately flushed out, instead they get deferred till the
end of a critical section.
  * flc-stats: Same as above but with stats turned on.
  * flc-always-log: Same as above but don't perform any log elision.
  * flc-always-log-stats: Same as above but with stats turned on.
  * fgc: (flush at global commit points) Stores to persistent memory
are not immediately flushed out, instead they are handled by the
helper thread. In a way they get globally optimized.
  * fgc-stats: Same as above but with stats turned on.
  * stats: statistics on
  * disable-flush: cache line flushes are turned on.
  * disable-flush-stats: Same as above but with statistics turned on.
  * flc-disable-flush
  * fgc-disable-flush
  * flc-disable-flush-stats

o There are 2 testing modes currently. "make quick-test" will build
Atlas in the default mode and run some tests. This is a good quick
test during development. "make test" will build Atlas in various modes
and run tests for each of the modes. Before any checkin, this must be
done. Tests include crash/recovery and performance runs.

o In order to invoke any of the examples, change directory to the
subdirectory "example", and invoke the executable. The library assumes
that /dev/shm is available, has enough space, and has rwx
permissions. If the program fails for some reason, the recovery
process must be initiated before the program can be run again. For
that purpose, invoke "tools/recover <program executable name>". Once
recovery is done, the program can be run again as before. Consider the
executable nvm_queue as an example. Use the following steps:
% cd examples
% ./queue_nvm
If the program crashes or is killed, then invoke recovery as below:
% ../tools/recover queue_nvm
To rerun, do the following:
% ./queue_nvm

o Description of examples:
  * "examples/queue_orig" shows a vanilla implementation of a
multithreaded queue.
  * "examples/queue_nvm" is the corresponding persistent queue.
  * "examples/cow_array_list" is a vanilla implementation of a
copy-on-write array implementation, inspired by Java
CopyOnWriteArrayList.
  * "examples/cow_array_list_nvm" is the corresponding persistent
array implementation.
  * "examples/sll" is a vanilla serial singly linked list.
  * "examples/sll_ll" is a persistent serial singly linked list,
written using a low-level NVRAM API.
  * "examples/sll_nvm" is a persistent serial singly linked list,
written using the higher-level Atlas API.
  * "examples/c-hashtable-nvm/tester" uses a persistent hashtable. The
persistent version is an adaptation of an open source implementation.

o Sometimes we just need to clean /dev/shm. Use "make clean_memory"
for this purpose.

